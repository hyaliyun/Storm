import{_ as m,o as n,c as a,a as t,m as d,t as h,C as g,M as b,U as w,f as u,F as y,p as x,e as v,q as _}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},E={class:"poem-container"},T={class:"review"},I={class:"review-title"},O={class:"review-content"};function q(i,e,l,p,r,s){return n(),a("div",E,[t("div",T,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(l.poem.prompt),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",O,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(l.poem.completion),1)])])])}const j=m(k,[["render",q],["__scopeId","data-v-d284fc47"]]),C=JSON.parse('[{"prompt":"You are given two strings `a` and `b` that consist of lowercase letters. In one operation, you can change any character in `a` or `b` to **any lowercase letter**. Your goal is to satisfy **one** of the following three conditions: * **Every** letter in `a` is **strictly less** than **every** letter in `b` in the alphabet. * **Every** letter in `b` is **strictly less** than **every** letter in `a` in the alphabet. * **Both** `a` and `b` consist of **only one** distinct letter. Return _the **minimum** number of operations needed to achieve your goal._ **Example 1:** **Input:** a = aba , b = caa **Output:** 2 **Explanation:** Consider the best way to make each condition true: 1) Change b to ccc in 2 operations, then every letter in a is less than every letter in b. 2) Change a to bbb and b to aaa in 3 operations, then every letter in b is less than every letter in a. 3) Change a to aaa and b to aaa in 2 operations, then a and b consist of one distinct letter. The best way was done in 2 operations (either condition 1 or condition 3). **Example 2:** **Input:** a = dabadd , b = cda **Output:** 3 **Explanation:** The best way is to make condition 1 true by changing b to eee . **Constraints:** * `1 <= a.length, b.length <= 105` * `a` and `b` consist only of lowercase letters.","completion":"def maxDepth(s: str) -> int: depth, max_depth = 0, 0 for ch in s: if ch == \'(\': depth += 1 elif ch == \')\': depth -= 1 max_depth = max(max_depth, depth) return max_depth"},{"prompt":"You are given two strings `s1` and `s2` of equal length. A **string swap** is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return `true` _if it is possible to make both strings equal by performing **at most one string swap** on **exactly one** of the strings._ Otherwise, return `false`. **Example 1:** **Input:** s1 = bank , s2 = kanb **Output:** true **Explanation:** For example, swap the first character with the last character of s2 to make bank . **Example 2:** **Input:** s1 = attack , s2 = defend **Output:** false **Explanation:** It is impossible to make them equal with one string swap. **Example 3:** **Input:** s1 = kelb , s2 = kelb **Output:** true **Explanation:** The two strings are already equal, so no string swap operation is required. **Constraints:** * `1 <= s1.length, s2.length <= 100` * `s1.length == s2.length` * `s1` and `s2` consist of only lowercase English letters.","completion":"def are_almost_equal(s1, s2): if s1 == s2: return True diff = [i for i in range(len(s1)) if s1[i] != s2[i]] return len(diff) == 2 and s1[diff[0]] == s2[diff[1]] and s1[diff[1]] == s2[diff[0]]"},{"prompt":"You are given an `m x n` grid `grid` where: * `\'.\'` is an empty cell. * `\'#\'` is a wall. * `\'@\'` is the starting point. * Lowercase letters represent keys. * Uppercase letters represent locks. You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall. If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key. For some `1 <= k <= 6`, there is exactly one lowercase and one uppercase letter of the first `k` letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return _the lowest number of moves to acquire all keys_. If it is impossible, return `1`. **Example 1:** **Input:** grid = [ @.a.. , #.# , b.A.B ] **Output:** 8 **Explanation:** Note that the goal is to obtain all the keys not to open all the locks. **Example 2:** **Input:** grid = [ @..aA , ..B#. , ....b ] **Output:** 6 **Example 3:** **Input:** grid = [ @Aa ] **Output:** 1 **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 30` * `grid[i][j]` is either an English letter, `\'.\'`, `\'#\'`, or `\'@\'`. * The number of keys in the grid is in the range `[1, 6]`. * Each key in the grid is **unique**. * Each key in the grid has a matching lock.","completion":"def largestOverlap(img1, img2): n = len(img1) onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]] onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]] overlaps = {} for pt1 in onesImg1: for pt2 in onesImg2: dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1] key = (dx, dy) if key not in overlaps: overlaps[key] = 0 overlaps[key] += 1 return max(overlaps.values() or [0])"},{"prompt":"You are given a **positive** integer `num` consisting of exactly four digits. Split `num` into two new integers `new1` and `new2` by using the **digits** found in `num`. **Leading zeros** are allowed in `new1` and `new2`, and **all** the digits found in `num` must be used. * For example, given `num = 2932`, you have the following digits: two `2`\'s, one `9` and one `3`. Some of the possible pairs `[new1, new2]` are `[22, 93]`, `[23, 92]`, `[223, 9]` and `[2, 329]`. Return _the **minimum** possible sum of_ `new1` _and_ `new2`. **Example 1:** **Input:** num = 2932 **Output:** 52 **Explanation:** Some possible pairs [new1, new2] are [29, 23], [223, 9], etc. The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52. **Example 2:** **Input:** num = 4009 **Output:** 13 **Explanation:** Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13. **Constraints:** * `1000 <= num <= 9999`","completion":"def min_operations(grid, x): min_element = min(min(row) for row in grid) min_ops = float(\'inf\') base = min_element while True: operations = 0 impossible = False for row in grid: if impossible: break for cell in row: diff = abs(cell - base) if diff % x != 0: impossible = True break operations += diff // x if impossible: break min_ops = min(min_ops, operations) base -= 1 return -1 if min_ops == float(\'inf\') else min_ops"},{"prompt":"There is a forest with an unknown number of rabbits. We asked n rabbits **How many rabbits have the same color as you? ** and collected the answers in an integer array `answers` where `answers[i]` is the answer of the `ith` rabbit. Given the array `answers`, return _the minimum number of rabbits that could be in the forest_. **Example 1:** **Input:** answers = [1,1,2] **Output:** 5 **Explanation:** The two rabbits that answered 1 could both be the same color, say red. The rabbit that answered 2 can\'t be red or the answers would be inconsistent. Say the rabbit that answered 2 was blue. Then there should be 2 other blue rabbits in the forest that didn\'t answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn\'t. **Example 2:** **Input:** answers = [10,10,10] **Output:** 11 **Constraints:** * `1 <= answers.length <= 1000` * `0 <= answers[i] < 1000`","completion":"from collections import Counter def numRabbits(answers): count = Counter(answers) rabbits = 0 for ans, cnt in count.items(): rabbits += (ans + cnt)//(ans + 1) * (ans + 1) return rabbits"},{"prompt":"Given an array `nums` of positive integers, return the longest possible length of an array prefix of `nums`, such that it is possible to remove **exactly one** element from this prefix so that every number that has appeared in it will have the same number of occurrences. If after removing one element there are no remaining elements, it\'s still considered that every appeared number has the same number of ocurrences (0). **Example 1:** **Input:** nums = [2,2,1,1,5,3,3,5] **Output:** 7 **Explanation:** For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4] = 5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice. **Example 2:** **Input:** nums = [1,1,1,2,2,2,3,3,3,4,4,4,5] **Output:** 13 **Constraints:** * `2 <= nums.length <= 105` * `1 <= nums[i] <= 105`","completion":"def minFallingPathSum(grid): n = len(grid) for i in range(1, n): for j in range(n): minVal = float(\'inf\') for k in range(n): if k == j: continue minVal = min(minVal, grid[i - 1][k]) grid[i][j] += minVal return min(grid[n - 1])"},{"prompt":"There is a regular convex polygon with `n` vertices. The vertices are labeled from `0` to `n 1` in a clockwise direction, and each vertex has **exactly one monkey**. The following figure shows a convex polygon of `6` vertices. Each monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex `i` can be: * the vertex `(i + 1) % n` in the clockwise direction, or * the vertex `(i 1 + n) % n` in the counterclockwise direction. A **collision** happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge. Return _the number of ways the monkeys can move so that at least **one collision**_ _happens_. Since the answer may be very large, return it modulo `109 + 7`. **Note** that each monkey can only move once. **Example 1:** **Input:** n = 3 **Output:** 6 **Explanation:** There are 8 total possible movements. Two ways such that they collide at some point are: Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide. Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide. It can be shown 6 total movements result in a collision. **Example 2:** **Input:** n = 4 **Output:** 14 **Explanation:** It can be shown that there are 14 ways for the monkeys to collide. **Constraints:** * `3 <= n <= 109`","completion":"def ways_to_collide(n): MOD = 10**9 + 7 return (pow(2, n, MOD) - n - 1 + MOD) % MOD"},{"prompt":"You are given an `m x n` integer grid `accounts` where `accounts[i][j]` is the amount of money the `i​​​​​​​​​​​th​​​​` customer has in the `j​​​​​​​​​​​th`​​​​ bank. Return _the **wealth** that the richest customer has._ A customer\'s **wealth** is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum **wealth**. **Example 1:** **Input:** accounts = [[1,2,3],[3,2,1]] **Output:** 6 **Explanation****:** `1st customer has wealth = 1 + 2 + 3 = 6` `2nd customer has wealth = 3 + 2 + 1 = 6` Both customers are considered the richest with a wealth of 6 each, so return 6. **Example 2:** **Input:** accounts = [[1,5],[7,3],[3,5]] **Output:** 10 **Explanation**: 1st customer has wealth = 6 2nd customer has wealth = 10 3rd customer has wealth = 8 The 2nd customer is the richest with a wealth of 10. **Example 3:** **Input:** accounts = [[2,8,7],[7,1,3],[1,9,5]] **Output:** 17 **Constraints:** * `m == accounts.length` * `n == accounts[i].length` * `1 <= m, n <= 50` * `1 <= accounts[i][j] <= 100`","completion":"def maximumWealth(accounts): max_wealth = 0 for customer in accounts: wealth = sum(customer) max_wealth = max(max_wealth, wealth) return max_wealth"},{"prompt":"Design a data structure to find the **frequency** of a given value in a given subarray. The **frequency** of a value in a subarray is the number of occurrences of that value in the subarray. Implement the `RangeFreqQuery` class: * `RangeFreqQuery(int[] arr)` Constructs an instance of the class with the given **0indexed** integer array `arr`. * `int query(int left, int right, int value)` Returns the **frequency** of `value` in the subarray `arr[left...right]`. A **subarray** is a contiguous sequence of elements within an array. `arr[left...right]` denotes the subarray that contains the elements of `nums` between indices `left` and `right` (**inclusive**). **Example 1:** **Input** [ RangeFreqQuery , query , query ] [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]] **Output** [null, 1, 2] **Explanation** RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]); rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4] rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array. **Constraints:** * `1 <= arr.length <= 105` * `1 <= arr[i], value <= 104` * `0 <= left <= right < arr.length` * At most `105` calls will be made to `query`","completion":"def check_good_line(board, r, c, color, dr, dc): opp_color = \'B\' if color == \'W\' else \'W\' count = 0 r += dr c += dc while 0 <= r < 8 and 0 <= c < 8 and board[r][c] == opp_color: count += 1 r += dr c += dc return 0 <= r < 8 and 0 <= c < 8 and board[r][c] == color and count >= 2 def is_legal_move(board, r_move, c_move, color): if board[r_move][c_move] != \'.\': return False board[r_move][c_move] = color for dr in range(-1, 2): for dc in range(-1, 2): if not (dr == 0 and dc == 0) and check_good_line(board, r_move, c_move, color, dr, dc): return True return False"},{"prompt":"There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi. The passengers are represented by a **0indexed** 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip. For **each** passenger `i` you pick up, you **earn** `endi starti + tipi` dollars. You may only drive **at most one** passenger at a time. Given `n` and `rides`, return _the **maximum** number of dollars you can earn by picking up the passengers optimally._ **Note:** You may drop off a passenger and pick up a different passenger at the same point. **Example 1:** **Input:** n = 5, rides = [[2,5,4],[1,5,1]] **Output:** 7 **Explanation:** We can pick up passenger 0 to earn 5 2 + 4 = 7 dollars. **Example 2:** **Input:** n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]] **Output:** 20 **Explanation:** We will pick up the following passengers: Drive passenger 1 from point 3 to point 10 for a profit of 10 3 + 2 = 9 dollars. Drive passenger 2 from point 10 to point 12 for a profit of 12 10 + 3 = 5 dollars. Drive passenger 5 from point 13 to point 18 for a profit of 18 13 + 1 = 6 dollars. We earn 9 + 5 + 6 = 20 dollars in total. **Constraints:** * `1 <= n <= 105` * `1 <= rides.length <= 3 * 104` * `rides[i].length == 3` * `1 <= starti < endi <= n` * `1 <= tipi <= 105`","completion":"def minOperationsToFlip(expression: str) -> int: zero, one, op = [0], [0], [] for c in expression: if c == \'&\': op.append(1) elif c == \'|\': op.append(2) elif c.isdigit(): if c == \'0\': one.append(1) zero.append(0) else: zero.append(1) one.append(0) elif c == \')\': cur_op = op.pop() x = zero.pop() y = one.pop() + 1 if cur_op == 1: new_zero = max(x, y) new_one = one[-1] + min(x, zero[-1]) else: new_zero = zero[-1] + min(x, one[-1]) new_one = max(y, one[-1]) zero.pop() one.pop() zero.append(new_zero) one.append(new_one) return zero[-1] + 1"},{"prompt":"Given an integer array `arr`, return _the length of a maximum size turbulent subarray of_ `arr`. A subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray. More formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if: * For `i <= k < j`: * `arr[k] > arr[k + 1]` when `k` is odd, and * `arr[k] < arr[k + 1]` when `k` is even. * Or, for `i <= k < j`: * `arr[k] > arr[k + 1]` when `k` is even, and * `arr[k] < arr[k + 1]` when `k` is odd. **Example 1:** **Input:** arr = [9,4,2,10,7,8,8,1,9] **Output:** 5 **Explanation:** arr[1] > arr[2] < arr[3] > arr[4] < arr[5] **Example 2:** **Input:** arr = [4,8,12,16] **Output:** 2 **Example 3:** **Input:** arr = [100] **Output:** 1 **Constraints:** * `1 <= arr.length <= 4 * 104` * `0 <= arr[i] <= 109`","completion":"def valid_mountain_array(arr): n, i, j = len(arr), 0, len(arr) - 1 while i + 1 < n and arr[i] < arr[i + 1]: i += 1 while j > 0 and arr[j - 1] > arr[j]: j -= 1 return i > 0 and i == j and j < n - 1"},{"prompt":"There is a broken calculator that has the integer `startValue` on its display initially. In one operation, you can: * multiply the number on display by `2`, or * subtract `1` from the number on display. Given two integers `startValue` and `target`, return _the minimum number of operations needed to display_ `target` _on the calculator_. **Example 1:** **Input:** startValue = 2, target = 3 **Output:** 2 **Explanation:** Use double operation and then decrement operation {2 > 4 > 3}. **Example 2:** **Input:** startValue = 5, target = 8 **Output:** 2 **Explanation:** Use decrement and then double {5 > 4 > 8}. **Example 3:** **Input:** startValue = 3, target = 10 **Output:** 3 **Explanation:** Use double, decrement and double {3 > 6 > 5 > 10}. **Constraints:** * `1 <= startValue, target <= 109`","completion":"def can_reorder_array(arr): from collections import Counter count = Counter(arr) arr = sorted(arr) for x in arr: if count[x] == 0: continue if count[2 * x] > 0: count[x] -= 1 count[2 * x] -= 1 else: return False return True"},{"prompt":"A [complex number](https://en.wikipedia.org/wiki/Complex_number) can be represented as a string on the form `**real**+**imaginary**i ` where: * `real` is the real part and is an integer in the range `[100, 100]`. * `imaginary` is the imaginary part and is an integer in the range `[100, 100]`. * `i2 == 1`. Given two complex numbers `num1` and `num2` as strings, return _a string of the complex number that represents their multiplications_. **Example 1:** **Input:** num1 = 1+1i , num2 = 1+1i **Output:** 0+2i **Explanation:** (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. **Example 2:** **Input:** num1 = 1+1i , num2 = 1+1i **Output:** 0+2i **Explanation:** (1 i) * (1 i) = 1 + i2 2 * i = 2i, and you need convert it to the form of 0+2i. **Constraints:** * `num1` and `num2` are valid complex numbers.","completion":"def complexNumberMultiply(num1: str, num2: str) -> str: real1, imag1 = map(int, num1[:-1].split(\'+\')) real2, imag2 = map(int, num2[:-1].split(\'+\')) real = real1 * real2 - imag1 * imag2 imag = real1 * imag2 + real2 * imag1 return f\\"{real}+{imag}i\\""},{"prompt":"Given an initial array `arr`, every day you produce a new array using the array of the previous day. On the `i`th day, you do the following operations on the array of day `i1` to produce the array of day `i`: 1. If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented. 2. If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented. 3. The first and last elements never change. After some days, the array does not change. Return that final array. **Example 1:** **Input:** arr = [6,2,3,4] **Output:** [6,3,3,4] **Explanation:** On the first day, the array is changed from [6,2,3,4] to [6,3,3,4]. No more operations can be done to this array. **Example 2:** **Input:** arr = [1,6,3,4,3,5] **Output:** [1,4,4,4,4,5] **Explanation:** On the first day, the array is changed from [1,6,3,4,3,5] to [1,5,4,3,4,5]. On the second day, the array is changed from [1,5,4,3,4,5] to [1,4,4,4,4,5]. No more operations can be done to this array. **Constraints:** * `3 <= arr.length <= 100` * `1 <= arr[i] <= 100`","completion":"def sumEvenGrandparent(root, parent=None, grandparent=None): if not root: return 0 sum = 0 if grandparent and grandparent.val % 2 == 0: sum += root.val sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent) return sum"},{"prompt":"You are given a positive integer `n` representing the number of nodes in an **undirected** graph. The nodes are labeled from `1` to `n`. You are also given a 2D integer array `edges`, where `edges[i] = [ai, bi]` indicates that there is a **bidirectional** edge between nodes `ai` and `bi`. **Notice** that the given graph may be disconnected. Divide the nodes of the graph into `m` groups (**1indexed**) such that: * Each node in the graph belongs to exactly one group. * For every pair of nodes in the graph that are connected by an edge `[ai, bi]`, if `ai` belongs to the group with index `x`, and `bi` belongs to the group with index `y`, then `|y x| = 1`. Return _the maximum number of groups (i.e., maximum_ `m`_) into which you can divide the nodes_. Return `1` _if it is impossible to group the nodes with the given conditions_. **Example 1:** **Input:** n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]] **Output:** 4 **Explanation:** As shown in the image we: Add node 5 to the first group. Add node 1 to the second group. Add nodes 2 and 4 to the third group. Add nodes 3 and 6 to the fourth group. We can see that every edge is satisfied. It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied. **Example 2:** **Input:** n = 3, edges = [[1,2],[2,3],[3,1]] **Output:** 1 **Explanation:** If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied. It can be shown that no grouping is possible. **Constraints:** * `1 <= n <= 500` * `1 <= edges.length <= 104` * `edges[i].length == 2` * `1 <= ai, bi <= n` * `ai != bi` * There is at most one edge between any pair of vertices.","completion":"from collections import defaultdict, deque def maxGroups(n, edges): graph = defaultdict(list) color = [0] * (n + 1) for edge in edges: graph[edge[0]].append(edge[1]) graph[edge[1]].append(edge[0]) max_group = 0 for i in range(1, n + 1): if color[i] == 0: q = deque([i]) color[i] = 1 while q: node = q.popleft() max_group = max(max_group, color[node]) for neighbor in graph[node]: if color[neighbor] == 0: color[neighbor] = color[node] + 1 q.append(neighbor) elif color[neighbor] == color[node]: return -1 return max_group"},{"prompt":"You and a gang of thieves are planning on robbing a bank. You are given a **0indexed** integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`. The `ith` day is a good day to rob the bank if: * There are at least `time` days before and after the `ith` day, * The number of guards at the bank for the `time` days **before** `i` are **nonincreasing**, and * The number of guards at the bank for the `time` days **after** `i` are **nondecreasing**. More formally, this means day `i` is a good day to rob the bank if and only if `security[i time] >= security[i time + 1] >= ... >= security[i] <= ... <= security[i + time 1] <= security[i + time]`. Return _a list of **all** days **(0indexed)** that are good days to rob the bank_. _The order that the days are returned in does **not** matter._ **Example 1:** **Input:** security = [5,3,3,3,5,6,2], time = 2 **Output:** [2,3] **Explanation:** On day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4]. On day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5]. No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank. **Example 2:** **Input:** security = [1,1,1,1,1], time = 0 **Output:** [0,1,2,3,4] **Explanation:** Since time equals 0, every day is a good day to rob the bank, so return every day. **Example 3:** **Input:** security = [1,2,3,4,5,6], time = 2 **Output:** [] **Explanation:** No day has 2 days before it that have a nonincreasing number of guards. Thus, no day is a good day to rob the bank, so return an empty list. **Constraints:** * `1 <= security.length <= 105` * `0 <= security[i], time <= 105`","completion":"def minNonZeroProduct(p): MOD = 10**9 + 7 prod = 1 a = (1 << p) - 2 b = ((1 << p) - 1) % MOD while a > 0: if a % 2: prod = (prod * b) % MOD b = (b * b) % MOD a //= 2 return prod"},{"prompt":"You are given a 2D integer array `items` where `items[i] = [pricei, weighti]` denotes the price and weight of the `ith` item, respectively. You are also given a **positive** integer `capacity`. Each item can be divided into two items with ratios `part1` and `part2`, where `part1 + part2 == 1`. * The weight of the first item is `weighti * part1` and the price of the first item is `pricei * part1`. * Similarly, the weight of the second item is `weighti * part2` and the price of the second item is `pricei * part2`. Return _**the maximum total price** to fill a bag of capacity_ `capacity` _with given items_. If it is impossible to fill a bag return `1`. Answers within `105` of the **actual answer** will be considered accepted. **Example 1:** **Input:** items = [[50,1],[10,8]], capacity = 5 **Output:** 55.00000 **Explanation:** We divide the 2nd item into two parts with part1 = 0.5 and part2 = 0.5. The price and weight of the 1st item are 5, 4. And similarly, the price and the weight of the 2nd item are 5, 4. The array items after operation becomes [[50,1],[5,4],[5,4]]. To fill a bag with capacity 5 we take the 1st element with a price of 50 and the 2nd element with a price of 5. It can be proved that 55.0 is the maximum total price that we can achieve. **Example 2:** **Input:** items = [[100,30]], capacity = 50 **Output:** 1.00000 **Explanation:** It is impossible to fill a bag with the given item. **Constraints:** * `1 <= items.length <= 105` * `items[i].length == 2` * `1 <= pricei, weighti <= 104` * `1 <= capacity <= 109`","completion":"def maxValue(items, capacity): items.sort(key=lambda x: x[0] / x[1], reverse=True) maxTotalPrice = 0 for item in items: if capacity >= item[1]: capacity -= item[1] maxTotalPrice += item[0] else: maxTotalPrice += item[0] * capacity / item[1] break return maxTotalPrice"},{"prompt":"You are given the `root` of a binary tree and an integer `distance`. A pair of two different **leaf** nodes of a binary tree is said to be good if the length of **the shortest path** between them is less than or equal to `distance`. Return _the number of good leaf node pairs_ in the tree. **Example 1:** **Input:** root = [1,2,3,null,4], distance = 3 **Output:** 1 **Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair. **Example 2:** **Input:** root = [1,2,3,4,5,6,7], distance = 3 **Output:** 2 **Explanation:** The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4. **Example 3:** **Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 **Output:** 1 **Explanation:** The only good pair is [2,5]. **Constraints:** * The number of nodes in the `tree` is in the range `[1, 210].` * `1 <= Node.val <= 100` * `1 <= distance <= 10`","completion":"def check_if_can_break(s1, s2): s1 = sorted(s1) s2 = sorted(s2) can_break_1 = can_break_2 = True for c1, c2 in zip(s1, s2): if c1 < c2: can_break_1 = False if c2 < c1: can_break_2 = False return can_break_1 or can_break_2"},{"prompt":"Given two positive integers `a` and `b`, return _the number of **common** factors of_ `a` _and_ `b`. An integer `x` is a **common factor** of `a` and `b` if `x` divides both `a` and `b`. **Example 1:** **Input:** a = 12, b = 6 **Output:** 4 **Explanation:** The common factors of 12 and 6 are 1, 2, 3, 6. **Example 2:** **Input:** a = 25, b = 30 **Output:** 2 **Explanation:** The common factors of 25 and 30 are 1, 5. **Constraints:** * `1 <= a, b <= 1000`","completion":"def common_factors(a: int, b: int) -> int: from math import gcd g = gcd(a, b) count = 0 for i in range(1, int(g**0.5) + 1): if g % i == 0: count += 1 if i * i != g: count += 1 return count"},{"prompt":"The Leetcode file system keeps a log each time some user performs a _change folder_ operation. The operations are described below: * `../ ` : Move to the parent folder of the current folder. (If you are already in the main folder, **remain in the same folder**). * `./ ` : Remain in the same folder. * `x/ ` : Move to the child folder named `x` (This folder is **guaranteed to always exist**). You are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step. The file system starts in the main folder, then the operations in `logs` are performed. Return _the minimum number of operations needed to go back to the main folder after the change folder operations._ **Example 1:** **Input:** logs = [ d1/ , d2/ , ../ , d21/ , ./ ] **Output:** 2 **Explanation:** Use this change folder operation ../ 2 times and go back to the main folder. **Example 2:** **Input:** logs = [ d1/ , d2/ , ./ , d3/ , ../ , d31/ ] **Output:** 3 **Example 3:** **Input:** logs = [ d1/ , ../ , ../ , ../ ] **Output:** 0 **Constraints:** * `1 <= logs.length <= 103` * `2 <= logs[i].length <= 10` * `logs[i]` contains lowercase English letters, digits, `\'.\'`, and `\'/\'`. * `logs[i]` follows the format described in the statement. * Folder names consist of lowercase English letters and digits.","completion":"def minOperations(logs): depth = 0 for log in logs: if log == \\"../\\": depth = max(0, depth - 1) elif log != \\"./\\": depth += 1 return depth"},{"prompt":"There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows: * Eat one orange. * If the number of remaining oranges `n` is divisible by `2` then you can eat `n / 2` oranges. * If the number of remaining oranges `n` is divisible by `3` then you can eat `2 * (n / 3)` oranges. You can only choose one of the actions per day. Given the integer `n`, return _the minimum number of days to eat_ `n` _oranges_. **Example 1:** **Input:** n = 10 **Output:** 4 **Explanation:** You have 10 oranges. Day 1: Eat 1 orange, 10 1 = 9. Day 2: Eat 6 oranges, 9 2*(9/3) = 9 6 = 3. (Since 9 is divisible by 3) Day 3: Eat 2 oranges, 3 2*(3/3) = 3 2 = 1. Day 4: Eat the last orange 1 1 = 0. You need at least 4 days to eat the 10 oranges. **Example 2:** **Input:** n = 6 **Output:** 3 **Explanation:** You have 6 oranges. Day 1: Eat 3 oranges, 6 6/2 = 6 3 = 3. (Since 6 is divisible by 2). Day 2: Eat 2 oranges, 3 2*(3/3) = 3 2 = 1. (Since 3 is divisible by 3) Day 3: Eat the last orange 1 1 = 0. You need at least 3 days to eat the 6 oranges. **Constraints:** * `1 <= n <= 2 * 109`","completion":"def countTriplets(arr): n = len(arr) XOR = [0] * (n + 1) for i in range(n): XOR[i+1] = XOR[i] ^ arr[i] count = 0 for i in range(n): for k in range(i+1, n): if XOR[i] == XOR[k+1]: count += k-i return count"},{"prompt":"Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_. The distance between two adjacent cells is `1`. **Example 1:** **Input:** mat = [[0,0,0],[0,1,0],[0,0,0]] **Output:** [[0,0,0],[0,1,0],[0,0,0]] **Example 2:** **Input:** mat = [[0,0,0],[0,1,0],[1,1,1]] **Output:** [[0,0,0],[0,1,0],[1,2,1]] **Constraints:** * `m == mat.length` * `n == mat[i].length` * `1 <= m, n <= 104` * `1 <= m * n <= 104` * `mat[i][j]` is either `0` or `1`. * There is at least one `0` in `mat`.","completion":"from collections import deque def updateMatrix(mat): m, n = len(mat), len(mat[0]) distance = [[0 if mat[i][j] == 0 else float(\'inf\') for j in range(n)] for i in range(m)] queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: newX, newY = x + dx, y + dy if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1: distance[newX][newY] = distance[x][y] + 1 queue.append((newX, newY)) return distance"},{"prompt":"There is a long table with a line of plates and candles arranged on top of it. You are given a **0indexed** string `s` consisting of characters `\'*\'` and `\'|\'` only, where a `\'*\'` represents a **plate** and a `\'|\'` represents a **candle**. You are also given a **0indexed** 2D integer array `queries` where `queries[i] = [lefti, righti]` denotes the **substring** `s[lefti...righti]` (**inclusive**). For each query, you need to find the **number** of plates **between candles** that are **in the substring**. A plate is considered **between candles** if there is at least one candle to its left **and** at least one candle to its right **in the substring**. * For example, `s = ||**||**|* `, and a query `[3, 8]` denotes the substring `*||******| `. The number of plates between candles in this substring is `2`, as each of the two plates has at least one candle **in the substring** to its left **and** right. Return _an integer array_ `answer` _where_ `answer[i]` _is the answer to the_ `ith` _query_. **Example 1:** **Input:** s = **|**|***| , queries = [[2,5],[5,9]] **Output:** [2,3] **Explanation:** queries[0] has two plates between candles. queries[1] has three plates between candles. **Example 2:** **Input:** s = ***|**|*****|**||**|* , queries = [[1,17],[4,5],[14,17],[5,11],[15,16]] **Output:** [9,0,0,0,0] **Explanation:** queries[0] has nine plates between candles. The other queries have zero plates between candles. **Constraints:** * `3 <= s.length <= 105` * `s` consists of `\'*\'` and `\'|\'` characters. * `1 <= queries.length <= 105` * `queries[i].length == 2` * `0 <= lefti <= righti < s.length`","completion":"from collections import defaultdict def splitPainting(segments): changes = defaultdict(int) for start, end, color in segments: changes[start] += color changes[end] -= color result = [] start, color_sum = 0, 0 for key in sorted(changes.keys()): if start != key: if color_sum: result.append([start, key, color_sum]) start = key color_sum += changes[key] return result"},{"prompt":"Given the string `s`, return the size of the longest substring containing each vowel an even number of times. That is, \'a\', \'e\', \'i\', \'o\', and \'u\' must appear an even number of times. **Example 1:** **Input:** s = eleetminicoworoep **Output:** 13 **Explanation:** The longest substring is leetminicowor which contains two each of the vowels: **e**, **i** and **o** and zero of the vowels: **a** and **u**. **Example 2:** **Input:** s = leetcodeisgreat **Output:** 5 **Explanation:** The longest substring is leetc which contains two e\'s. **Example 3:** **Input:** s = bcbcbc **Output:** 6 **Explanation:** In this case, the given string bcbcbc is the longest because all vowels: **a**, **e**, **i**, **o** and **u** appear zero times. **Constraints:** * `1 <= s.length <= 5 x 10^5` * `s` contains only lowercase English letters. It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.","completion":"def min_remove_to_make_valid(s: str) -> str: stk = [] result = list(s) for i, ch in enumerate(s): if ch == \'(\': stk.append(i) elif ch == \')\': if stk: stk.pop() else: result[i] = \'\' for i in stk: result[i] = \'\' return \'\'.join(result)"},{"prompt":"For a binary tree **T**, we can define a **flip operation** as follows: choose any node, and swap the left and right child subtrees. A binary tree **X** is _flip equivalent_ to a binary tree **Y** if and only if we can make **X** equal to **Y** after some number of flip operations. Given the roots of two binary trees `root1` and `root2`, return `true` if the two trees are flip equivalent or `false` otherwise. **Example 1:** **Input:** root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] **Output:** true **Explanation:** We flipped at nodes with values 1, 3, and 5. **Example 2:** **Input:** root1 = [], root2 = [] **Output:** true **Example 3:** **Input:** root1 = [], root2 = [1] **Output:** false **Constraints:** * The number of nodes in each tree is in the range `[0, 100]`. * Each tree will have **unique node values** in the range `[0, 99]`.","completion":"def partitionDisjoint(nums): left_max, global_max, left_length = nums[0], nums[0], 1 for i in range(1, len(nums)): if nums[i] < left_max: left_max = global_max left_length = i + 1 else: global_max = max(global_max, nums[i]) return left_length"},{"prompt":"ernational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: * `\'a\'` maps to `. `, * `\'b\'` maps to `... `, * `\'c\'` maps to `.. `, and so on. For convenience, the full table for the `26` letters of the English alphabet is given below: [ . , ... , .. , .. , . , ... , . , .... , .. , . , . , ... , , . , , .. , . , .. , ... , , .. , ... , . , .. , . , .. ] Given an array of strings `words` where each word can be written as a concatenation of the Morse code of each letter. * For example, `cab ` can be written as `...... `, which is the concatenation of `.. `, `. `, and `... `. We will call such a concatenation the **transformation** of a word. Return _the number of different **transformations** among all words we have_. **Example 1:** **Input:** words = [ gin , zen , gig , msg ] **Output:** 2 **Explanation:** The transformation of each word is: gin > .... zen > .... gig > .... msg > .... There are 2 different transformations: .... and .... . **Example 2:** **Input:** words = [ a ] **Output:** 1 **Constraints:** * `1 <= words.length <= 100` * `1 <= words[i].length <= 12` * `words[i]` consists of lowercase English letters.","completion":"def rotated_digits(n): count = 0 for i in range(1, n + 1): is_valid_after_rotation = True is_different_after_rotation = False num = i while num: digit = num % 10 if digit in {3, 4, 7}: is_valid_after_rotation = False break if digit in {2, 5, 6, 9}: is_different_after_rotation = True num //= 10 if is_valid_after_rotation and is_different_after_rotation: count += 1 return count"},{"prompt":"A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `\'0\'` with the letter `\'O\'`, and the digit `\'1\'` with the letter `\'I\'`. Such a representation is valid if and only if it consists only of the letters in the set `{\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'I\', \'O\'}`. Given a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `ERROR `. **Example 1:** **Input:** num = 257 **Output:** IOI **Explanation:** 257 is 101 in hexadecimal. **Example 2:** **Input:** num = 3 **Output:** ERROR **Constraints:** * `1 <= num.length <= 12` * `num` does not contain leading zeros. * num represents an integer in the range `[1, 1012]`.","completion":"def to_hexspeak(num: str) -> str: n = int(num) hex_str = [] while n: rem = n % 16 if rem == 1: hex_str.insert(0, \'I\') elif rem == 0: hex_str.insert(0, \'O\') elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord(\'A\'))) else: return \'ERROR\' n //= 16 return \'\'.join(hex_str)"},{"prompt":"There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker. We want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules: 1. Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group. 2. Every worker in the paid group must be paid at least their minimum wage expectation. Given the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** quality = [10,20,5], wage = [70,50,30], k = 2 **Output:** 105.00000 **Explanation:** We pay 70 to 0th worker and 35 to 2nd worker. **Example 2:** **Input:** quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3 **Output:** 30.66667 **Explanation:** We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately. **Constraints:** * `n == quality.length == wage.length` * `1 <= k <= n <= 104` * `1 <= quality[i], wage[i] <= 104`","completion":"def largeGroupPositions(s: str): result = [] start = 0 for i in range(1, len(s)): if s[i] != s[start]: if i - start >= 3: result.append([start, i - 1]) start = i if len(s) - start >= 3: result.append([start, len(s) - 1]) return result"},{"prompt":"Given a **0indexed** string `word` and a character `ch`, **reverse** the segment of `word` that starts at index `0` and ends at the index of the **first occurrence** of `ch` (**inclusive**). If the character `ch` does not exist in `word`, do nothing. * For example, if `word = abcdefd ` and `ch = d `, then you should **reverse** the segment that starts at `0` and ends at `3` (**inclusive**). The resulting string will be `dcbaefd `. Return _the resulting string_. **Example 1:** **Input:** word = abcdefd , ch = d **Output:** dcbaefd **Explanation:** The first occurrence of d is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is dcbaefd . **Example 2:** **Input:** word = xyxzxe , ch = z **Output:** zxyxxe **Explanation:** The first and only occurrence of z is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is zxyxxe . **Example 3:** **Input:** word = abcd , ch = z **Output:** abcd **Explanation:** z does not exist in word. You should not do any reverse operation, the resulting string is abcd . **Constraints:** * `1 <= word.length <= 250` * `word` consists of lowercase English letters. * `ch` is a lowercase English letter.","completion":"import math def minimum_speed(n, hour, dist): if n > math.ceil(hour): return -1 low, high = 1, int(1e7) while low <= high: mid = low + (high - low) // 2 time = sum(math.ceil(d / mid) for d in dist) if time <= hour: speed = mid high = mid - 1 else: low = mid + 1 return speed"},{"prompt":"LeetCode company workers use keycards to unlock office doors. Each time a worker uses their keycard, the security system saves the worker\'s name and the time when it was used. The system emits an **alert** if any worker uses the keycard **three or more times** in a onehour period. You are given a list of strings `keyName` and `keyTime` where `[keyName[i], keyTime[i]]` corresponds to a person\'s name and the time when their keycard was used **in a** **single day**. Access times are given in the **24hour time format HH:MM **, such as `23:51 ` and `09:49 `. Return a _list of unique worker names who received an alert for frequent keycard use_. Sort the names in **ascending order alphabetically**. Notice that `10:00 ` `11:00 ` is considered to be within a onehour period, while `22:51 ` `23:52 ` is not considered to be within a onehour period. **Example 1:** **Input:** keyName = [ daniel , daniel , daniel , luis , luis , luis , luis ], keyTime = [ 10:00 , 10:40 , 11:00 , 09:00 , 11:00 , 13:00 , 15:00 ] **Output:** [ daniel ] **Explanation:** daniel used the keycard 3 times in a onehour period ( 10:00 , 10:40 , 11:00 ). **Example 2:** **Input:** keyName = [ alice , alice , alice , bob , bob , bob , bob ], keyTime = [ 12:01 , 12:00 , 18:00 , 21:00 , 21:20 , 21:30 , 23:00 ] **Output:** [ bob ] **Explanation:** bob used the keycard 3 times in a onehour period ( 21:00 , 21:20 , 21:30 ). **Constraints:** * `1 <= keyName.length, keyTime.length <= 105` * `keyName.length == keyTime.length` * `keyTime[i]` is in the format **HH:MM **. * `[keyName[i], keyTime[i]]` is **unique**. * `1 <= keyName[i].length <= 10` * `keyName[i] contains only lowercase English letters.`","completion":"import heapq from collections import Counter def find_least_num_of_unique_ints(arr, k): freq_map = Counter(arr) min_heap = list(freq_map.values()) heapq.heapify(min_heap) while k > 0: k -= heapq.heappop(min_heap) return len(min_heap) if k == 0 else len(min_heap) + 1"},{"prompt":"You are given an integer `n` indicating there are `n` people numbered from `0` to `n 1`. You are also given a **0indexed** 2D integer array `meetings` where `meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi` have a meeting at `timei`. A person may attend **multiple meetings** at the same time. Finally, you are given an integer `firstPerson`. Person `0` has a **secret** and initially shares the secret with a person `firstPerson` at time `0`. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person `xi` has the secret at `timei`, then they will share the secret with person `yi`, and vice versa. The secrets are shared **instantaneously**. That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return _a list of all the people that have the secret after all the meetings have taken place._ You may return the answer in **any order**. **Example 1:** **Input:** n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 **Output:** [0,1,2,3,5] **Explanation:** At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5.​​​​ Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings. **Example 2:** **Input:** n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 **Output:** [0,1,3] **Explanation:** At time 0, person 0 shares the secret with person 3. At time 2, neither person 1 nor person 2 know the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings. **Example 3:** **Input:** n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 **Output:** [0,1,2,3,4] **Explanation:** At time 0, person 0 shares the secret with person 1. At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3. Note that person 2 can share the secret at the same time as receiving it. At time 2, person 3 shares the secret with person 4. Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings. **Constraints:** * `2 <= n <= 105` * `1 <= meetings.length <= 105` * `meetings[i].length == 3` * `0 <= xi, yi <= n 1` * `xi != yi` * `1 <= timei <= 105` * `1 <= firstPerson <= n 1`","completion":"def find_secret_sharers(n, meetings, first_person): secret_holders = [-1] * n secret_holders[0] = 0 secret_holders[first_person] = 0 meetings.sort(key=lambda x: x[2]) for x, y, time in meetings: if secret_holders[x] != -1 and secret_holders[x] <= time: secret_holders[y] = time if secret_holders[y] != -1 and secret_holders[y] <= time: secret_holders[x] = time return [i for i in range(n) if secret_holders[i] != -1]"},{"prompt":"You are given a string `s` and a robot that currently holds an empty string `t`. Apply one of the following operations until `s` and `t` **are both empty**: * Remove the **first** character of a string `s` and give it to the robot. The robot will append this character to the string `t`. * Remove the **last** character of a string `t` and give it to the robot. The robot will write this character on paper. Return _the lexicographically smallest string that can be written on the paper._ **Example 1:** **Input:** s = zza **Output:** azz **Explanation:** Let p denote the written string. Initially p= , s= zza , t= . Perform first operation three times p= , s= , t= zza . Perform second operation three times p= azz , s= , t= . **Example 2:** **Input:** s = bac **Output:** abc **Explanation:** Let p denote the written string. Perform first operation twice p= , s= c , t= ba . Perform second operation twice p= ab , s= c , t= . Perform first operation p= ab , s= , t= c . Perform second operation p= abc , s= , t= . **Example 3:** **Input:** s = bdda **Output:** addb **Explanation:** Let p denote the written string. Initially p= , s= bdda , t= . Perform first operation four times p= , s= , t= bdda . Perform second operation four times p= addb , s= , t= . **Constraints:** * `1 <= s.length <= 105` * `s` consists of only English lowercase letters.","completion":"def robot_sort(s): t = [] for c in s: while t and t[-1] <= c: t.pop() t.append(c) return \'\'.join(t)"},{"prompt":"You are given two strings `s` and `sub`. You are also given a 2D character array `mappings` where `mappings[i] = [oldi, newi]` indicates that you may perform the following operation **any** number of times: * **Replace** a character `oldi` of `sub` with `newi`. Each character in `sub` **cannot** be replaced more than once. Return `true` _if it is possible to make_ `sub` _a substring of_ `s` _by replacing zero or more characters according to_ `mappings`. Otherwise, return `false`. A **substring** is a contiguous nonempty sequence of characters within a string. **Example 1:** **Input:** s = fool3e7bar , sub = leet , mappings = [[ e , 3 ],[ t , 7 ],[ t , 8 ]] **Output:** true **Explanation:** Replace the first \'e\' in sub with \'3\' and \'t\' in sub with \'7\'. Now sub = l3e7 is a substring of s, so we return true. **Example 2:** **Input:** s = fooleetbar , sub = f00l , mappings = [[ o , 0 ]] **Output:** false **Explanation:** The string f00l is not a substring of s and no replacements can be made. Note that we cannot replace \'0\' with \'o\'. **Example 3:** **Input:** s = Fool33tbaR , sub = leetd , mappings = [[ e , 3 ],[ t , 7 ],[ t , 8 ],[ d , b ],[ p , b ]] **Output:** true **Explanation:** Replace the first and second \'e\' in sub with \'3\' and \'d\' in sub with \'b\'. Now sub = l33tb is a substring of s, so we return true. **Constraints:** * `1 <= sub.length <= s.length <= 5000` * `0 <= mappings.length <= 1000` * `mappings[i].length == 2` * `oldi != newi` * `s` and `sub` consist of uppercase and lowercase English letters and digits. * `oldi` and `newi` are either uppercase or lowercase English letters or digits. 0 <= i < j < n and nums[i] % k + nums[j] % k == k.","completion":"def count_pairs(nums, k): mod_count = [0] * k count = 0 for num in nums: mod_count[num % k] += 1 count += mod_count[0] * (mod_count[0] - 1) // 2 for i in range(1, k // 2 + 1): if i != k - i: count += mod_count[i] * mod_count[k-i] else: count += mod_count[i] * (mod_count[i] - 1) // 2 return count"},{"prompt":"An integer `x` is **numerically balanced** if for every digit `d` in the number `x`, there are **exactly** `d` occurrences of that digit in `x`. Given an integer `n`, return _the **smallest numerically balanced** number **strictly greater** than_ `n`_._ **Example 1:** **Input:** n = 1 **Output:** 22 **Explanation:** 22 is numerically balanced since: The digit 2 occurs 2 times. It is also the smallest numerically balanced number strictly greater than 1. **Example 2:** **Input:** n = 1000 **Output:** 1333 **Explanation:** 1333 is numerically balanced since: The digit 1 occurs 1 time. The digit 3 occurs 3 times. It is also the smallest numerically balanced number strictly greater than 1000. Note that 1022 cannot be the answer because 0 appeared more than 0 times. **Example 3:** **Input:** n = 3000 **Output:** 3133 **Explanation:** 3133 is numerically balanced since: The digit 1 occurs 1 time. The digit 3 occurs 3 times. It is also the smallest numerically balanced number strictly greater than 3000. **Constraints:** * `0 <= n <= 106`","completion":"def build_array(nums): ans = [] for i in range(len(nums)): ans.append(nums[nums[i]]) return ans"},{"prompt":"You have information about `n` different recipes. You are given a string array `recipes` and a 2D string array `ingredients`. The `ith` recipe has the name `recipes[i]`, and you can **create** it if you have **all** the needed ingredients from `ingredients[i]`. Ingredients to a recipe may need to be created from **other** recipes, i.e., `ingredients[i]` may contain a string that is in `recipes`. You are also given a string array `supplies` containing all the ingredients that you initially have, and you have an infinite supply of all of them. Return _a list of all the recipes that you can create._ You may return the answer in **any order**. Note that two recipes may contain each other in their ingredients. **Example 1:** **Input:** recipes = [ bread ], ingredients = [[ yeast , flour ]], supplies = [ yeast , flour , corn ] **Output:** [ bread ] **Explanation:** We can create bread since we have the ingredients yeast and flour . **Example 2:** **Input:** recipes = [ bread , sandwich ], ingredients = [[ yeast , flour ],[ bread , meat ]], supplies = [ yeast , flour , meat ] **Output:** [ bread , sandwich ] **Explanation:** We can create bread since we have the ingredients yeast and flour . We can create sandwich since we have the ingredient meat and can create the ingredient bread . **Example 3:** **Input:** recipes = [ bread , sandwich , burger ], ingredients = [[ yeast , flour ],[ bread , meat ],[ sandwich , meat , bread ]], supplies = [ yeast , flour , meat ] **Output:** [ bread , sandwich , burger ] **Explanation:** We can create bread since we have the ingredients yeast and flour . We can create sandwich since we have the ingredient meat and can create the ingredient bread . We can create burger since we have the ingredient meat and can create the ingredients bread and sandwich . **Constraints:** * `n == recipes.length == ingredients.length` * `1 <= n <= 100` * `1 <= ingredients[i].length, supplies.length <= 100` * `1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10` * `recipes[i], ingredients[i][j]`, and `supplies[k]` consist only of lowercase English letters. * All the values of `recipes` and `supplies` combined are unique. * Each `ingredients[i]` does not contain any duplicate values.","completion":"def numDistinct(binary): mod = 10**9 + 7 zero_count, ones_count = 0, 0 for c in binary: if c == \'0\': zero_count = (zero_count + ones_count) % mod else: ones_count = (ones_count * 2 + 1) % mod return zero_count"},{"prompt":"You are given an `m x n` integer matrix `points` (**0indexed**). Starting with `0` points, you want to **maximize** the number of points you can get from the matrix. To gain points, you must pick one cell in **each row**. Picking the cell at coordinates `(r, c)` will **add** `points[r][c]` to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows `r` and `r + 1` (where `0 <= r < m 1`), picking cells at coordinates `(r, c1)` and `(r + 1, c2)` will **subtract** `abs(c1 c2)` from your score. Return _the **maximum** number of points you can achieve_. `abs(x)` is defined as: * `x` for `x >= 0`. * `x` for `x < 0`. **Example 1:** **Input:** points = [[1,2,3],[1,5,1],[3,1,1]] **Output:** 9 **Explanation:** The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11 to your score. However, you must subtract abs(2 1) + abs(1 0) = 2 from your score. Your final score is 11 2 = 9. **Example 2:** **Input:** points = [[1,5],[2,3],[4,2]] **Output:** 11 **Explanation:** The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12 to your score. However, you must subtract abs(1 1) + abs(1 0) = 1 from your score. Your final score is 12 1 = 11. **Constraints:** * `m == points.length` * `n == points[r].length` * `1 <= m, n <= 105` * `1 <= m * n <= 105` * `0 <= points[r][c] <= 105`","completion":"def maxPoints(points): m, n = len(points), len(points[0]) dp = [0] * n for row in points: next_dp = [0] * n for c1 in range(n): score = dp[c1] + row[c1] - c1 for c2 in range(n): next_dp[c2] = max(next_dp[c2], score - row[c1] + c2) dp = next_dp return max(dp)"},{"prompt":"Given four integers `length`, `width`, `height`, and `mass`, representing the dimensions and mass of a box, respectively, return _a string representing the **category** of the box_. * The box is `Bulky ` if: * **Any** of the dimensions of the box is greater or equal to `104`. * Or, the **volume** of the box is greater or equal to `109`. * If the mass of the box is greater or equal to `100`, it is `Heavy .` * If the box is both `Bulky ` and `Heavy `, then its category is `Both `. * If the box is neither `Bulky ` nor `Heavy `, then its category is `Neither `. * If the box is `Bulky ` but not `Heavy `, then its category is `Bulky `. * If the box is `Heavy ` but not `Bulky `, then its category is `Heavy `. **Note** that the volume of the box is the product of its length, width and height. **Example 1:** **Input:** length = 1000, width = 35, height = 700, mass = 300 **Output:** Heavy **Explanation:** None of the dimensions of the box is greater or equal to 104. Its volume = 24500000 <= 109. So it cannot be categorized as Bulky . However mass >= 100, so the box is Heavy . Since the box is not Bulky but Heavy , we return Heavy . **Example 2:** **Input:** length = 200, width = 50, height = 800, mass = 50 **Output:** Neither **Explanation:** None of the dimensions of the box is greater or equal to 104. Its volume = 8 * 106 <= 109. So it cannot be categorized as Bulky . Its mass is also less than 100, so it cannot be categorized as Heavy either. Since its neither of the two above categories, we return Neither . **Constraints:** * `1 <= length, width, height <= 105` * `1 <= mass <= 103`","completion":"def boxCategory(length: int, width: int, height: int, mass: int) -> str: bulky = length >= 10000 or width >= 10000 or height >= 10000 or int(length) * width * height >= 1000000000 heavy = mass >= 100 if bulky and heavy: return \\"Both \\" if bulky: return \\"Bulky \\" if heavy: return \\"Heavy \\" return \\"Neither \\""},{"prompt":"There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire `timeToLive` seconds after the `currentTime`. If the token is renewed, the expiry time will be **extended** to expire `timeToLive` seconds after the (potentially different) `currentTime`. Implement the `AuthenticationManager` class: * `AuthenticationManager(int timeToLive)` constructs the `AuthenticationManager` and sets the `timeToLive`. * `generate(string tokenId, int currentTime)` generates a new token with the given `tokenId` at the given `currentTime` in seconds. * `renew(string tokenId, int currentTime)` renews the **unexpired** token with the given `tokenId` at the given `currentTime` in seconds. If there are no unexpired tokens with the given `tokenId`, the request is ignored, and nothing happens. * `countUnexpiredTokens(int currentTime)` returns the number of **unexpired** tokens at the given currentTime. Note that if a token expires at time `t`, and another action happens on time `t` (`renew` or `countUnexpiredTokens`), the expiration takes place **before** the other actions. **Example 1:** **Input** [ AuthenticationManager , `renew` , generate , `countUnexpiredTokens` , generate , `renew` , `renew` , `countUnexpiredTokens` ] [[5], [ aaa , 1], [ aaa , 2], [6], [ bbb , 7], [ aaa , 8], [ bbb , 10], [15]] **Output** [null, null, null, 1, null, null, null, 0] **Explanation** AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with `timeToLive` = 5 seconds. authenticationManager.`renew`( aaa , 1); // No token exists with tokenId aaa at time 1, so nothing happens. authenticationManager.generate( aaa , 2); // Generates a new token with tokenId aaa at time 2. authenticationManager.`countUnexpiredTokens`(6); // The token with tokenId aaa is the only unexpired one at time 6, so return 1. authenticationManager.generate( bbb , 7); // Generates a new token with tokenId bbb at time 7. authenticationManager.`renew`( aaa , 8); // The token with tokenId aaa expired at time 7, and 8 >= 7, so at time 8 the `renew` request is ignored, and nothing happens. authenticationManager.`renew`( bbb , 10); // The token with tokenId bbb is unexpired at time 10, so the `renew` request is fulfilled and now the token will expire at time 15. authenticationManager.`countUnexpiredTokens`(15); // The token with tokenId bbb expires at time 15, and the token with tokenId aaa expired at time 7, so currently no token is unexpired, so return 0. **Constraints:** * `1 <= timeToLive <= 108` * `1 <= currentTime <= 108` * `1 <= tokenId.length <= 5` * `tokenId` consists only of lowercase letters. * All calls to `generate` will contain unique values of `tokenId`. * The values of `currentTime` across all the function calls will be **strictly increasing**. * At most `2000` calls will be made to all functions combined.","completion":"def interpret(command: str) -> str: result = [] i = 0 while i < len(command): if command[i] == \\"G\\": result.append(\\"G\\") i += 1 elif command[i:i+2] == \\"()\\": result.append(\\"o\\") i += 2 else: result.append(\\"al\\") i += 4 return \\"\\".join(result)"},{"prompt":"Given a positive integer `n`, find and return _the **longest distance** between any two **adjacent**_ `1`_\'s in the binary representation of_ `n`_. If there are no two adjacent_ `1`_\'s, return_ `0`_._ Two `1`\'s are **adjacent** if there are only `0`\'s separating them (possibly no `0`\'s). The **distance** between two `1`\'s is the absolute difference between their bit positions. For example, the two `1`\'s in `1001 ` have a distance of 3. **Example 1:** **Input:** n = 22 **Output:** 2 **Explanation:** 22 in binary is 10110 . The first adjacent pair of 1\'s is 10110 with a distance of 2. The second adjacent pair of 1\'s is 10110 with a distance of 1. The answer is the largest of these two distances, which is 2. Note that 10110 is not a valid pair since there is a 1 separating the two 1\'s underlined. **Example 2:** **Input:** n = 8 **Output:** 0 **Explanation:** 8 in binary is 1000 . There are not any adjacent pairs of 1\'s in the binary representation of 8, so we return 0. **Example 3:** **Input:** n = 5 **Output:** 2 **Explanation:** 5 in binary is 101 . **Constraints:** * `1 <= n <= 109`","completion":"def push_dominoes(dominoes: str) -> str: prev, cur = None, dominoes while prev != cur: prev = cur cur_lst = list(prev) for i in range(len(cur)): if prev[i] == \'L\' and i > 0 and prev[i - 1] == \'.\': cur_lst[i - 1] = \'L\' elif prev[i] == \'R\' and i < len(cur) - 1 and prev[i + 1] == \'.\': cur_lst[i + 1] = \'R\' cur = \'\'.join(cur_lst) return cur"},{"prompt":"Given an array `nums` sorted in **nondecreasing** order, return _the maximum between the number of positive integers and the number of negative integers._ * In other words, if the number of positive integers in `nums` is `pos` and the number of negative integers is `neg`, then return the maximum of `pos` and `neg`. **Note** that `0` is neither positive nor negative. **Example 1:** **Input:** nums = [2,1,1,1,2,3] **Output:** 3 **Explanation:** There are 3 positive integers and 3 negative integers. The maximum count among them is 3. **Example 2:** **Input:** nums = [3,2,1,0,0,1,2] **Output:** 3 **Explanation:** There are 2 positive integers and 3 negative integers. The maximum count among them is 3. **Example 3:** **Input:** nums = [5,20,66,1314] **Output:** 4 **Explanation:** There are 4 positive integers and 0 negative integers. The maximum count among them is 4. **Constraints:** * `1 <= nums.length <= 2000` * `2000 <= nums[i] <= 2000` * `nums` is sorted in a **nondecreasing order**.","completion":"def max_positive_negative_count(nums): pos = next((i for i, x in enumerate(nums) if x >= 0), len(nums)) neg = len(nums) - pos return max(pos, neg)"},{"prompt":"You are given a positive integer `n`. Continuously replace `n` with the sum of its **prime factors**. * Note that if a prime factor divides `n` multiple times, it should be included in the sum as many times as it divides `n`. Return _the smallest value_ `n` _will take on._ **Example 1:** **Input:** n = 15 **Output:** 5 **Explanation:** Initially, n = 15. 15 = 3 * 5, so replace n with 3 + 5 = 8. 8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6. 6 = 2 * 3, so replace n with 2 + 3 = 5. 5 is the smallest value n will take on. **Example 2:** **Input:** n = 3 **Output:** 3 **Explanation:** Initially, n = 3. 3 is the smallest value n will take on. **Constraints:** * `2 <= n <= 105`","completion":"def smallestFactorization(n): if n <= 3: return n result, factor = 0, 1 for i in range(2, 6): while n % i == 0: result += factor * i factor *= 10 n //= i return result if n == 1 else n"},{"prompt":"Given a string `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`. You are asked to apply the following algorithm on the string any number of times: 1. Pick a **nonempty** prefix from the string `s` where all the characters in the prefix are equal. 2. Pick a **nonempty** suffix from the string `s` where all the characters in this suffix are equal. 3. The prefix and the suffix should not intersect at any index. 4. The characters from the prefix and suffix must be the same. 5. Delete both the prefix and the suffix. Return _the **minimum length** of_ `s` _after performing the above operation any number of times (possibly zero times)_. **Example 1:** **Input:** s = ca **Output:** 2 **Explanation:** You can\'t remove any characters, so the string stays as is. **Example 2:** **Input:** s = cabaabac **Output:** 0 **Explanation:** An optimal sequence of operations is: Take prefix = c and suffix = c and remove them, s = abaaba . Take prefix = a and suffix = a and remove them, s = baab . Take prefix = b and suffix = b and remove them, s = aa . Take prefix = a and suffix = a and remove them, s = . **Example 3:** **Input:** s = aabccabba **Output:** 3 **Explanation:** An optimal sequence of operations is: Take prefix = aa and suffix = a and remove them, s = bccabb . Take prefix = b and suffix = bb and remove them, s = cca . **Constraints:** * `1 <= s.length <= 105` * `s` only consists of characters `\'a\'`, `\'b\'`, and `\'c\'`.","completion":"def minimumLength(s: str) -> int: if not s: return 0 i, j = 0, len(s) - 1 while i < j: if s[i] != s[j]: break remove_char = s[i] while i < len(s) and s[i] == remove_char: i += 1 while j >= 0 and s[j] == remove_char: j -= 1 return max(0, j - i + 1)"},{"prompt":"Given a **directed acyclic graph**, with `n` vertices numbered from `0` to `n1`, and an array `edges` where `edges[i] = [fromi, toi]` represents a directed edge from node `fromi` to node `toi`. Find _the smallest set of vertices from which all nodes in the graph are reachable_. It\'s guaranteed that a unique solution exists. Notice that you can return the vertices in any order. **Example 1:** **Input:** n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] **Output:** [0,3] **Explanation:** It\'s not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3]. **Example 2:** **Input:** n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]] **Output:** [0,2,3] **Explanation:** Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4. **Constraints:** * `2 <= n <= 10^5` * `1 <= edges.length <= min(10^5, n * (n 1) / 2)` * `edges[i].length == 2` * `0 <= fromi, toi < n` * All pairs `(fromi, toi)` are distinct.","completion":"def has_all_codes(s, k): need = 1 << k got = set() for i in range(len(s) - k + 1): got.add(s[i:i + k]) return len(got) == need"},{"prompt":"You have `n` tasks and `m` workers. Each task has a strength requirement stored in a **0indexed** integer array `tasks`, with the `ith` task requiring `tasks[i]` strength to complete. The strength of each worker is stored in a **0indexed** integer array `workers`, with the `jth` worker having `workers[j]` strength. Each worker can only be assigned to a **single** task and must have a strength **greater than or equal** to the task\'s strength requirement (i.e., `workers[j] >= tasks[i]`). Additionally, you have `pills` magical pills that will **increase a worker\'s strength** by `strength`. You can decide which workers receive the magical pills, however, you may only give each worker **at most one** magical pill. Given the **0indexed** integer arrays `tasks` and `workers` and the integers `pills` and `strength`, return _the **maximum** number of tasks that can be completed._ **Example 1:** **Input:** tasks = [**3**,**2**,**1**], workers = [**0**,**3**,**3**], pills = 1, strength = 1 **Output:** 3 **Explanation:** We can assign the magical pill and tasks as follows: Give the magical pill to worker 0. Assign worker 0 to task 2 (0 + 1 >= 1) Assign worker 1 to task 1 (3 >= 2) Assign worker 2 to task 0 (3 >= 3) **Example 2:** **Input:** tasks = [**5**,4], workers = [**0**,0,0], pills = 1, strength = 5 **Output:** 1 **Explanation:** We can assign the magical pill and tasks as follows: Give the magical pill to worker 0. Assign worker 0 to task 0 (0 + 5 >= 5) **Example 3:** **Input:** tasks = [**10**,**15**,30], workers = [**0**,**10**,10,10,10], pills = 3, strength = 10 **Output:** 2 **Explanation:** We can assign the magical pills and tasks as follows: Give the magical pill to worker 0 and worker 1. Assign worker 0 to task 0 (0 + 10 >= 10) Assign worker 1 to task 1 (10 + 10 >= 15) The last pill is not given because it will not make any worker strong enough for the last task. **Constraints:** * `n == tasks.length` * `m == workers.length` * `1 <= n, m <= 5 * 104` * `0 <= pills <= m` * `0 <= tasks[i], workers[j], strength <= 109`","completion":"def maxTasks(tasks, workers, pills, strength): tasks.sort() workers.sort() cnt = 0 i = 0 for j in range(pills): while i < len(tasks) and tasks[i] > workers[j] + strength: i += 1 if i < len(tasks): cnt += 1 i += 1 i = 0 for j in range(pills, len(workers)): if i < len(tasks) and tasks[i] <= workers[j]: cnt += 1 i += 1 return cnt"},{"prompt":"You are given an integer array `nums` and an integer `k`. In one operation, you can pick two numbers from the array whose sum equals `k` and remove them from the array. Return _the maximum number of operations you can perform on the array_. **Example 1:** **Input:** nums = [1,2,3,4], k = 5 **Output:** 2 **Explanation:** Starting with nums = [1,2,3,4]: Remove numbers 1 and 4, then nums = [2,3] Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. **Example 2:** **Input:** nums = [3,1,3,4,3], k = 6 **Output:** 1 **Explanation:** Starting with nums = [3,1,3,4,3]: Remove the first two 3\'s, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109` * `1 <= k <= 109`","completion":"def findLengthOfShortestSubarray(arr): n = len(arr) left, right = 0, n - 1 while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 if left == n - 1: return 0 while right > 0 and arr[right] >= arr[right - 1]: right -= 1 result = min(right, n - left - 1) i, j = 0, right while i <= left and j < n: if arr[i] <= arr[j]: result = min(result, j - i - 1) i += 1 else: j += 1 return result"},{"prompt":"You are given a string `s` consisting of digits and an integer `k`. A **round** can be completed if the length of `s` is greater than `k`. In one round, do the following: 1. **Divide** `s` into **consecutive groups** of size `k` such that the first `k` characters are in the first group, the next `k` characters are in the second group, and so on. **Note** that the size of the last group can be smaller than `k`. 2. **Replace** each group of `s` with a string representing the sum of all its digits. For example, `346 ` is replaced with `13 ` because `3 + 4 + 6 = 13`. 3. **Merge** consecutive groups together to form a new string. If the length of the string is greater than `k`, repeat from step `1`. Return `s` _after all rounds have been completed_. **Example 1:** **Input:** s = 11111222223 , k = 3 **Output:** 135 **Explanation:** For the first round, we divide s into groups of size 3: 111 , 112 , 222 , and 23 . ​​​​​Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. So, s becomes 3 + 4 + 6 + 5 = 3465 after the first round. For the second round, we divide s into 346 and 5 . Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. So, s becomes 13 + 5 = 135 after second round. Now, s.length <= k, so we return 135 as the answer. **Example 2:** **Input:** s = 00000000 , k = 3 **Output:** 000 **Explanation:** We divide s into 000 , 000 , and 00 . Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. s becomes 0 + 0 + 0 = 000 , whose length is equal to k, so we return 000 . **Constraints:** * `1 <= s.length <= 100` * `2 <= k <= 100` * `s` consists of digits only.","completion":"def is_a_only_before_b(s: str) -> bool: last_index_a = -1 for i, c in enumerate(s): if c == \'a\': last_index_a = i elif c == \'b\' and last_index_a > -1: return False return True"},{"prompt":"You are given the `head` of a linked list. **Delete** the **middle node**, and return _the_ `head` _of the modified linked list_. The **middle node** of a linked list of size `n` is the `⌊n / 2⌋th` node from the **start** using **0based indexing**, where `⌊x⌋` denotes the largest integer less than or equal to `x`. * For `n` = `1`, `2`, `3`, `4`, and `5`, the middle nodes are `0`, `1`, `1`, `2`, and `2`, respectively. **Example 1:** **Input:** head = [1,3,4,7,1,2,6] **Output:** [1,3,4,1,2,6] **Explanation:** The above figure represents the given linked list. The indices of the nodes are written below. Since n = 7, node 3 with value 7 is the middle node, which is marked in red. We return the new list after removing this node. **Example 2:** **Input:** head = [1,2,3,4] **Output:** [1,2,4] **Explanation:** The above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node, which is marked in red. **Example 3:** **Input:** head = [2,1] **Output:** [2] **Explanation:** The above figure represents the given linked list. For n = 2, node 1 with value 1 is the middle node, which is marked in red. Node 0 with value 2 is the only node remaining after removing node 1. **Constraints:** * The number of nodes in the list is in the range `[1, 105]`. * `1 <= Node.val <= 105`","completion":"def min_swaps_to_balance(s: str) -> int: open_brackets = 0 swaps = 0 for c in s: if c == \'[\': open_brackets += 1 else: if open_brackets == 0: swaps += 1 open_brackets += 1 else: open_brackets -= 1 return swaps"},{"prompt":"A die simulator generates a random number from `1` to `6` for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (**1indexed**) consecutive times. Given an array of integers `rollMax` and an integer `n`, return _the number of distinct sequences that can be obtained with exact_ `n` _rolls_. Since the answer may be too large, return it **modulo** `109 + 7`. Two sequences are considered different if at least one element differs from each other. **Example 1:** **Input:** n = 2, rollMax = [1,1,2,2,2,3] **Output:** 34 **Explanation:** There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 362 = 34. **Example 2:** **Input:** n = 2, rollMax = [1,1,1,1,1,1] **Output:** 30 **Example 3:** **Input:** n = 3, rollMax = [1,1,1,2,2,3] **Output:** 181 **Constraints:** * `1 <= n <= 5000` * `rollMax.length == 6` * `1 <= rollMax[i] <= 15`","completion":"def areConnected(n, threshold, queries): answer = [False] * len(queries) parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def unite(x, y): rootx = find(x) rooty = find(y) if rootx != rooty: if rank[rootx] > rank[rooty]: rootx, rooty = rooty, rootx parent[rootx] = rooty if rank[rootx] == rank[rooty]: rank[rooty] += 1 for i in range(threshold + 1, n + 1): for j in range(i * 2, n + 1, i): unite(i, j) for i, query in enumerate(queries): answer[i] = find(query[0]) == find(query[1]) return answer"},{"prompt":"Given the availability time slots arrays `slots1` and `slots2` of two people and a meeting duration `duration`, return the **earliest time slot** that works for both of them and is of duration `duration`. If there is no common time slot that satisfies the requirements, return an **empty array**. The format of a time slot is an array of two elements `[start, end]` representing an inclusive time range from `start` to `end`. It is guaranteed that no two availability slots of the same person intersect with each other. That is, for any two time slots `[start1, end1]` and `[start2, end2]` of the same person, either `start1 > end2` or `start2 > end1`. **Example 1:** **Input:** slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8 **Output:** [60,68] **Example 2:** **Input:** slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12 **Output:** [] **Constraints:** * `1 <= slots1.length, slots2.length <= 104` * `slots1[i].length, slots2[i].length == 2` * `slots1[i][0] < slots1[i][1]` * `slots2[i][0] < slots2[i][1]` * `0 <= slots1[i][j], slots2[i][j] <= 109` * `1 <= duration <= 106`","completion":"from collections import defaultdict, deque def shortestAlternatingPaths(n, redEdges, blueEdges): adj_list = defaultdict(lambda: defaultdict(set)) for u, v in redEdges: adj_list[u][0].add(v) for u, v in blueEdges: adj_list[u][1].add(v) dist = [[-1] * 2 for _ in range(n)] dist[0] = [0, 0] q = deque([(0, 0), (0, 1)]) while q: node, color = q.popleft() next_color = color ^ 1 for neighbor in adj_list[node][next_color]: if dist[neighbor][next_color] == -1: dist[neighbor][next_color] = dist[node][color] + 1 q.append((neighbor, next_color)) result = [] for a, b in dist: result.append(min(a, b) if a != -1 and b != -1 else max(a, b)) return result"},{"prompt":"You are given an `m x n` matrix of characters `box` representing a sideview of a box. Each cell of the box is one of the following: * A stone `\'#\'` * A stationary obstacle `\'*\'` * Empty `\'.\'` The box is rotated **90 degrees clockwise**, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity **does not** affect the obstacles\' positions, and the inertia from the box\'s rotation **does not** affect the stones\' horizontal positions. It is **guaranteed** that each stone in `box` rests on an obstacle, another stone, or the bottom of the box. Return _an_ `n x m` _matrix representing the box after the rotation described above_. **Example 1:** **Input:** box = [[ # , . , # ]] **Output:** [[ . ], [ # ], [ # ]] **Example 2:** **Input:** box = [[ # , . , * , . ], [ # , # , * , . ]] **Output:** [[ # , . ], [ # , # ], [ * , * ], [ . , . ]] **Example 3:** **Input:** box = [[ # , # , * , . , * , . ], [ # , # , # , * , . , . ], [ # , # , # , . , # , . ]] **Output:** [[ . , # , # ], [ . , # , # ], [ # , # , * ], [ # , * , . ], [ # , . , * ], [ # , . , . ]] **Constraints:** * `m == box.length` * `n == box[i].length` * `1 <= m, n <= 500` * `box[i][j]` is either `\'#\'`, `\'*\'`, or `\'.\'`.","completion":"def min_boxes_touching_floor(n): return (n + 1) // 2"},{"prompt":"There are two types of soup: **type A** and **type B**. Initially, we have `n` ml of each type of soup. There are four kinds of operations: 1. Serve `100` ml of **soup A** and `0` ml of **soup B**, 2. Serve `75` ml of **soup A** and `25` ml of **soup B**, 3. Serve `50` ml of **soup A** and `50` ml of **soup B**, and 4. Serve `25` ml of **soup A** and `75` ml of **soup B**. When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability `0.25`. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup. **Note** that we do not have an operation where all `100` ml\'s of **soup B** are used first. Return _the probability that **soup A** will be empty first, plus half the probability that **A** and **B** become empty at the same time_. Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** n = 50 **Output:** 0.62500 **Explanation:** If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625. **Example 2:** **Input:** n = 100 **Output:** 0.71875 **Constraints:** * `0 <= n <= 109`","completion":"from bisect import bisect_left from collections import defaultdict def numMatchingSubseq(s, words): positions = defaultdict(list) for i, c in enumerate(s): positions[c].append(i) count = 0 for word in words: index = -1 isSubsequence = True for c in word: position_list = positions.get(c, []) i = bisect_left(position_list, index + 1) if (i == len(position_list)): isSubsequence = False break index = position_list[i] if isSubsequence: count += 1 return count"},{"prompt":"You are given two integers `n` and `maxValue`, which are used to describe an **ideal** array. A **0indexed** integer array `arr` of length `n` is considered **ideal** if the following conditions hold: * Every `arr[i]` is a value from `1` to `maxValue`, for `0 <= i < n`. * Every `arr[i]` is divisible by `arr[i 1]`, for `0 < i < n`. Return _the number of **distinct** ideal arrays of length_ `n`. Since the answer may be very large, return it modulo `109 + 7`. **Example 1:** **Input:** n = 2, maxValue = 5 **Output:** 10 **Explanation:** The following are the possible ideal arrays: Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5] Arrays starting with the value 2 (2 arrays): [2,2], [2,4] Arrays starting with the value 3 (1 array): [3,3] Arrays starting with the value 4 (1 array): [4,4] Arrays starting with the value 5 (1 array): [5,5] There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays. **Example 2:** **Input:** n = 5, maxValue = 3 **Output:** 11 **Explanation:** The following are the possible ideal arrays: Arrays starting with the value 1 (9 arrays): With no other distinct values (1 array): [1,1,1,1,1] With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2] With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3] Arrays starting with the value 2 (1 array): [2,2,2,2,2] Arrays starting with the value 3 (1 array): [3,3,3,3,3] There are a total of 9 + 1 + 1 = 11 distinct ideal arrays. **Constraints:** * `2 <= n <= 104` * `1 <= maxValue <= 104`","completion":"def numOfArrays(n: int, maxValue: int) -> int: mod = 10**9 + 7 dp = [0] * (maxValue + 1) for i in range(1, maxValue + 1): dp[i] = i for i in range(1, n): for j in range(maxValue, 0, -1): dp[j] = (dp[j] + dp[j - 1]) % mod return dp[maxValue]"},{"prompt":"You are given an array of points in the **XY** plane `points` where `points[i] = [xi, yi]`. Return _the minimum area of any rectangle formed from these points, with sides **not necessarily parallel** to the X and Y axes_. If there is not any such rectangle, return `0`. Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** points = [[1,2],[2,1],[1,0],[0,1]] **Output:** 2.00000 **Explanation:** The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2. **Example 2:** **Input:** points = [[0,1],[2,1],[1,1],[1,0],[2,0]] **Output:** 1.00000 **Explanation:** The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1. **Example 3:** **Input:** points = [[0,3],[1,2],[3,1],[1,3],[2,1]] **Output:** 0 **Explanation:** There is no possible rectangle to form from these points. **Constraints:** * `1 <= points.length <= 50` * `points[i].length == 2` * `0 <= xi, yi <= 4 * 104` * All the given points are **unique**.","completion":"def find_same_binary_value_parts(arr): ones = sum(arr) if ones % 3 != 0: return [-1, -1] target = ones // 3 if target == 0: return [0, len(arr) - 2] count = 0 i = j = -1 ones = 0 for idx, n in enumerate(arr): if n == 1: ones += 1 if ones == target + 1: count += 1 if count == 1 and i == -1: i = idx if count == 2 and j == -1: j = idx if count == 3: break return [i, j]"},{"prompt":"You are given a positive integer `p`. Consider an array `nums` (**1indexed**) that consists of the integers in the **inclusive** range `[1, 2p 1]` in their binary representations. You are allowed to do the following operation **any** number of times: * Choose two elements `x` and `y` from `nums`. * Choose a bit in `x` and swap it with its corresponding bit in `y`. Corresponding bit refers to the bit that is in the **same position** in the other integer. For example, if `x = 1101` and `y = 0011`, after swapping the `2nd` bit from the right, we have `x = 1111` and `y = 0001`. Find the **minimum nonzero** product of `nums` after performing the above operation **any** number of times. Return _this product_ _**modulo**_ `109 + 7`. **Note:** The answer should be the minimum product **before** the modulo operation is done. **Example 1:** **Input:** p = 1 **Output:** 1 **Explanation:** nums = [1]. There is only one element, so the product equals that element. **Example 2:** **Input:** p = 2 **Output:** 6 **Explanation:** nums = [01, 10, 11]. Any swap would either make the product 0 or stay the same. Thus, the array product of 1 * 2 * 3 = 6 is already minimized. **Example 3:** **Input:** p = 3 **Output:** 1512 **Explanation:** nums = [001, 010, 011, 100, 101, 110, 111] In the first operation we can swap the leftmost bit of the second and fifth elements. The resulting array is [001, 110, 011, 100, 001, 110, 111]. In the second operation we can swap the middle bit of the third and fourth elements. The resulting array is [001, 110, 001, 110, 001, 110, 111]. The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product. **Constraints:** * `1 <= p <= 60`","completion":"def minNonZeroProduct(p: int) -> int: mod = 10**9 + 7 x = (1 << p) - 1 y = (1 << p) - 2 z = pow(y, x - 1, mod) return x * z % mod"},{"prompt":"You are given an integer array `nums`. You can choose **exactly one** index (**0indexed**) and remove the element. Notice that the index of the elements may change after the removal. For example, if `nums = [6,1,7,4,1]`: * Choosing to remove index `1` results in `nums = [6,7,4,1]`. * Choosing to remove index `2` results in `nums = [6,1,4,1]`. * Choosing to remove index `4` results in `nums = [6,1,7,4]`. An array is **fair** if the sum of the oddindexed values equals the sum of the evenindexed values. Return the _**number** of indices that you could choose such that after the removal,_ `nums` _is **fair**._ **Example 1:** **Input:** nums = [2,1,6,4] **Output:** 1 **Explanation:** Remove index 0: [1,6,4] > Even sum: 1 + 4 = 5. Odd sum: 6. Not fair. Remove index 1: [2,6,4] > Even sum: 2 + 4 = 6. Odd sum: 6. Fair. Remove index 2: [2,1,4] > Even sum: 2 + 4 = 6. Odd sum: 1. Not fair. Remove index 3: [2,1,6] > Even sum: 2 + 6 = 8. Odd sum: 1. Not fair. There is 1 index that you can remove to make nums fair. **Example 2:** **Input:** nums = [1,1,1] **Output:** 3 **Explanation:** You can remove any index and the remaining array is fair. **Example 3:** **Input:** nums = [1,2,3] **Output:** 0 **Explanation:** You cannot make a fair array after removing any index. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 104`","completion":"def numberOfFairs(nums): even_sum = sum(nums[0::2]) odd_sum = sum(nums[1::2]) l_even = l_odd = count = 0 for i, num in enumerate(nums): if i % 2 == 0: even_sum -= num if l_even + odd_sum == l_odd + even_sum: count += 1 l_even += num else: odd_sum -= num if l_even + odd_sum == l_odd + even_sum: count += 1 l_odd += num return count"},{"prompt":"You are given an array `target` that consists of **distinct** integers and another integer array `arr` that **can** have duplicates. In one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array. Return _the **minimum** number of operations needed to make_ `target` _a **subsequence** of_ `arr`_._ A **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements\' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not. **Example 1:** **Input:** target = [5,1,3], `arr` = [9,4,2,3,4] **Output:** 2 **Explanation:** You can add 5 and 1 in such a way that makes `arr` = [5,9,4,1,2,3,4], then target will be a subsequence of `arr`. **Example 2:** **Input:** target = [6,4,8,1,3,2], `arr` = [4,7,6,2,3,8,6,1] **Output:** 3 **Constraints:** * `1 <= target.length, arr.length <= 105` * `1 <= target[i], arr[i] <= 109` * `target` contains no duplicates.","completion":"from bisect import bisect_left def minOperations(target, arr): pos = {x: i for i, x in enumerate(target)} dp = [] for a in arr: if a in pos: idx = bisect_left(dp, pos[a]) if idx == len(dp): dp.append(pos[a]) else: dp[idx] = pos[a] return len(target) - len(dp)"},{"prompt":"You would like to make dessert and are preparing to buy the ingredients. You have `n` ice cream base flavors and `m` types of toppings to choose from. You must follow these rules when making your dessert: * There must be **exactly one** ice cream base. * You can add **one or more** types of topping or have no toppings at all. * There are **at most two** of **each type** of topping. You are given three inputs: * `baseCosts`, an integer array of length `n`, where each `baseCosts[i]` represents the price of the `ith` ice cream base flavor. * `toppingCosts`, an integer array of length `m`, where each `toppingCosts[i]` is the price of **one** of the `ith` topping. * `target`, an integer representing your target price for dessert. You want to make a dessert with a total cost as close to `target` as possible. Return _the closest possible cost of the dessert to_ `target`. If there are multiple, return _the **lower** one._ **Example 1:** **Input:** baseCosts = [1,7], toppingCosts = [3,4], target = 10 **Output:** 10 **Explanation:** Consider the following combination (all 0indexed): Choose base 1: cost 7 Take 1 of topping 0: cost 1 x 3 = 3 Take 0 of topping 1: cost 0 x 4 = 0 Total: 7 + 3 + 0 = 10. **Example 2:** **Input:** baseCosts = [2,3], toppingCosts = [4,5,100], target = 18 **Output:** 17 **Explanation:** Consider the following combination (all 0indexed): Choose base 1: cost 3 Take 1 of topping 0: cost 1 x 4 = 4 Take 2 of topping 1: cost 2 x 5 = 10 Take 0 of topping 2: cost 0 x 100 = 0 Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18. **Example 3:** **Input:** baseCosts = [3,10], toppingCosts = [2,5], target = 9 **Output:** 8 **Explanation:** It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost. **Constraints:** * `n == baseCosts.length` * `m == toppingCosts.length` * `1 <= n, m <= 10` * `1 <= baseCosts[i], toppingCosts[i] <= 104` * `1 <= target <= 104`","completion":"from itertools import product def closest_cost(base_costs, topping_costs, target): closest = float(\'inf\') topping_combinations = list(product([0, 1, 2], repeat=len(topping_costs))) for base in base_costs: for combination in topping_combinations: combination_cost = sum(x * y for x, y in zip(topping_costs, combination)) diff = abs(target - (base + combination_cost)) if diff < closest: closest = diff if diff == 0: return target return target - closest"},{"prompt":"There are `n` cities numbered from `0` to `n 1` and `n 1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by `connections` where `connections[i] = [ai, bi]` represents a road from city `ai` to city `bi`. This year, there will be a big event in the capital (city `0`), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city `0`. Return the **minimum** number of edges changed. It\'s **guaranteed** that each city can reach city `0` after reorder. **Example 1:** **Input:** n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]] **Output:** 3 **Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital). **Example 2:** **Input:** n = 5, connections = [[1,0],[1,2],[3,2],[3,4]] **Output:** 2 **Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital). **Example 3:** **Input:** n = 3, connections = [[1,0],[2,0]] **Output:** 0 **Constraints:** * `2 <= n <= 5 * 104` * `connections.length == n 1` * `connections[i].length == 2` * `0 <= ai, bi <= n 1` * `ai != bi`","completion":"def maxJumps(arr, d): n = len(arr) dp = [1] * n def helper(idx): if dp[idx] > 1: return dp[idx] maximum = 1 for i in range(1, d + 1): if idx + i < n and arr[idx] <= arr[idx + i]: break if idx + i < n: maximum = max(maximum, 1 + helper(idx + i)) if idx - i >= 0 and arr[idx] <= arr[idx - i]: break if idx - i >= 0: maximum = max(maximum, 1 + helper(idx - i)) dp[idx] = maximum return maximum for i in range(n): helper(i) return max(dp)"},{"prompt":"You are given an integer array `nums` of size `n` containing **each** element from `0` to `n 1` (**inclusive**). Each of the elements from `1` to `n 1` represents an item, and the element `0` represents an empty space. In one operation, you can move **any** item to the empty space. `nums` is considered to be sorted if the numbers of all the items are in **ascending** order and the empty space is either at the beginning or at the end of the array. For example, if `n = 4`, `nums` is sorted if: * `nums = [0,1,2,3]` or * `nums = [1,2,3,0]` ...and considered to be unsorted otherwise. Return _the **minimum** number of operations needed to sort_ `nums`. **Example 1:** **Input:** nums = [4,2,0,3,1] **Output:** 3 **Explanation:** Move item 2 to the empty space. Now, nums = [4,0,2,3,1]. Move item 1 to the empty space. Now, nums = [4,1,2,3,0]. Move item 4 to the empty space. Now, nums = [0,1,2,3,4]. It can be proven that 3 is the minimum number of operations needed. **Example 2:** **Input:** nums = [1,2,3,4,0] **Output:** 0 **Explanation:** nums is already sorted so return 0. **Example 3:** **Input:** nums = [1,0,2,4,3] **Output:** 2 **Explanation:** Move item 2 to the empty space. Now, nums = [1,2,0,4,3]. Move item 3 to the empty space. Now, nums = [1,2,3,4,0]. It can be proven that 2 is the minimum number of operations needed. **Constraints:** * `n == nums.length` * `2 <= n <= 105` * `0 <= nums[i] < n` * All the values of `nums` are **unique**.","completion":"def min_operations(nums): n = len(nums) idx0 = -1 for i in range(n): if nums[i] == 0: idx0 = i break cnt1 = 0 cnt2 = 0 for i in range(1, n): if abs(nums[i] - nums[i - 1]) != 1: cnt1 += abs(nums[i] - nums[i - 1]) - 1 for i in range(idx0 + 1, n): if nums[i] < nums[i - 1]: cnt2 += 1 return min(cnt1, cnt2)"},{"prompt":"We are given an array `asteroids` of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet. **Example 1:** **Input:** asteroids = [5,10,5] **Output:** [5,10] **Explanation:** The 10 and 5 collide resulting in 10. The 5 and 10 never collide. **Example 2:** **Input:** asteroids = [8,8] **Output:** [] **Explanation:** The 8 and 8 collide exploding each other. **Example 3:** **Input:** asteroids = [10,2,5] **Output:** [10] **Explanation:** The 2 and 5 collide resulting in 5. The 10 and 5 collide resulting in 10. **Constraints:** * `2 <= asteroids.length <= 104` * `1000 <= asteroids[i] <= 1000` * `asteroids[i] != 0`","completion":"def asteroidCollision(asteroids): s = [] for num in asteroids: if num > 0 or not s or s[-1] < 0: s.append(num) elif s[-1] <= -num: if s[-1] < -num: s.pop() s.append(num) else: s.pop() return s"},{"prompt":"Given two integers `num` and `k`, consider a set of positive integers with the following properties: * The units digit of each integer is `k`. * The sum of the integers is `num`. Return _the **minimum** possible size of such a set, or_ `1` _if no such set exists._ Note: * The set can contain multiple instances of the same integer, and the sum of an empty set is considered `0`. * The **units digit** of a number is the rightmost digit of the number. **Example 1:** **Input:** num = 58, k = 9 **Output:** 2 **Explanation:** One valid set is [9,49], as the sum is 58 and each integer has a units digit of 9. Another valid set is [19,39]. It can be shown that 2 is the minimum possible size of a valid set. **Example 2:** **Input:** num = 37, k = 2 **Output:** 1 **Explanation:** It is not possible to obtain a sum of 37 using only integers that have a units digit of 2. **Example 3:** **Input:** num = 0, k = 7 **Output:** 0 **Explanation:** The sum of an empty set is considered 0. **Constraints:** * `0 <= num <= 3000` * `0 <= k <= 9`","completion":"def min_operations(nums): nums.sort(reverse=True) total_sum = sum(nums) half_sum, operations = 0, 0 for num in nums: half_sum += num operations += 1 if half_sum >= (total_sum + 1) // 2: break return operations"},{"prompt":"Given an array of integers `arr`, and three integers `a`, `b` and `c`. You need to find the number of good triplets. A triplet `(arr[i], arr[j], arr[k])` is **good** if the following conditions are true: * `0 <= i < j < k < arr.length` * `|arr[i] arr[j]| <= a` * `|arr[j] arr[k]| <= b` * `|arr[i] arr[k]| <= c` Where `|x|` denotes the absolute value of `x`. Return _the number of good triplets_. **Example 1:** **Input:** arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3 **Output:** 4 **Explanation:** There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)]. **Example 2:** **Input:** arr = [1,1,2,2,3], a = 0, b = 0, c = 1 **Output:** 0 **Explanation:** No triplet satisfies all conditions. **Constraints:** * `3 <= arr.length <= 100` * `0 <= arr[i] <= 1000` * `0 <= a, b, c <= 1000`","completion":"def minNumberOfFrogs(croakOfFrogs: str) -> int: counts = [0] * 5 max_frogs = 0 for c in croakOfFrogs: index = \\"croak\\".find(c) if index == 0: counts[0] += 1 max_frogs = max(max_frogs, counts[0]) elif counts[index - 1] > 0: counts[index - 1] -= 1 counts[index] += 1 else: return -1 if counts[0] == counts[4]: return max_frogs else: return -1"},{"prompt":"You are given a **(0indexed)** array of positive integers `candiesCount` where `candiesCount[i]` represents the number of candies of the `ith` type you have. You are also given a 2D array `queries` where `queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]`. You play a game with the following rules: * You start eating candies on day `**0**`. * You **cannot** eat **any** candy of type `i` unless you have eaten **all** candies of type `i 1`. * You must eat **at least** **one** candy per day until you have eaten all the candies. Construct a boolean array `answer` such that `answer.length == queries.length` and `answer[i]` is `true` if you can eat a candy of type `favoriteTypei` on day `favoriteDayi` without eating **more than** `dailyCapi` candies on **any** day, and `false` otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2. Return _the constructed array_ `answer`. **Example 1:** **Input:** candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] **Output:** [true,false,true] **Explanation:** 1 If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2. 2 You can eat at most 4 candies each day. If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1. On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2. 3 If you eat 1 candy each day, you will eat a candy of type 2 on day 13. **Example 2:** **Input:** candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] **Output:** [false,true,true,false,false] **Constraints:** * `1 <= candiesCount.length <= 105` * `1 <= candiesCount[i] <= 105` * `1 <= queries.length <= 105` * `queries[i].length == 3` * `0 <= favoriteTypei < candiesCount.length` * `0 <= favoriteDayi <= 109` * `1 <= dailyCapi <= 109`","completion":"def num_ways(words, target): n, m = len(words), len(target) MOD = 10**9 + 7 cnt = [0] * 26 for word in words: for ch in word: cnt[ord(ch) - ord(\'a\')] += 1 dp = [0] * (m + 1) dp[0] = 1 for ch in target: for i in range(m - 1, -1, -1): dp[i + 1] += dp[i] * cnt[ord(ch) - ord(\'a\')] dp[i + 1] %= MOD return dp[m]"},{"prompt":"There is an infrastructure of `n` cities with some number of `roads` connecting these cities. Each `roads[i] = [ai, bi]` indicates that there is a bidirectional road between cities `ai` and `bi`. The **network rank** of **two different cities** is defined as the total number of **directly** connected roads to **either** city. If a road is directly connected to both cities, it is only counted **once**. The **maximal network rank** of the infrastructure is the **maximum network rank** of all pairs of different cities. Given the integer `n` and the array `roads`, return _the **maximal network rank** of the entire infrastructure_. **Example 1:** **Input:** n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] **Output:** 4 **Explanation:** The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once. **Example 2:** **Input:** n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] **Output:** 5 **Explanation:** There are 5 roads that are connected to cities 1 or 2. **Example 3:** **Input:** n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] **Output:** 5 **Explanation:** The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected. **Constraints:** * `2 <= n <= 100` * `0 <= roads.length <= n * (n 1) / 2` * `roads[i].length == 2` * `0 <= ai, bi <= n1` * `ai != bi` * Each pair of cities has **at most one** road connecting them.","completion":"def range_sum(nums, n, left, right): MOD = 10**9 + 7 sums = [] for i in range(n): sum = 0 for j in range(i, n): sum += nums[j] sums.append(sum) sums.sort() result = 0 for i in range(left-1, right): result = (result + sums[i]) % MOD return result"},{"prompt":"You are given a positive integer `num`. You may swap any two digits of `num` that have the same **parity** (i.e. both odd digits or both even digits). Return _the **largest** possible value of_ `num` _after **any** number of swaps._ **Example 1:** **Input:** num = 1234 **Output:** 3412 **Explanation:** Swap the digit 3 with the digit 1, this results in the number 3214. Swap the digit 2 with the digit 4, this results in the number 3412. Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number. Also note that we may not swap the digit 4 with the digit 1 since they are of different parities. **Example 2:** **Input:** num = 65875 **Output:** 87655 **Explanation:** Swap the digit 8 with the digit 6, this results in the number 85675. Swap the first digit 5 with the digit 7, this results in the number 87655. Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number. **Constraints:** * `1 <= num <= 109`","completion":"def first_palindrome(words): for word in words: if word == word[::-1]: return word return \\"\\""},{"prompt":"You are given two integers `m` and `n`, which represent the dimensions of a matrix. You are also given the `head` of a linked list of integers. Generate an `m x n` matrix that contains the integers in the linked list presented in **spiral** order **(clockwise)**, starting from the **topleft** of the matrix. If there are remaining empty spaces, fill them with `1`. Return _the generated matrix_. **Example 1:** **Input:** m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0] **Output:** [[3,0,2,6,8],[5,0,1,1,1],[5,2,4,9,7]] **Explanation:** The diagram above shows how the values are printed in the matrix. Note that the remaining spaces in the matrix are filled with 1. **Example 2:** **Input:** m = 1, n = 4, head = [0,1,2] **Output:** [[0,1,2,1]] **Explanation:** The diagram above shows how the values are printed from left to right in the matrix. The last space in the matrix is set to 1. **Constraints:** * `1 <= m, n <= 105` * `1 <= m * n <= 105` * The number of nodes in the list is in the range `[1, m * n]`. * `0 <= Node.val <= 1000`","completion":"def sum_prefix_scores(s: str) -> int: n = len(s) sum_scores = 0 longest_common_prefix = 0 for i in range(n - 1, -1, -1): if s[i] == s[n - 1 - longest_common_prefix]: longest_common_prefix += 1 else: longest_common_prefix = 0 sum_scores += longest_common_prefix return sum_scores"},{"prompt":"There are `n` hens and `m` grains on a line. You are given the initial positions of the hens and the grains in two integer arrays `hens` and `grains` of size `n` and `m` respectively. Any hen can eat a grain if they are on the same position. The time taken for this is negligible. One hen can also eat multiple grains. In `1` second, a hen can move right or left by `1` unit. The hens can move simultaneously and independently of each other. Return _the **minimum** time to eat all grains if the hens act optimally._ **Example 1:** **Input:** hens = [3,6,7], grains = [2,4,7,9] **Output:** 2 **Explanation:** One of the ways hens eat all grains in 2 seconds is described below: The first hen eats the grain at position 2 in 1 second. The second hen eats the grain at position 4 in 2 seconds. The third hen eats the grains at positions 7 and 9 in 2 seconds. So, the maximum time needed is 2. It can be proven that the hens cannot eat all grains before 2 seconds. **Example 2:** **Input:** hens = [4,6,109,111,213,215], grains = [5,110,214] **Output:** 1 **Explanation:** One of the ways hens eat all grains in 1 second is described below: The first hen eats the grain at position 5 in 1 second. The fourth hen eats the grain at position 110 in 1 second. The sixth hen eats the grain at position 214 in 1 second. The other hens do not move. So, the maximum time needed is 1. **Constraints:** * `1 <= hens.length, grains.length <= 2*104` * `0 <= hens[i], grains[j] <= 109`","completion":"def min_time_to_eat_grains(hens, grains): hens.sort() grains.sort() left, right = 0, 10**9 while left < right: mid = left + (right - left) // 2 can_eat = True i = 0 for grain in grains: if i >= len(hens): can_eat = False break while i < len(hens) and hens[i] < grain - mid: i += 1 if i >= len(hens) or hens[i] > grain + mid: can_eat = False break i += 1 if can_eat: right = mid else: left = mid + 1 return left"},{"prompt":"A car travels from a starting position to a destination which is `target` miles east of the starting position. There are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas. The car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. Return _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `1`. Note that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived. **Example 1:** **Input:** target = 1, startFuel = 1, stations = [] **Output:** 0 **Explanation:** We can reach the target without refueling. **Example 2:** **Input:** target = 100, startFuel = 1, stations = [[10,100]] **Output:** 1 **Explanation:** We can not reach the target (or even the first gas station). **Example 3:** **Input:** target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] **Output:** 2 **Explanation:** We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel. We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas. We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2. **Constraints:** * `1 <= target, startFuel <= 109` * `0 <= stations.length <= 500` * `1 <= positioni < positioni+1 < target` * `1 <= fueli < 109`","completion":"def can_visit_all_rooms(rooms): visited = set() stack = [0] while stack: current_room = stack.pop() visited.add(current_room) for key in rooms[current_room]: if key not in visited: stack.append(key) return len(visited) == len(rooms)"},{"prompt":"There are `n` flights that are labeled from `1` to `n`. You are given an array of flight bookings `bookings`, where `bookings[i] = [firsti, lasti, seatsi]` represents a booking for flights `firsti` through `lasti` (**inclusive**) with `seatsi` seats reserved for **each flight** in the range. Return _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the total number of seats reserved for flight_ `i`. **Example 1:** **Input:** bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 **Output:** [10,55,45,25,25] **Explanation:** Flight labels: 1 2 3 4 5 Booking 1 reserved: 10 10 Booking 2 reserved: 20 20 Booking 3 reserved: 25 25 25 25 Total seats: 10 55 45 25 25 Hence, answer = [10,55,45,25,25] **Example 2:** **Input:** bookings = [[1,2,10],[2,2,15]], n = 2 **Output:** [10,25] **Explanation:** Flight labels: 1 2 Booking 1 reserved: 10 10 Booking 2 reserved: 15 Total seats: 10 25 Hence, answer = [10,25] **Constraints:** * `1 <= n <= 2 * 104` * `1 <= bookings.length <= 2 * 104` * `bookings[i].length == 3` * `1 <= firsti <= lasti <= n` * `1 <= seatsi <= 104`","completion":"def corpFlightBookings(bookings, n): seats = [0] * n for booking in bookings: seats[booking[0] - 1] += booking[2] if booking[1] < n: seats[booking[1]] -= booking[2] for i in range(1, n): seats[i] += seats[i - 1] return seats"},{"prompt":"You are given an integer `n`. There is an **undirected** graph with `n` nodes, numbered from `0` to `n 1`. You are given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`. Return _the **number of pairs** of different nodes that are **unreachable** from each other_. **Example 1:** **Input:** n = 3, edges = [[0,1],[0,2],[1,2]] **Output:** 0 **Explanation:** There are no pairs of nodes that are unreachable from each other. Therefore, we return 0. **Example 2:** **Input:** n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]] **Output:** 14 **Explanation:** There are 14 pairs of nodes that are unreachable from each other: [[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]. Therefore, we return 14. **Constraints:** * `1 <= n <= 105` * `0 <= edges.length <= 2 * 105` * `edges[i].length == 2` * `0 <= ai, bi < n` * `ai != bi` * There are no repeated edges.","completion":"def count_hills_valleys(nums): count = 0 for i in range(1, len(nums) - 1): if (nums[i] > nums[i - 1] and nums[i] > nums[i + 1]) or (nums[i] < nums[i - 1] and nums[i] < nums[i + 1]): count += 1 return count"},{"prompt":"Given the array `houses` where `houses[i]` is the location of the `ith` house along a street and an integer `k`, allocate `k` mailboxes in the street. Return _the **minimum** total distance between each house and its nearest mailbox_. The test cases are generated so that the answer fits in a 32bit integer. **Example 1:** **Input:** houses = [1,4,8,10,20], k = 3 **Output:** 5 **Explanation:** Allocate mailboxes in position 3, 9 and 20. Minimum total distance from each houses to nearest mailboxes is |31| + |43| + |98| + |109| + |2020| = 5 **Example 2:** **Input:** houses = [2,3,5,12,18], k = 2 **Output:** 9 **Explanation:** Allocate mailboxes in position 3 and 14. Minimum total distance from each houses to nearest mailboxes is |23| + |33| + |53| + |1214| + |1814| = 9. **Constraints:** * `1 <= k <= houses.length <= 100` * `1 <= houses[i] <= 104` * All the integers of `houses` are **unique**.","completion":"def max_events(events): events.sort(key=lambda x: x[1]) count = 0 last_day = -1 for event in events: if event[0] > last_day: count += 1 last_day = event[1] return count"},{"prompt":"You have `n` bags numbered from `0` to `n 1`. You are given two **0indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags. Return _the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._ **Example 1:** **Input:** capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2 **Output:** 3 **Explanation:** Place 1 rock in bag 0 and 1 rock in bag 1. The number of rocks in each bag are now [2,3,4,4]. Bags 0, 1, and 2 have full capacity. There are 3 bags at full capacity, so we return 3. It can be shown that it is not possible to have more than 3 bags at full capacity. Note that there may be other ways of placing the rocks that result in an answer of 3. **Example 2:** **Input:** capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100 **Output:** 3 **Explanation:** Place 8 rocks in bag 0 and 2 rocks in bag 2. The number of rocks in each bag are now [10,2,2]. Bags 0, 1, and 2 have full capacity. There are 3 bags at full capacity, so we return 3. It can be shown that it is not possible to have more than 3 bags at full capacity. Note that we did not use all of the additional rocks. **Constraints:** * `n == capacity.length == rocks.length` * `1 <= n <= 5 * 104` * `1 <= capacity[i] <= 109` * `0 <= rocks[i] <= capacity[i]` * `1 <= additionalRocks <= 109`","completion":"def max_unique_even_sum(final_sum): result = [] current = 2 while final_sum > 0: if final_sum >= current: result.append(current) final_sum -= current current += 2 else: break return result"},{"prompt":"You are given a **0indexed** array of **distinct** integers `nums`. There is an element in `nums` that has the **lowest** value and an element that has the **highest** value. We call them the **minimum** and **maximum** respectively. Your goal is to remove **both** these elements from the array. A **deletion** is defined as either removing an element from the **front** of the array or removing an element from the **back** of the array. Return _the **minimum** number of deletions it would take to remove **both** the minimum and maximum element from the array._ **Example 1:** **Input:** nums = [2,**10**,7,5,4,**1**,8,6] **Output:** 5 **Explanation:** The minimum element in the array is nums[5], which is 1. The maximum element in the array is nums[1], which is 10. We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back. This results in 2 + 3 = 5 deletions, which is the minimum number possible. **Example 2:** **Input:** nums = [0,**4**,**19**,1,8,2,3,5] **Output:** 3 **Explanation:** The minimum element in the array is nums[1], which is 4. The maximum element in the array is nums[2], which is 19. We can remove both the minimum and maximum by removing 3 elements from the front. This results in only 3 deletions, which is the minimum number possible. **Example 3:** **Input:** nums = [**101**] **Output:** 1 **Explanation:** There is only one element in the array, which makes it both the minimum and maximum element. We can remove it with 1 deletion. **Constraints:** * `1 <= nums.length <= 105` * `105 <= nums[i] <= 105` * The integers in `nums` are **distinct**.","completion":"def numberOfLists(num: str) -> int: mod = 10 ** 9 + 7 n = len(num) dp = [[0] * (n + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(n): for j in range(1, n + 1): if num[i] == \'0\': continue for k in range(1, min(n - i + 1, 11)): if k > 1 and num[i + k - 1] == \'0\': break dp[i + k][j] = (dp[i + k][j] + dp[i][j - 1]) % mod return sum(dp[n]) % mod"},{"prompt":"Given two integers n and k, return _an array of all the integers of length_ `n` _where the difference between every two consecutive digits is_ `k`. You may return the answer in **any order**. Note that the integers should not have leading zeros. Integers as `02` and `043` are not allowed. **Example 1:** **Input:** n = 3, k = 7 **Output:** [181,292,707,818,929] **Explanation:** Note that 070 is not a valid number, because it has leading zeroes. **Example 2:** **Input:** n = 2, k = 1 **Output:** [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98] **Constraints:** * `2 <= n <= 9` * `0 <= k <= 9`","completion":"def minFallingPathSum(matrix): n = len(matrix) for i in range(1, n): for j in range(n): min_val = matrix[i - 1][j] if j > 0: min_val = min(min_val, matrix[i - 1][j - 1]) if j < n - 1: min_val = min(min_val, matrix[i - 1][j + 1]) matrix[i][j] += min_val return min(matrix[-1])"},{"prompt":"Given an integer array `arr`, return _the mean of the remaining integers after removing the smallest `5%` and the largest `5%` of the elements._ Answers within `105` of the **actual answer** will be considered accepted. **Example 1:** **Input:** arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] **Output:** 2.00000 **Explanation:** After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2. **Example 2:** **Input:** arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] **Output:** 4.00000 **Example 3:** **Input:** arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4] **Output:** 4.77778 **Constraints:** * `20 <= arr.length <= 1000` * `arr.length` **is a multiple** of `20`. * `0 <= arr[i] <= 105`","completion":"def is_path_crossing(path: str) -> bool: visited = {(0, 0)} x, y = 0, 0 for dir in path: if dir == \'N\': y += 1 elif dir == \'S\': y -= 1 elif dir == \'E\': x += 1 elif dir == \'W\': x -= 1 if (x, y) in visited: return True visited.add((x, y)) return False"},{"prompt":"You have `k` lists of sorted integers in **nondecreasing order**. Find the **smallest** range that includes at least one number from each of the `k` lists. We define the range `[a, b]` is smaller than range `[c, d]` if `b a < d c` **or** `a < c` if `b a == d c`. **Example 1:** **Input:** nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]] **Output:** [20,24] **Explanation:** List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24]. **Example 2:** **Input:** nums = [[1,2,3],[1,2,3],[1,2,3]] **Output:** [1,1] **Constraints:** * `nums.length == k` * `1 <= k <= 3500` * `1 <= nums[i].length <= 50` * `105 <= nums[i][j] <= 105` * `nums[i]` is sorted in **nondecreasing** order.","completion":"import heapq def smallestRange(nums): minHeap = [] maxVal = -1e9 for i, lst in enumerate(nums): heapq.heappush(minHeap, (lst[0], i)) maxVal = max(maxVal, lst[0]) listIndices = [0] * len(nums) minRange = 1e9 start, end = -1, -1 while len(minHeap) == len(nums): val, listIdx = heapq.heappop(minHeap) range_ = maxVal - val if range_ < minRange: minRange = range_ start, end = val, maxVal listIndices[listIdx] += 1 if listIndices[listIdx] < len(nums[listIdx]): newVal = nums[listIdx][listIndices[listIdx]] heapq.heappush(minHeap, (newVal, listIdx)) maxVal = max(maxVal, newVal) return [start, end]"},{"prompt":"Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold: 1. The code must be wrapped in a **valid closed tag**. Otherwise, the code is invalid. 2. A **closed tag** (not necessarily valid) has exactly the following format : `TAG_CONTENT`. Among them, is the start tag, and is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is **valid** if and only if the TAG_NAME and TAG_CONTENT are valid. 3. A **valid** `TAG_NAME` only contain **uppercase letters**, and has length in range [1,9]. Otherwise, the `TAG_NAME` is **invalid**. 4. A **valid** `TAG_CONTENT` may contain other **valid closed tags**, **cdata** and any characters (see note1) **EXCEPT** unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the `TAG_CONTENT` is **invalid**. 5. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. 6. A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or ``, all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).`` ``` * The cdata has the following format : . The range of `CDATA_CONTENT` is defined as the characters between ``and the **first subsequent** `]]>`.`` ``* `CDATA_CONTENT` may contain **any characters**. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as **regular characters**.`` ``` ``` `` **Example 1:** **Input:** code = This is the first line ]]> **Output:** true **Explanation:** The code is wrapped in a closed tag : and . The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true. **Example 2:** **Input:** code = >> ![cdata[]] ]>]]>]]>>] **Output:** true **Explanation:** We first separate the code into : start_tag|tag_content|end_tag. start_tag > ** ** **** end_tag > ** ** **** tag_content could also be separated into : text1|cdata|text2. text1 > ** >> ![cdata[]] ** cdata > ** ]>]]> **, where the CDATA_CONTENT is ** ** **]> ** text2 > ** ]]>>] ** The reason why start_tag is NOT ** ** **>> ** is because of the rule 6. The reason why cdata is NOT ** ]>]]>]]> ** is because of the rule 7. **Example 3:** **Input:** code = **Output:** false **Explanation:** Unbalanced. If is closed, then ** must be unmatched, and vice versa.** ** **Constraints:** * `1 <= code.length <= 500` * `code` consists of English letters, digits, `\'<\'`, `\'>\'`, `\'/\'`, `\'!\'`, `\'[\'`, `\']\'`, `\'.\'`, and `\' \'`. **`` ```","completion":"def is_valid(code, i): if i >= len(code) or code[i] != \'<\': return False, i i += 1 name_start = i while i < len(code) and code[i].isupper(): i += 1 name_len = i - name_start if name_len < 1 or name_len > 9 or code[i] != \'>\': return False, i i += 1 while i < len(code) and code[i] != \'<\': i += 1 if i + 2 + name_len >= len(code) or code[i:i + 2 + name_len] != \'</\' + code[name_start:i] + \'>\': return False, i return True, i + 2 + name_len def validate_code_snippet(code): is_valid_code, i = is_valid(code, 0) return is_valid_code and i == len(code)"},{"prompt":"You are given an array of characters `letters` that is sorted in **nondecreasing order**, and a character `target`. There are **at least two different** characters in `letters`. Return _the smallest character in_ `letters` _that is lexicographically greater than_ `target`. If such a character does not exist, return the first character in `letters`. **Example 1:** **Input:** letters = [ c , f , j ], target = a **Output:** c **Explanation:** The smallest character that is lexicographically greater than \'a\' in letters is \'c\'. **Example 2:** **Input:** letters = [ c , f , j ], target = c **Output:** f **Explanation:** The smallest character that is lexicographically greater than \'c\' in letters is \'f\'. **Example 3:** **Input:** letters = [ x , x , y , y ], target = z **Output:** x **Explanation:** There are no characters in letters that is lexicographically greater than \'z\' so we return letters[0]. **Constraints:** * `2 <= letters.length <= 104` * `letters[i]` is a lowercase English letter. * `letters` is sorted in **nondecreasing** order. * `letters` contains at least two different characters. * `target` is a lowercase English letter.","completion":"import heapq from collections import defaultdict def networkDelayTime(times, n, k): graph = defaultdict(list) for u, v, w in times: graph[u].append((v, w)) dist = {i: float(\'inf\') for i in range(1, n + 1)} dist[k] = 0 pq = [(0, k)] while pq: time, node = heapq.heappop(pq) if time > dist[node]: continue for neighbour, neighbourTime in graph[node]: candidate_dist = time + neighbourTime if candidate_dist < dist[neighbour]: dist[neighbour] = candidate_dist heapq.heappush(pq, (candidate_dist, neighbour)) maxTime = max(dist.values()) return maxTime if maxTime < float(\'inf\') else -1"},{"prompt":"You are given a string `s`. Reorder the string using the following algorithm: 1. Pick the **smallest** character from `s` and **append** it to the result. 2. Pick the **smallest** character from `s` which is greater than the last appended character to the result and **append** it. 3. Repeat step 2 until you cannot pick more characters. 4. Pick the **largest** character from `s` and **append** it to the result. 5. Pick the **largest** character from `s` which is smaller than the last appended character to the result and **append** it. 6. Repeat step 5 until you cannot pick more characters. 7. Repeat the steps from 1 to 6 until you pick all characters from `s`. In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result. Return _the result string after sorting_ `s` _with this algorithm_. **Example 1:** **Input:** s = aaaabbbbcccc **Output:** abccbaabccba **Explanation:** After steps 1, 2 and 3 of the first iteration, result = abc After steps 4, 5 and 6 of the first iteration, result = abccba First iteration is done. Now s = aabbcc and we go back to step 1 After steps 1, 2 and 3 of the second iteration, result = abccbaabc After steps 4, 5 and 6 of the second iteration, result = abccbaabccba **Example 2:** **Input:** s = rat **Output:** art **Explanation:** The word rat becomes art after reordering it with the mentioned algorithm. **Constraints:** * `1 <= s.length <= 500` * `s` consists of only lowercase English letters.","completion":"def numberOfSubarrays(nums, k): n = len(nums) result = count = 0 odd_count = [0] * (n + 1) odd_count[0] = 1 for num in nums: count += num % 2 if count >= k: result += odd_count[count - k] odd_count[count] += 1 return result"},{"prompt":"You are given a binary array `nums` (**0indexed**). We define `xi` as the number whose binary representation is the subarray `nums[0..i]` (from mostsignificantbit to leastsignificantbit). * For example, if `nums = [1,0,1]`, then `x0 = 1`, `x1 = 2`, and `x2 = 5`. Return _an array of booleans_ `answer` _where_ `answer[i]` _is_ `true` _if_ `xi` _is divisible by_ `5`. **Example 1:** **Input:** nums = [0,1,1] **Output:** [true,false,false] **Explanation:** The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base10. Only the first number is divisible by 5, so answer[0] is true. **Example 2:** **Input:** nums = [1,1,1] **Output:** [false,false,false] **Constraints:** * `1 <= nums.length <= 105` * `nums[i]` is either `0` or `1`.","completion":"def largestPerimeter(nums): nums.sort(reverse=True) for i in range(len(nums) - 2): if nums[i] < nums[i + 1] + nums[i + 2]: return nums[i] + nums[i + 1] + nums[i + 2] return 0"},{"prompt":"You are given an integer array `arr`. Sort the integers in the array in ascending order by the number of `1`\'s in their binary representation and in case of two or more integers have the same number of `1`\'s you have to sort them in ascending order. Return _the array after sorting it_. **Example 1:** **Input:** arr = [0,1,2,3,4,5,6,7,8] **Output:** [0,1,2,4,8,3,5,6,7] **Explantion:** [0] is the only integer with 0 bits. [1,2,4,8] all have 1 bit. [3,5,6] have 2 bits. [7] has 3 bits. The sorted array by bits is [0,1,2,4,8,3,5,6,7] **Example 2:** **Input:** arr = [1024,512,256,128,64,32,16,8,4,2,1] **Output:** [1,2,4,8,16,32,64,128,256,512,1024] **Explantion:** All integers have 1 bit in the binary representation, you should just sort them in ascending order. **Constraints:** * `1 <= arr.length <= 500` * `0 <= arr[i] <= 104`","completion":"def min_moves_to_palindrome(s: str) -> int: moves = 0 s = list(s) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: temp_right = right while s[left] != s[temp_right]: temp_right -= 1 s.insert(right, s.pop(temp_right)) moves += right - temp_right left += 1 right -= 1 return moves"},{"prompt":"Given the strings `s1` and `s2` of size `n` and the string `evil`, return _the number of **good** strings_. A **good** string has size `n`, it is alphabetically greater than or equal to `s1`, it is alphabetically smaller than or equal to `s2`, and it does not contain the string `evil` as a substring. Since the answer can be a huge number, return this **modulo** `109 + 7`. **Example 1:** **Input:** n = 2, s1 = aa , s2 = da , evil = b **Output:** 51 **Explanation:** There are 25 good strings starting with \'a\': aa , ac , ad ,..., az . Then there are 25 good strings starting with \'c\': ca , cc , cd ,..., cz and finally there is one good string starting with \'d\': da . **Example 2:** **Input:** n = 8, s1 = leetcode , s2 = leetgoes , evil = leet **Output:** 0 **Explanation:** All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix leet , therefore, there is not any good string. **Example 3:** **Input:** n = 2, s1 = gx , s2 = gz , evil = x **Output:** 2 **Constraints:** * `s1.length == n` * `s2.length == n` * `s1 <= s2` * `1 <= n <= 500` * `1 <= evil.length <= 50` * All strings consist of lowercase English letters.","completion":"from bisect import bisect_left def suggestedProducts(products, searchWord): products.sort() result = [] current_prefix = \\"\\" for letter in searchWord: current_prefix += letter index = bisect_left(products, current_prefix) suggestions = [] for i in range(3): if index < len(products) and products[index].startswith(current_prefix): suggestions.append(products[index]) index += 1 else: break result.append(suggestions) return result"},{"prompt":"You are given the array `nums` consisting of `n` positive integers. You computed the sum of all nonempty continuous subarrays from the array and then sorted them in nondecreasing order, creating a new array of `n * (n + 1) / 2` numbers. _Return the sum of the numbers from index_ `left` _to index_ `right` (**indexed from 1**)_, inclusive, in the new array._ Since the answer can be a huge number return it modulo `109 + 7`. **Example 1:** **Input:** nums = [1,2,3,4], n = 4, left = 1, right = 5 **Output:** 13 **Explanation:** All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in nondecreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. **Example 2:** **Input:** nums = [1,2,3,4], n = 4, left = 3, right = 4 **Output:** 6 **Explanation:** The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6. **Example 3:** **Input:** nums = [1,2,3,4], n = 4, left = 1, right = 10 **Output:** 50 **Constraints:** * `n == nums.length` * `1 <= nums.length <= 1000` * `1 <= nums[i] <= 100` * `1 <= left <= right <= n * (n + 1) / 2`","completion":"def longestHappyPrefix(s): n = len(s) lps = [0] * n length = 0 i = 1 while i < n: if s[i] == s[length]: length += 1 lps[i] = length i += 1 elif length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return s[:lps[-1]]"},{"prompt":"The **distance of a pair** of integers `a` and `b` is defined as the absolute difference between `a` and `b`. Given an integer array `nums` and an integer `k`, return _the_ `kth` _smallest **distance among all the pairs**_ `nums[i]` _and_ `nums[j]` _where_ `0 <= i < j < nums.length`. **Example 1:** **Input:** nums = [1,3,1], k = 1 **Output:** 0 **Explanation:** Here are all the pairs: (1,3) > 2 (1,1) > 0 (3,1) > 2 Then the 1st smallest distance pair is (1,1), and its distance is 0. **Example 2:** **Input:** nums = [1,1,1], k = 2 **Output:** 0 **Example 3:** **Input:** nums = [1,6,1], k = 3 **Output:** 5 **Constraints:** * `n == nums.length` * `2 <= n <= 104` * `0 <= nums[i] <= 106` * `1 <= k <= n * (n 1) / 2`","completion":"def smallestDistancePair(nums, k): nums.sort() low, high = 0, nums[-1] - nums[0] while low < high: mid = (low + high) // 2 count, left = 0, 0 for right in range(len(nums)): while nums[right] - nums[left] > mid: left += 1 count += (right - left) if count < k: low = mid + 1 else: high = mid return low"},{"prompt":"There is a special kind of apple tree that grows apples every day for `n` days. On the `ith` day, the tree grows `apples[i]` apples that will rot after `days[i]` days, that is on day `i + days[i]` the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by `apples[i] == 0` and `days[i] == 0`. You decided to eat **at most** one apple a day (to keep the doctors away). Note that you can keep eating after the first `n` days. Given two integer arrays `days` and `apples` of length `n`, return _the maximum number of apples you can eat._ **Example 1:** **Input:** apples = [1,2,3,5,2], days = [3,2,1,4,2] **Output:** 7 **Explanation:** You can eat 7 apples: On the first day, you eat an apple that grew on the first day. On the second day, you eat an apple that grew on the second day. On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot. On the fourth to the seventh days, you eat apples that grew on the fourth day. **Example 2:** **Input:** apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] **Output:** 5 **Explanation:** You can eat 5 apples: On the first to the third day you eat apples that grew on the first day. Do nothing on the fouth and fifth days. On the sixth and seventh days you eat apples that grew on the sixth day. **Constraints:** * `n == apples.length == days.length` * `1 <= n <= 2 * 104` * `0 <= apples[i], days[i] <= 2 * 104` * `days[i] = 0` if and only if `apples[i] = 0`.","completion":"def unhappyFriends(n, preferences, pairs): pair_mapping = [0] * n for pair in pairs: pair_mapping[pair[0]] = pair[1] pair_mapping[pair[1]] = pair[0] unhappy_count = 0 for x in range(n): y = pair_mapping[x] pref_x = preferences[x] idx_y = pref_x.index(y) for i in range(idx_y): u = pref_x[i] v = pair_mapping[u] pref_u = preferences[u] if x in pref_u[:pref_u.index(v)]: unhappy_count += 1 break return unhappy_count // 2"},{"prompt":"Given a string `text` and an array of strings `words`, return _an array of all index pairs_ `[i, j]` _so that the substring_ `text[i...j]` _is in `words`_. Return the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate). **Example 1:** **Input:** text = thestoryofleetcodeandme , words = [ story , fleet , leetcode ] **Output:** [[3,7],[9,13],[10,17]] **Example 2:** **Input:** text = ababa , words = [ aba , ab ] **Output:** [[0,1],[0,2],[2,3],[2,4]] **Explanation:** Notice that matches can overlap, see aba is found in [0,2] and [2,4]. **Constraints:** * `1 <= text.length <= 100` * `1 <= words.length <= 20` * `1 <= words[i].length <= 50` * `text` and `words[i]` consist of lowercase English letters. * All the strings of `words` are **unique**.","completion":"def has_all_codes_in_range(s: str, n: int) -> bool: substrings = set() length = len(bin(n)) - 2 for i in range(len(s) - length + 1): substrings.add(s[i:i + length]) return len(substrings) == n"},{"prompt":"Given two strings `s` and `part`, perform the following operation on `s` until **all** occurrences of the substring `part` are removed: * Find the **leftmost** occurrence of the substring `part` and **remove** it from `s`. Return `s` _after removing all occurrences of_ `part`. A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** s = daabcbaabcbc , part = abc **Output:** dab **Explanation**: The following operations are done: s = da**abc**baabcbc , remove abc starting at index 2, so s = dabaabcbc . s = daba**abc**bc , remove abc starting at index 4, so s = dababc . s = dab**abc** , remove abc starting at index 3, so s = dab . Now s has no occurrences of abc . **Example 2:** **Input:** s = axxxxyyyyb , part = xy **Output:** ab **Explanation**: The following operations are done: s = axxx**xy**yyyb , remove xy starting at index 4 so s = axxxyyyb . s = axx**xy**yyb , remove xy starting at index 3 so s = axxyyb . s = ax**xy**yb , remove xy starting at index 2 so s = axyb . s = a**xy**b , remove xy starting at index 1 so s = ab . Now s has no occurrences of xy . **Constraints:** * `1 <= s.length <= 1000` * `1 <= part.length <= 1000` * `s`​​​​​​ and `part` consists of lowercase English letters.","completion":"def check_ones_segment(s: str) -> bool: count = 0 for i in range(len(s)): if s[i] == \'1\': if i > 0 and s[i - 1] == \'0\': count += 1 return count <= 1"},{"prompt":"You are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**preorder traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Preorder) of the binary tree. Any node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect: Flip the **smallest** number of nodes so that the **preorder traversal** of the tree **matches** `voyage`. Return _a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the preorder traversal match_ `voyage`_, return the list_ `[1]`. **Example 1:** **Input:** root = [1,2], voyage = [2,1] **Output:** [1] **Explanation:** It is impossible to flip the nodes such that the preorder traversal matches voyage. **Example 2:** **Input:** root = [1,2,3], voyage = [1,3,2] **Output:** [1] **Explanation:** Flipping node 1 swaps nodes 2 and 3, so the preorder traversal matches voyage. **Example 3:** **Input:** root = [1,2,3], voyage = [1,2,3] **Output:** [] **Explanation:** The tree\'s preorder traversal already matches voyage, so no nodes need to be flipped. **Constraints:** * The number of nodes in the tree is `n`. * `n == voyage.length` * `1 <= n <= 100` * `1 <= Node.val, voyage[i] <= n` * All the values in the tree are **unique**. * All the values in `voyage` are **unique**.","completion":"from collections import deque def shortestBridge(grid): n = len(grid) q = deque() # Find the first island and mark it for i in range(n): if any(grid[i]): first_row = i first_col = grid[first_row].index(1) break dfs(grid, q, first_row, first_col) steps = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while q: for _ in range(len(q)): x, y = q.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: if grid[nx][ny] == 1: return steps elif grid[nx][ny] == 0: grid[nx][ny] = -1 q.append((nx, ny)) steps += 1 return -1 def dfs(grid, q, i, j): n = len(grid) if not (0 <= i < n and 0 <= j < n and grid[i][j] == 1): return grid[i][j] = -1 q.append((i, j)) dfs(grid, q, i - 1, j) dfs(grid, q, i + 1, j) dfs(grid, q, i, j - 1) dfs(grid, q, i, j + 1)"},{"prompt":"There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`. A path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k1`. The distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k1`. Return _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`. **Example 1:** **Input:** n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]] **Output:** 3 **Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are: 1) 1 > 2 > 5 2) 1 > 2 > 3 > 5 3) 1 > 3 > 5 **Example 2:** **Input:** n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]] **Output:** 1 **Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 > 3 > 7. **Constraints:** * `1 <= n <= 2 * 104` * `n 1 <= edges.length <= 4 * 104` * `edges[i].length == 3` * `1 <= ui, vi <= n` * `ui != vi` * `1 <= weighti <= 105` * There is at most one edge between any two nodes. * There is at least one path between any two nodes.","completion":"def count_consistent_strings(allowed, words): allowed_set = set(allowed) count = 0 for word in words: is_valid = True for c in word: if c not in allowed_set: is_valid = False break if is_valid: count += 1 return count"},{"prompt":"Given a binary string `s`, you can split `s` into 3 **nonempty** strings `s1`, `s2`, and `s3` where `s1 + s2 + s3 = s`. Return the number of ways `s` can be split such that the number of ones is the same in `s1`, `s2`, and `s3`. Since the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** **Input:** s = 10101 **Output:** 4 **Explanation:** There are four ways to split s in 3 parts where each part contain the same number of letters \'1\'. 1|010|1 1|01|01 10|10|1 10|1|01 **Example 2:** **Input:** s = 1001 **Output:** 0 **Example 3:** **Input:** s = 0000 **Output:** 3 **Explanation:** There are three ways to split s in 3 parts. 0|0|00 0|00|0 00|0|0 **Constraints:** * `3 <= s.length <= 105` * `s[i]` is either `\'0\'` or `\'1\'`.","completion":"def min_sum_of_lengths(arr, target): n = len(arr) sum_, min_len, result = 0, float(\'inf\'), float(\'inf\') mp = {0: -1} for i in range(n): sum_ += arr[i] if sum_ >= target and (sum_ - target) in mp: if mp[sum_ - target] > -1 and min_len != float(\'inf\'): result = min(result, i - mp[sum_ - target] + min_len) min_len = min(min_len, i - mp[sum_ - target]) mp[sum_] = i return result if result != float(\'inf\') else -1"},{"prompt":"There is an integer array `nums` that consists of `n` **unique** elements, but you have forgotten it. However, you do remember every pair of adjacent elements in `nums`. You are given a 2D integer array `adjacentPairs` of size `n 1` where each `adjacentPairs[i] = [ui, vi]` indicates that the elements `ui` and `vi` are adjacent in `nums`. It is guaranteed that every adjacent pair of elements `nums[i]` and `nums[i+1]` will exist in `adjacentPairs`, either as `[nums[i], nums[i+1]]` or `[nums[i+1], nums[i]]`. The pairs can appear **in any order**. Return _the original array_ `nums`_. If there are multiple solutions, return **any of them**_. **Example 1:** **Input:** adjacentPairs = [[2,1],[3,4],[3,2]] **Output:** [1,2,3,4] **Explanation:** This array has all its adjacent pairs in adjacentPairs. Notice that adjacentPairs[i] may not be in lefttoright order. **Example 2:** **Input:** adjacentPairs = [[4,2],[1,4],[3,1]] **Output:** [2,4,1,3] **Explanation:** There can be negative numbers. Another solution is [3,1,4,2], which would also be accepted. **Example 3:** **Input:** adjacentPairs = [[100000,100000]] **Output:** [100000,100000] **Constraints:** * `nums.length == n` * `adjacentPairs.length == n 1` * `adjacentPairs[i].length == 2` * `2 <= n <= 105` * `105 <= nums[i], ui, vi <= 105` * There exists some `nums` that has `adjacentPairs` as its pairs.","completion":"def count_substrings_with_one_difference(s, t): count = 0 for i in range(len(s)): for j in range(len(t)): differences = 0 k = 0 while i + k < len(s) and j + k < len(t): if s[i + k] != t[j + k]: differences += 1 if differences == 2: break if differences == 1: count += 1 k += 1 return count"},{"prompt":"Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings `words`. For example, if `words = [ abc , xyz ]` and the stream added the four characters (one by one) `\'a\'`, `\'x\'`, `\'y\'`, and `\'z\'`, your algorithm should detect that the suffix `xyz ` of the characters `axyz ` matches `xyz ` from `words`. Implement the `StreamChecker` class: * `StreamChecker(String[] words)` Initializes the object with the strings array `words`. * `boolean query(char letter)` Accepts a new character from the stream and returns `true` if any nonempty suffix from the stream forms a word that is in `words`. **Example 1:** **Input** [ StreamChecker , query , query , query , query , query , query , query , query , query , query , query , query ] [[[ cd , f , kl ]], [ a ], [ b ], [ c ], [ d ], [ e ], [ f ], [ g ], [ h ], [ i ], [ j ], [ k ], [ l ]] **Output** [null, false, false, false, true, false, true, false, false, false, false, false, true] **Explanation** StreamChecker streamChecker = new StreamChecker([ cd , f , kl ]); streamChecker.query( a ); // return False streamChecker.query( b ); // return False streamChecker.query( c ); // return False streamChecker.query( d ); // return True, because \'cd\' is in the wordlist streamChecker.query( e ); // return False streamChecker.query( f ); // return True, because \'f\' is in the wordlist streamChecker.query( g ); // return False streamChecker.query( h ); // return False streamChecker.query( i ); // return False streamChecker.query( j ); // return False streamChecker.query( k ); // return False streamChecker.query( l ); // return True, because \'kl\' is in the wordlist **Constraints:** * `1 <= words.length <= 2000` * `1 <= words[i].length <= 200` * `words[i]` consists of lowercase English letters. * `letter` is a lowercase English letter. * At most `4 * 104` calls will be made to query.","completion":"def equationsPossible(equations): parent = [i for i in range(26)] def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] for e in equations: if e[1] == \'=\': x = ord(e[0]) - ord(\'a\') y = ord(e[3]) - ord(\'a\') parent[find(x)] = find(y) for e in equations: if e[1] == \'!\' and find(ord(e[0]) - ord(\'a\')) == find(ord(e[3]) - ord(\'a\')): return False return True"},{"prompt":"A perfectly straight street is represented by a number line. The street has street lamp(s) on it and is represented by a 2D integer array `lights`. Each `lights[i] = [positioni, rangei]` indicates that there is a street lamp at position `positioni` that lights up the area from `[positioni rangei, positioni + rangei]` (**inclusive**). The **brightness** of a position `p` is defined as the number of street lamp that light up the position `p`. Given `lights`, return _the **brightest** position on the_ _street. If there are multiple brightest positions, return the **smallest** one._ **Example 1:** **Input:** lights = [[3,2],[1,2],[3,3]] **Output:** 1 **Explanation:** The first street lamp lights up the area from [(3) 2, (3) + 2] = [5, 1]. The second street lamp lights up the area from [1 2, 1 + 2] = [1, 3]. The third street lamp lights up the area from [3 3, 3 + 3] = [0, 6]. Position 1 has a brightness of 2, illuminated by the first and second street light. Positions 0, 1, 2, and 3 have a brightness of 2, illuminated by the second and third street light. Out of all these positions, 1 is the smallest, so return it. **Example 2:** **Input:** lights = [[1,0],[0,1]] **Output:** 1 **Explanation:** The first street lamp lights up the area from [1 0, 1 + 0] = [1, 1]. The second street lamp lights up the area from [0 1, 0 + 1] = [1, 1]. Position 1 has a brightness of 2, illuminated by the first and second street light. Return 1 because it is the brightest position on the street. **Example 3:** **Input:** lights = [[1,2]] **Output:** 1 **Explanation:** The first street lamp lights up the area from [1 2, 1 + 2] = [1, 3]. Positions 1, 0, 1, 2, and 3 have a brightness of 1, illuminated by the first street light. Out of all these positions, 1 is the smallest, so return it. **Constraints:** * `1 <= lights.length <= 105` * `lights[i].length == 2` * `108 <= positioni <= 108` * `0 <= rangei <= 108`","completion":"def remove_occurrences(s, part): while part in s: s = s.replace(part, \'\', 1) return s"},{"prompt":"You are given an undirected graph. You are given an integer `n` which is the number of nodes in the graph and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`. A **connected trio** is a set of **three** nodes where there is an edge between **every** pair of them. The **degree of a connected trio** is the number of edges where one endpoint is in the trio, and the other is not. Return _the **minimum** degree of a connected trio in the graph, or_ `1` _if the graph has no connected trios._ **Example 1:** **Input:** n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] **Output:** 3 **Explanation:** There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above. **Example 2:** **Input:** n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] **Output:** 0 **Explanation:** There are exactly three trios: 1) [1,4,3] with degree 0. 2) [2,5,6] with degree 2. 3) [5,6,7] with degree 2. **Constraints:** * `2 <= n <= 400` * `edges[i].length == 2` * `1 <= edges.length <= n * (n1) / 2` * `1 <= ui, vi <= n` * `ui != vi` * There are no repeated edges.","completion":"def count_vowel_strings(n): dp = [1, 1, 1, 1, 1] for i in range(1, n): for j in range(3, -1, -1): dp[j] += dp[j + 1] return sum(dp)"},{"prompt":"You are given an integer array `nums` of length `n` where `nums` is a permutation of the numbers in the range `[0, n 1]`. You should build a set `s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... }` subjected to the following rule: * The first element in `s[k]` starts with the selection of the element `nums[k]` of `index = k`. * The next element in `s[k]` should be `nums[nums[k]]`, and then `nums[nums[nums[k]]]`, and so on. * We stop adding right before a duplicate element occurs in `s[k]`. Return _the longest length of a set_ `s[k]`. **Example 1:** **Input:** nums = [5,4,0,3,1,6,2] **Output:** 4 **Explanation:** nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2. One of the longest sets s[k]: s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0} **Example 2:** **Input:** nums = [0,1,2] **Output:** 1 **Constraints:** * `1 <= nums.length <= 105` * `0 <= nums[i] < nums.length` * All the values of `nums` are **unique**.","completion":"def arrayNesting(nums): n = len(nums) max_len = 0 for i in range(n): if nums[i] != -1: start = nums[i] count = 0 while nums[start] != -1: temp = start start = nums[start] count += 1 nums[temp] = -1 max_len = max(max_len, count) return max_len"},{"prompt":"You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location. Two squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions. The **border of a connected component** is all the squares in the connected component that are either **4directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column). You should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`. Return _the final grid_. **Example 1:** **Input:** grid = [[1,1],[1,2]], row = 0, col = 0, color = 3 **Output:** [[3,3],[3,2]] **Example 2:** **Input:** grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3 **Output:** [[1,3,3],[2,3,3]] **Example 3:** **Input:** grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2 **Output:** [[2,2,2],[2,1,2],[2,2,2]] **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 50` * `1 <= grid[i][j], color <= 1000` * `0 <= row < m` * `0 <= col < n`","completion":"def good_subarrays(nums, k): count = 0 for i in range(len(nums)): frequency = {} for j in range(i, len(nums)): frequency[nums[j]] = frequency.get(nums[j], 0) + 1 if len(frequency) > k: break if len(frequency) == k: count += 1 return count"},{"prompt":"During the NBA playoffs, we always set the rather strong team to play with the rather weak team, like make the rank `1` team play with the rank `nth` team, which is a good strategy to make the contest more interesting. Given `n` teams, return _their final contest matches in the form of a string_. The `n` teams are labeled from `1` to `n`, which represents their initial rank (i.e., Rank `1` is the strongest team and Rank `n` is the weakest team). We will use parentheses `\'(\'`, and `\')\'` and commas `\',\'` to represent the contest team pairing. We use the parentheses for pairing and the commas for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. **Example 1:** **Input:** n = 4 **Output:** ((1,4),(2,3)) **Explanation:** In the first round, we pair the team 1 and 4, the teams 2 and 3 together, as we need to make the strong team and weak team together. And we got (1, 4),(2, 3). In the second round, the winners of (1, 4) and (2, 3) need to play again to generate the final winner, so you need to add the paratheses outside them. And we got the final answer ((1,4),(2,3)). **Example 2:** **Input:** n = 8 **Output:** (((1,8),(4,5)),((2,7),(3,6))) **Explanation:** First round: (1, 8),(2, 7),(3, 6),(4, 5) Second round: ((1, 8),(4, 5)),((2, 7),(3, 6)) Third round: (((1, 8),(4, 5)),((2, 7),(3, 6))) Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))). **Constraints:** * `n == 2x` where `x` in in the range `[1, 12]`.","completion":"def findContestMatch(n): matches = [str(i) for i in range(1, n + 1)] while n > 1: for i in range(n // 2): matches[i] = \\"(\\" + matches[i] + \\",\\" + matches[n - 1 - i] + \\")\\" n //= 2 return matches[0]"},{"prompt":"You are given an array `nums` consisting of **positive** integers. You have to take each integer in the array, **reverse its digits**, and add it to the end of the array. You should apply this operation to the original integers in `nums`. Return _the number of **distinct** integers in the final array_. **Example 1:** **Input:** nums = [1,13,10,12,31] **Output:** 6 **Explanation:** After including the reverse of each number, the resulting array is [1,13,10,12,31,1,31,1,21,13]. The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1. The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31). **Example 2:** **Input:** nums = [2,2,2] **Output:** 1 **Explanation:** After including the reverse of each number, the resulting array is [2,2,2,2,2,2]. The number of distinct integers in this array is 1 (The number 2). **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 106`","completion":"def distinct_integers_after_reversing_and_adding(nums): distinct = set(nums) for num in nums: reversed_num = int(str(num)[::-1]) distinct.add(reversed_num) return len(distinct)"},{"prompt":"You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times: * Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] 1` and **every** element equal to `nums[i] + 1`. Return _the **maximum number of points** you can earn by applying the above operation some number of times_. **Example 1:** **Input:** nums = [3,4,2] **Output:** 6 **Explanation:** You can perform the following operations: Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2]. Delete 2 to earn 2 points. nums = []. You earn a total of 6 points. **Example 2:** **Input:** nums = [2,2,3,3,3,4] **Output:** 9 **Explanation:** You can perform the following operations: Delete a 3 to earn 3 points. All 2\'s and 4\'s are also deleted. nums = [3,3]. Delete a 3 again to earn 3 points. nums = [3]. Delete a 3 once more to earn 3 points. nums = []. You earn a total of 9 points. **Constraints:** * `1 <= nums.length <= 2 * 104` * `1 <= nums[i] <= 104`","completion":"def max_points(nums): dp = [0] * 100001 max_points = 0 for num in nums: dp[num] += 1 for i in range(2, len(dp)): dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i]) max_points = max(max_points, dp[i]) return max_points"},{"prompt":"Given the array `restaurants` where `restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]`. You have to filter the restaurants using three filters. The `veganFriendly` filter will be either _true_ (meaning you should only include restaurants with `veganFriendlyi` set to true) or _false_ (meaning you can include any restaurant). In addition, you have the filters `maxPrice` and `maxDistance` which are the maximum value for price and distance of restaurants you should consider respectively. Return the array of restaurant _**IDs**_ after filtering, ordered by **rating** from highest to lowest. For restaurants with the same rating, order them by _**id**_ from highest to lowest. For simplicity `veganFriendlyi` and `veganFriendly` take value _1_ when it is _true_, and _0_ when it is _false_. **Example 1:** **Input:** restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10 **Output:** [3,1,5] **Explanation:** The restaurants are: Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10] Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5] Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4] Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3] Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] After filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). **Example 2:** **Input:** restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10 **Output:** [4,3,2,1,5] **Explanation:** The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered. **Example 3:** **Input:** restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3 **Output:** [4,5] **Constraints:** * `1 <= restaurants.length <= 10^4` * `restaurants[i].length == 5` * `1 <= idi, ratingi, pricei, distancei <= 10^5` * `1 <= maxPrice, maxDistance <= 10^5` * `veganFriendlyi` and `veganFriendly` are 0 or 1. * All `idi` are distinct.","completion":"def sort_based_on_mapping(mapping, nums): def mapped_value(num): return int(\'\'.join(str(mapping[int(d)]) for d in str(num))) return sorted(nums, key=mapped_value)"},{"prompt":"Given two integer arrays `nums1` and `nums2` of length `n`, count the pairs of indices `(i, j)` such that `i < j` and `nums1[i] + nums1[j] > nums2[i] + nums2[j]`. Return _the **number of pairs** satisfying the condition._ **Example 1:** **Input:** nums1 = [2,1,2,1], nums2 = [1,2,1,2] **Output:** 1 **Explanation**: The pairs satisfying the condition are: (0, 2) where 2 + 2 > 1 + 1. **Example 2:** **Input:** nums1 = [1,10,6,2], nums2 = [1,4,1,5] **Output:** 5 **Explanation**: The pairs satisfying the condition are: (0, 1) where 1 + 10 > 1 + 4. (0, 2) where 1 + 6 > 1 + 1. (1, 2) where 10 + 6 > 4 + 1. (1, 3) where 10 + 2 > 4 + 5. (2, 3) where 6 + 2 > 1 + 5. **Constraints:** * `n == nums1.length == nums2.length` * `1 <= n <= 105` * `1 <= nums1[i], nums2[i] <= 105`","completion":"def count_homogenous(s: str) -> int: res, count, mod = 0, 1, 10**9 + 7 for i in range(1, len(s)): count = count + 1 if s[i] == s[i - 1] else 1 res = (res + count) % mod return res"},{"prompt":"You are given a positive integer `n` representing the number of nodes of a **Directed Acyclic Graph** (DAG). The nodes are numbered from `0` to `n 1` (**inclusive**). You are also given a 2D integer array `edges`, where `edges[i] = [fromi, toi]` denotes that there is a **unidirectional** edge from `fromi` to `toi` in the graph. Return _a list_ `answer`_, where_ `answer[i]` _is the **list of ancestors** of the_ `ith` _node, sorted in **ascending order**_. A node `u` is an **ancestor** of another node `v` if `u` can reach `v` via a set of edges. **Example 1:** **Input:** n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]] **Output:** [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]] **Explanation:** The above diagram represents the input graph. Nodes 0, 1, and 2 do not have any ancestors. Node 3 has two ancestors 0 and 1. Node 4 has two ancestors 0 and 2. Node 5 has three ancestors 0, 1, and 3. Node 6 has five ancestors 0, 1, 2, 3, and 4. Node 7 has four ancestors 0, 1, 2, and 3. **Example 2:** **Input:** n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] **Output:** [[],[0],[0,1],[0,1,2],[0,1,2,3]] **Explanation:** The above diagram represents the input graph. Node 0 does not have any ancestor. Node 1 has one ancestor 0. Node 2 has two ancestors 0 and 1. Node 3 has three ancestors 0, 1, and 2. Node 4 has four ancestors 0, 1, 2, and 3. **Constraints:** * `1 <= n <= 1000` * `0 <= edges.length <= min(2000, n * (n 1) / 2)` * `edges[i].length == 2` * `0 <= fromi, toi <= n 1` * `fromi != toi` * There are no duplicate edges. * The graph is **directed** and **acyclic**.","completion":"def min_cost(grid, start_pos, home_pos, row_costs, col_costs): return abs(row_costs[start_pos[0]] - row_costs[home_pos[0]]) + abs(col_costs[start_pos[1]] - col_costs[home_pos[1]])"},{"prompt":"The **alternating sum** of a **0indexed** array is defined as the **sum** of the elements at **even** indices **minus** the **sum** of the elements at **odd** indices. * For example, the alternating sum of `[4,2,5,3]` is `(4 + 5) (2 + 3) = 4`. Given an array `nums`, return _the **maximum alternating sum** of any subsequence of_ `nums` _(after **reindexing** the elements of the subsequence)_. A **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements\' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not. **Example 1:** **Input:** nums = [4,2,5,3] **Output:** 7 **Explanation:** It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) 2 = 7. **Example 2:** **Input:** nums = [5,6,7,8] **Output:** 8 **Explanation:** It is optimal to choose the subsequence [8] with alternating sum 8. **Example 3:** **Input:** nums = [6,2,1,2,4,5] **Output:** 10 **Explanation:** It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) 1 = 10. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 105`","completion":"def min_elements(nums, limit, goal): total_sum = sum(nums) diff = abs(goal - total_sum) return (diff + limit - 1) // limit"},{"prompt":"You are given a **0indexed** integer array `nums` consisting of `3 * n` elements. You are allowed to remove any **subsequence** of elements of size **exactly** `n` from `nums`. The remaining `2 * n` elements will be divided into two **equal** parts: * The first `n` elements belonging to the first part and their sum is `sumfirst`. * The next `n` elements belonging to the second part and their sum is `sumsecond`. The **difference in sums** of the two parts is denoted as `sumfirst sumsecond`. * For example, if `sumfirst = 3` and `sumsecond = 2`, their difference is `1`. * Similarly, if `sumfirst = 2` and `sumsecond = 3`, their difference is `1`. Return _the **minimum difference** possible between the sums of the two parts after the removal of_ `n` _elements_. **Example 1:** **Input:** nums = [3,1,2] **Output:** 1 **Explanation:** Here, nums has 3 elements, so n = 1. Thus we have to remove 1 element from nums and divide the array into two equal parts. If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 2 = 1. If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 2 = 1. If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 1 = 2. The minimum difference between sums of the two parts is min(1,1,2) = 1. **Example 2:** **Input:** nums = [7,9,5,8,1,3] **Output:** 1 **Explanation:** Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each. If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) (1+3) = 12. To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) (8+3) = 1. It can be shown that it is not possible to obtain a difference smaller than 1. **Constraints:** * `nums.length == 3 * n` * `1 <= n <= 105` * `1 <= nums[i] <= 105`","completion":"def kth_distinct_string(arr, k): frequency = {} for s in arr: frequency[s] = frequency.get(s, 0) + 1 count = 0 for s in arr: if frequency[s] == 1: count += 1 if count == k: return s return \\"\\""},{"prompt":"There is a country of `n` cities numbered from `0` to `n 1`. In this country, there is a road connecting **every pair** of cities. There are `m` friends numbered from `0` to `m 1` who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city **more than once**, but the same city will not be listed consecutively. Given an integer `n` and a 2D integer array `paths` where `paths[i]` is an integer array representing the path of the `ith` friend, return _the length of the **longest common subpath** that is shared by **every** friend\'s path, or_ `0` _if there is no common subpath at all_. A **subpath** of a path is a contiguous sequence of cities within that path. **Example 1:** **Input:** n = 5, paths = [[0,1,2,3,4], [2,3,4], [4,0,1,2,3]] **Output:** 2 **Explanation:** The longest common subpath is [2,3]. **Example 2:** **Input:** n = 3, paths = [[0],[1],[2]] **Output:** 0 **Explanation:** There is no common subpath shared by the three paths. **Example 3:** **Input:** n = 5, paths = [[0,1,2,3,4], [4,3,2,1,0]] **Output:** 1 **Explanation:** The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1. **Constraints:** * `1 <= n <= 105` * `m == paths.length` * `2 <= m <= 105` * `sum(paths[i].length) <= 105` * `0 <= paths[i][j] < n` * The same city is not listed multiple times consecutively in `paths[i]`.","completion":"def are_sentences_similar(sentence1, sentence2): words1 = sentence1.split() words2 = sentence2.split() while words1 and words2 and words1[0] == words2[0]: words1.pop(0) words2.pop(0) while words1 and words2 and words1[-1] == words2[-1]: words1.pop() words2.pop() return not words1 or not words2"},{"prompt":"Given an array of integers `nums` and an integer `threshold`, we will choose a positive integer `divisor`, divide all the array by it, and sum the division\'s result. Find the **smallest** `divisor` such that the result mentioned above is less than or equal to `threshold`. Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: `7/3 = 3` and `10/2 = 5`). The test cases are generated so that there will be an answer. **Example 1:** **Input:** nums = [1,2,5,9], threshold = 6 **Output:** 5 **Explanation:** We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). **Example 2:** **Input:** nums = [44,22,33,11,1], threshold = 5 **Output:** 44 **Constraints:** * `1 <= nums.length <= 5 * 104` * `1 <= nums[i] <= 106` * `nums.length <= threshold <= 106`","completion":"def format_date(date): months = { \\"Jan\\": \\"01\\", \\"Feb\\": \\"02\\", \\"Mar\\": \\"03\\", \\"Apr\\": \\"04\\", \\"May\\": \\"05\\", \\"Jun\\": \\"06\\", \\"Jul\\": \\"07\\", \\"Aug\\": \\"08\\", \\"Sep\\": \\"09\\", \\"Oct\\": \\"10\\", \\"Nov\\": \\"11\\", \\"Dec\\": \\"12\\", } day, month, year = date.split() return f\\"{year}-{months[month]}-{day}\\""},{"prompt":"Given the `root` of a binary tree and a `leaf` node, reroot the tree so that the `leaf` is the new root. You can reroot the tree with the following steps for each node `cur` on the path **starting from the** `leaf` up to the `root`​​​ **excluding the root**: 1. If `cur` has a left child, then that child becomes `cur`\'s right child. 2. `cur`\'s original parent becomes `cur`\'s left child. Note that in this process the original parent\'s pointer to `cur` becomes `null`, making it have at most one child. Return _the new root_ _of the rerooted tree._ **Note:** Ensure that your solution sets the `Node.parent` pointers correctly after rerooting or you will receive Wrong Answer . **Example 1:** **Input:** root = [3,5,1,6,2,0,8,null,null,7,4], leaf = 7 **Output:** [7,2,null,5,4,3,6,null,null,null,1,null,null,0,8] **Example 2:** **Input:** root = [3,5,1,6,2,0,8,null,null,7,4], leaf = 0 **Output:** [0,1,null,3,8,5,null,null,null,6,2,null,null,7,4] **Constraints:** * The number of nodes in the tree is in the range `[2, 100]`. * `109 <= Node.val <= 109` * All `Node.val` are **unique**. * `leaf` exist in the tree.","completion":"def make_good(s: str) -> str: result = [] for c in s: if result and abs(ord(result[-1]) - ord(c)) == 32: result.pop() else: result.append(c) return \\"\\".join(result)"},{"prompt":"You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city. The monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute. You have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start. You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon. Return _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._ **Example 1:** **Input:** dist = [1,3,4], speed = [1,1,1] **Output:** 3 **Explanation:** In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster. After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster. After a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster. All 3 monsters can be eliminated. **Example 2:** **Input:** dist = [1,1,2,3], speed = [1,1,1,1] **Output:** 1 **Explanation:** In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster. After a minute, the distances of the monsters are [X,0,1,2], so you lose. You can only eliminate 1 monster. **Example 3:** **Input:** dist = [3,2,4], speed = [5,3,2] **Output:** 1 **Explanation:** In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster. After a minute, the distances of the monsters are [X,0,2], so you lose. You can only eliminate 1 monster. **Constraints:** * `n == dist.length == speed.length` * `1 <= n <= 105` * `1 <= dist[i], speed[i] <= 105`","completion":"def eliminate_maximum(dist, speed): n = len(dist) time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)] time_to_reach_city.sort() eliminated = 0 for i in range(n): if time_to_reach_city[i] > i: eliminated += 1 else: break return eliminated"},{"prompt":"There are `k` workers who want to move `n` boxes from an old warehouse to a new one. You are given the two integers `n` and `k`, and a 2D integer array `time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]`. The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all `k` workers are waiting on the left side of the bridge. To move the boxes, the `ith` worker (**0indexed**) can : * Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes. * Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously. * Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes. * Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously. A worker `i` is **less efficient** than a worker `j` if either condition is met: * `leftToRighti + rightToLefti > leftToRightj + rightToLeftj` * `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j` The following rules regulate the movement of the workers through the bridge : * If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge. * If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with **the lowest efficiency** crosses first. * If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with **the lowest efficiency** crosses first. Return _the instance of time at which the last worker **reaches the left bank** of the river after all n boxes have been put in the new warehouse_. **Example 1:** **Input:** n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]] **Output:** 6 **Explanation:** From 0 to 1: worker 2 crosses the bridge from the left bank to the right bank. From 1 to 2: worker 2 picks up a box from the old warehouse. From 2 to 6: worker 2 crosses the bridge from the right bank to the left bank. From 6 to 7: worker 2 puts a box at the new warehouse. The whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank. **Example 2:** **Input:** n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]] **Output:** 50 **Explanation:** From 0 to 10: worker 1 crosses the bridge from the left bank to the right bank. From 10 to 20: worker 1 picks up a box from the old warehouse. From 10 to 11: worker 0 crosses the bridge from the left bank to the right bank. From 11 to 20: worker 0 picks up a box from the old warehouse. From 20 to 30: worker 1 crosses the bridge from the right bank to the left bank. From 30 to 40: worker 1 puts a box at the new warehouse. From 30 to 31: worker 0 crosses the bridge from the right bank to the left bank. From 31 to 39: worker 0 puts a box at the new warehouse. From 39 to 40: worker 0 crosses the bridge from the left bank to the right bank. From 40 to 49: worker 0 picks up a box from the old warehouse. From 49 to 50: worker 0 crosses the bridge from the right bank to the left bank. From 50 to 58: worker 0 puts a box at the new warehouse. The whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank. **Constraints:** * `1 <= n, k <= 104` * `time.length == k` * `time[i].length == 4` * `1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000`","completion":"from heapq import heappush, heappop def getLastMoment(n, k, time): left = [(time[j][0] + time[j][2], j) for j in range(k)] right = [] while n: while right and right[0][0] <= left[0][0]: right_top = heappop(right) heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1])) left_top = heappop(left) time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1] heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1])) n -= 1 lastMoment = -1 while right: right_top = heappop(right) lastMoment = max(lastMoment, time[right_top[1]][2]) return lastMoment"},{"prompt":"Given 3 positives numbers `a`, `b` and `c`. Return the minimum flips required in some bits of `a` and `b` to make ( `a` OR `b` == `c` ). (bitwise OR operation). Flip operation consists of change **any** single bit 1 to 0 or change the bit 0 to 1 in their binary representation. **Example 1:** **Input:** a = 2, b = 6, c = 5 **Output:** 3 **Explanation:** After flips a = 1 , b = 4 , c = 5 such that (`a` OR `b` == `c`) **Example 2:** **Input:** a = 4, b = 2, c = 7 **Output:** 1 **Example 3:** **Input:** a = 1, b = 2, c = 3 **Output:** 0 **Constraints:** * `1 <= a <= 10^9` * `1 <= b <= 10^9` * `1 <= c <= 10^9`","completion":"def minFlips(a: int, b: int, c: int) -> int: count = 0 for i in range(32): bitA = (a >> i) & 1 bitB = (b >> i) & 1 bitC = (c >> i) & 1 if bitC == 0: count += bitA + bitB else: count += 1 - (bitA | bitB) return count"},{"prompt":"Given a list of `dominoes`, `dominoes[i] = [a, b]` is **equivalent to** `dominoes[j] = [c, d]` if and only if either (`a == c` and `b == d`), or (`a == d` and `b == c`) that is, one domino can be rotated to be equal to another domino. Return _the number of pairs_ `(i, j)` _for which_ `0 <= i < j < dominoes.length`_, and_ `dominoes[i]` _is **equivalent to**_ `dominoes[j]`. **Example 1:** **Input:** dominoes = [[1,2],[2,1],[3,4],[5,6]] **Output:** 1 **Example 2:** **Input:** dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]] **Output:** 3 **Constraints:** * `1 <= dominoes.length <= 4 * 104` * `dominoes[i].length == 2` * `1 <= dominoes[i][j] <= 9`","completion":"def remove_duplicates(s: str) -> str: stack = [] for c in s: if stack and stack[-1] == c: stack.pop() else: stack.append(c) return \\"\\".join(stack)"},{"prompt":"You have a **1indexed** binary string of length `n` where all the bits are `0` initially. We will flip all the bits of this binary string (i.e., change them from `0` to `1`) one by one. You are given a **1indexed** integer array `flips` where `flips[i]` indicates that the bit at index `i` will be flipped in the `ith` step. A binary string is **prefixaligned** if, after the `ith` step, all the bits in the **inclusive** range `[1, i]` are ones and all the other bits are zeros. Return _the number of times the binary string is **prefixaligned** during the flipping process_. **Example 1:** **Input:** flips = [3,2,4,1,5] **Output:** 2 **Explanation:** The binary string is initially 00000 . After applying step 1: The string becomes 00100 , which is not prefixaligned. After applying step 2: The string becomes 01100 , which is not prefixaligned. After applying step 3: The string becomes 01110 , which is not prefixaligned. After applying step 4: The string becomes 11110 , which is prefixaligned. After applying step 5: The string becomes 11111 , which is prefixaligned. We can see that the string was prefixaligned 2 times, so we return 2. **Example 2:** **Input:** flips = [4,1,2,3] **Output:** 1 **Explanation:** The binary string is initially 0000 . After applying step 1: The string becomes 0001 , which is not prefixaligned. After applying step 2: The string becomes 1001 , which is not prefixaligned. After applying step 3: The string becomes 1101 , which is not prefixaligned. After applying step 4: The string becomes 1111 , which is prefixaligned. We can see that the string was prefixaligned 1 time, so we return 1. **Constraints:** * `n == flips.length` * `1 <= n <= 5 * 104` * `flips` is a permutation of the integers in the range `[1, n]`.","completion":"def find_kth_palindrome(k, int_length): mid = (int_length + 1) // 2 limit = 10 ** mid - 1 i = 0 while i <= limit: num = str(i) rev = num[::-1] if int_length % 2 != 0: rev = rev[1:] palindrome = int(num + rev) if palindrome > 0: k -= 1 if k == 0: return palindrome i += 1 return -1 def palindrome_queries(queries, int_length): return [find_kth_palindrome(query, int_length) for query in queries]"},{"prompt":"Given two strings `s` and `t`, transform string `s` into string `t` using the following operation any number of times: * Choose a **nonempty** substring in `s` and sort it in place so the characters are in **ascending order**. * For example, applying the operation on the underlined substring in `14234 ` results in `12344 `. Return `true` if _it is possible to transform `s` into `t`_. Otherwise, return `false`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** **Input:** s = 84532 , t = 34852 **Output:** true **Explanation:** You can transform s into t using the following sort operations: 84532 (from index 2 to 3) > 84352 84352 (from index 0 to 2) > 34852 **Example 2:** **Input:** s = 34521 , t = 23415 **Output:** true **Explanation:** You can transform s into t using the following sort operations: 34521 > 23451 23451 > 23415 **Example 3:** **Input:** s = 12345 , t = 12435 **Output:** false **Constraints:** * `s.length == t.length` * `1 <= s.length <= 105` * `s` and `t` consist of only digits.","completion":"def kth_factor(n: int, k: int) -> int: for i in range(1, n+1): if n % i == 0: k -= 1 if k == 0: return i return -1"},{"prompt":"You are given an integer `n` and an integer `start`. Define an array `nums` where `nums[i] = start + 2 * i` (**0indexed**) and `n == nums.length`. Return _the bitwise XOR of all elements of_ `nums`. **Example 1:** **Input:** n = 5, start = 0 **Output:** 8 **Explanation:** Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8. Where ^ corresponds to bitwise XOR operator. **Example 2:** **Input:** n = 4, start = 3 **Output:** 8 **Explanation:** Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8. **Constraints:** * `1 <= n <= 1000` * `0 <= start <= 1000` * `n == nums.length`","completion":"def findTheDistanceValue(arr1, arr2, d): count = 0 for i in arr1: valid = True for j in arr2: if abs(i - j) <= d: valid = False break if valid: count += 1 return count"},{"prompt":"There is an undirected connected tree with `n` nodes labeled from `0` to `n 1` and `n 1` edges. You are given a **0indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. Remove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined: 1. Get the XOR of all the values of the nodes for **each** of the three components respectively. 2. The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair. * For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 3 = 5`. Return _the **minimum** score of any possible pair of edge removals on the given tree_. **Example 1:** **Input:** nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]] **Output:** 9 **Explanation:** The diagram above shows a way to make a pair of removals. The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10. The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1. The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5. The score is the difference between the largest and smallest XOR value which is 10 1 = 9. It can be shown that no other pair of removals will obtain a smaller score than 9. **Example 2:** **Input:** nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]] **Output:** 0 **Explanation:** The diagram above shows a way to make a pair of removals. The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0. The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0. The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0. The score is the difference between the largest and smallest XOR value which is 0 0 = 0. We cannot obtain a smaller score than 0. **Constraints:** * `n == nums.length` * `3 <= n <= 1000` * `1 <= nums[i] <= 108` * `edges.length == n 1` * `edges[i].length == 2` * `0 <= ai, bi < n` * `ai != bi` * `edges` represents a valid tree.","completion":"def dfs(node, parent, xor_values, tree): xor_value = xor_values[node] for child in tree[node]: if child != parent: xor_value ^= dfs(child, node, xor_values, tree) return xor_value def minimumScore(nums, edges): n = len(nums) tree = [[] for _ in range(n)] for edge in edges: tree[edge[0]].append(edge[1]) tree[edge[1]].append(edge[0]) xor_values = [dfs(i, -1, nums, tree) for i in range(n)] ans = float(\'inf\') for i in range(n): for j in range(i + 1, n): xor1 = xor_values[i] xor2 = xor_values[j] ^ nums[i] xor3 = nums[i] ^ nums[j] max_xor = max(xor1, xor2, xor3) min_xor = min(xor1, xor2, xor3) ans = min(ans, max_xor - min_xor) return ans"},{"prompt":"You are given a **0indexed** integer array `nums` and an integer `k`. You are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n 1, i + k)]` **inclusive**. You want to reach the last index of the array (index `n 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array. Return _the **maximum score** you can get_. **Example 1:** **Input:** nums = [1,1,2,4,7,3], k = 2 **Output:** 7 **Explanation:** You can choose your jumps forming the subsequence [1,1,4,3] (underlined above). The sum is 7. **Example 2:** **Input:** nums = [10,5,2,4,0,3], k = 3 **Output:** 17 **Explanation:** You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17. **Example 3:** **Input:** nums = [1,5,20,4,1,3,6,3], k = 2 **Output:** 0 **Constraints:** * `1 <= nums.length, k <= 105` * `104 <= nums[i] <= 104`","completion":"def isPrintable(targetGrid): m, n = len(targetGrid), len(targetGrid[0]) top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61 vis = [[False]*n for _ in range(m)] for i in range(m): for j in range(n): c = targetGrid[i][j] top[c] = min(top[c], i) bottom[c] = max(bottom[c], i) left[c] = min(left[c], j) right[c] = max(right[c], j) def dfs(x): i, j = x // n, x % n if vis[i][j]: return True c = targetGrid[i][j] if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False vis[i][j] = True for k in range(1, 61): if k == c: continue if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False return True for color in range(1, 61): for i in range(top[color], bottom[color] + 1): for j in range(left[color], right[color] + 1): if not vis[i][j] and not dfs(i * n + j): return False return True"},{"prompt":"Given an integer `n`, return _a binary string representing its representation in base_ `2`. **Note** that the returned string should not have leading zeros unless the string is `0 `. **Example 1:** **Input:** n = 2 **Output:** 110 **Explantion:** (2)2 + (2)1 = 2 **Example 2:** **Input:** n = 3 **Output:** 111 **Explantion:** (2)2 + (2)1 + (2)0 = 3 **Example 3:** **Input:** n = 4 **Output:** 100 **Explantion:** (2)2 = 4 **Constraints:** * `0 <= n <= 109`","completion":"def odd_even_jumps(arr): n = len(arr) can_reach_odd = [False] * n can_reach_even = [False] * n can_reach_odd[-1] = can_reach_even[-1] = True index_map = {} index_map[arr[-1]] = n - 1 good_indices = 1 for i in range(n - 2, -1, -1): odd_jump = next(iter([value for value in index_map if value >= arr[i]]), None) even_jump = next(iter([value for value in index_map if value <= arr[i]]), None) if odd_jump is not None: can_reach_odd[i] = can_reach_even[index_map[odd_jump]] if even_jump is not None: can_reach_even[i] = can_reach_odd[index_map[even_jump]] if can_reach_odd[i]: good_indices += 1 index_map[arr[i]] = i return good_indices"},{"prompt":"There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`. You will start on the `1st` day and you cannot take two or more courses simultaneously. Return _the maximum number of courses that you can take_. **Example 1:** **Input:** courses = [[100,200],[200,1300],[1000,1250],[2000,3200]] **Output:** 3 Explanation: There are totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date. **Example 2:** **Input:** courses = [[1,2]] **Output:** 1 **Example 3:** **Input:** courses = [[3,2],[4,3]] **Output:** 0 **Constraints:** * `1 <= courses.length <= 104` * `1 <= durationi, lastDayi <= 104`","completion":"import heapq def scheduleCourse(courses): courses.sort(key=lambda x: x[1]) curr_time, duration_sum = 0, [] for duration, deadline in courses: curr_time += duration heapq.heappush(duration_sum, -duration) if curr_time > deadline: curr_time += heapq.heappop(duration_sum) return len(duration_sum)"},{"prompt":"There are `n` people standing in a queue, and they numbered from `0` to `n 1` in **left to right** order. You are given an array `heights` of **distinct** integers where `heights[i]` represents the height of the `ith` person. A person can **see** another person to their right in the queue if everybody in between is **shorter** than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j1])`. Return _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the **number of people** the_ `ith` _person can **see** to their right in the queue_. **Example 1:** **Input:** heights = [10,6,8,5,11,9] **Output:** [3,1,2,1,1,0] **Explanation:** Person 0 can see person 1, 2, and 4. Person 1 can see person 2. Person 2 can see person 3 and 4. Person 3 can see person 4. Person 4 can see person 5. Person 5 can see no one since nobody is to the right of them. **Example 2:** **Input:** heights = [5,1,2,3,10] **Output:** [4,1,1,1,0] **Constraints:** * `n == heights.length` * `1 <= n <= 105` * `1 <= heights[i] <= 105` * All the values of `heights` are **unique**.","completion":"def truncate_sentence(s, k): words = s.split(\' \') return \' \'.join(words[:k])"},{"prompt":"Given a positive integer `n`, there exists a **0indexed** array called `powers`, composed of the **minimum** number of powers of `2` that sum to `n`. The array is sorted in **nondecreasing** order, and there is **only one** way to form the array. You are also given a **0indexed** 2D integer array `queries`, where `queries[i] = [lefti, righti]`. Each `queries[i]` represents a query where you have to find the product of all `powers[j]` with `lefti <= j <= righti`. Return _an array_ `answers`_, equal in length to_ `queries`_, where_ `answers[i]` _is the answer to the_ `ith` _query_. Since the answer to the `ith` query may be too large, each `answers[i]` should be returned **modulo** `109 + 7`. **Example 1:** **Input:** n = 15, queries = [[0,1],[2,2],[0,3]] **Output:** [2,4,64] **Explanation:** For n = 15, powers = [1,2,4,8]. It can be shown that powers cannot be a smaller size. Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2. Answer to 2nd query: powers[2] = 4. Answer to 3rd query: powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64. Each answer modulo 109 + 7 yields the same answer, so [2,4,64] is returned. **Example 2:** **Input:** n = 2, queries = [[0,0]] **Output:** [2] **Explanation:** For n = 2, powers = [2]. The answer to the only query is powers[0] = 2. The answer modulo 109 + 7 is the same, so [2] is returned. **Constraints:** * `1 <= n <= 109` * `1 <= queries.length <= 105` * `0 <= starti <= endi < powers.length`","completion":"def getPowers(n): powers = [] while n > 0: powers.append(n & (-n)) n -= n & (-n) return powers def productOfPowers(n, queries): powers = getPowers(n) answers = [] mod = 10**9 + 7 for query in queries: product = 1 for i in range(query[0], query[1] + 1): product = (product * powers[i]) % mod answers.append(product) return answers"},{"prompt":"You have a chat log of `n` messages. You are given two string arrays `messages` and `senders` where `messages[i]` is a **message** sent by `senders[i]`. A **message** is list of **words** that are separated by a single space with no leading or trailing spaces. The **word count** of a sender is the total number of **words** sent by the sender. Note that a sender may send more than one message. Return _the sender with the **largest** word count_. If there is more than one sender with the largest word count, return _the one with the **lexicographically largest** name_. **Note:** * Uppercase letters come before lowercase letters in lexicographical order. * `Alice ` and `alice ` are distinct. **Example 1:** **Input:** messages = [ Hello userTwooo , Hi userThree , Wonderful day Alice , Nice day userThree ], senders = [ Alice , userTwo , userThree , Alice ] **Output:** Alice **Explanation:** Alice sends a total of 2 + 3 = 5 words. userTwo sends a total of 2 words. userThree sends a total of 3 words. Since Alice has the largest word count, we return Alice . **Example 2:** **Input:** messages = [ How is leetcode for everyone , Leetcode is useful for practice ], senders = [ Bob , Charlie ] **Output:** Charlie **Explanation:** Bob sends a total of 5 words. Charlie sends a total of 5 words. Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie. **Constraints:** * `n == messages.length == senders.length` * `1 <= n <= 104` * `1 <= messages[i].length <= 100` * `1 <= senders[i].length <= 10` * `messages[i]` consists of uppercase and lowercase English letters and `\' \'`. * All the words in `messages[i]` are separated by **a single space**. * `messages[i]` does not have leading or trailing spaces. * `senders[i]` consists of uppercase and lowercase English letters only.","completion":"def rearrange_digits(num): if num == 0: return 0 digits = sorted(str(num)) if digits[0] != \'-\' and digits[0] == \'0\': nonzero_index = next(index for index, digit in enumerate(digits) if digit != \'0\') digits[0], digits[nonzero_index] = digits[nonzero_index], digits[0] return int(\\"\\".join(digits))"},{"prompt":"We are given `hours`, a list of the number of hours worked per day for a given employee. A day is considered to be a _tiring day_ if and only if the number of hours worked is (strictly) greater than `8`. A _wellperforming interval_ is an interval of days for which the number of tiring days is strictly larger than the number of nontiring days. Return the length of the longest wellperforming interval. **Example 1:** **Input:** hours = [9,9,6,0,6,6,9] **Output:** 3 **Explanation:** The longest wellperforming interval is [9,9,6]. **Example 2:** **Input:** hours = [6,6,6] **Output:** 0 **Constraints:** * `1 <= hours.length <= 104` * `0 <= hours[i] <= 16`","completion":"def longestWellPerformingInterval(hours): sum = 0 longest = 0 first_sum_index = {} for i, hour in enumerate(hours): sum += 1 if hour > 8 else -1 if sum > 0: longest = i + 1 else: if sum - 1 in first_sum_index: longest = max(longest, i - first_sum_index[sum - 1]) if sum not in first_sum_index: first_sum_index[sum] = i return longest"},{"prompt":"There is a **1based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively. Initially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `rith` row and `cith` column (**1based** coordinates) will be covered with **water** (i.e., changed to `1`). You want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the **four** cardinal directions (left, right, up, and down). Return _the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells_. **Example 1:** **Input:** row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]] **Output:** 2 **Explanation:** The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 2. **Example 2:** **Input:** row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]] **Output:** 1 **Explanation:** The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 1. **Example 3:** **Input:** row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]] **Output:** 3 **Explanation:** The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 3. **Constraints:** * `2 <= row, col <= 2 * 104` * `4 <= row * col <= 2 * 104` * `cells.length == row * col` * `1 <= ri <= row` * `1 <= ci <= col` * All the values of `cells` are **unique**.","completion":"def sort_sentence(s: str) -> str: tokens = s.split() words = [\'\'] * len(tokens) for token in tokens: pos = int(token[-1]) - 1 words[pos] = token[:-1] return \' \'.join(words)"},{"prompt":"You are given a nonnegative integer array `nums`. In one operation, you must: * Choose a positive integer `x` such that `x` is less than or equal to the **smallest nonzero** element in `nums`. * Subtract `x` from every **positive** element in `nums`. Return _the **minimum** number of operations to make every element in_ `nums` _equal to_ `0`. **Example 1:** **Input:** nums = [1,5,0,3,5] **Output:** 3 **Explanation:** In the first operation, choose x = 1. Now, nums = [0,4,0,2,4]. In the second operation, choose x = 2. Now, nums = [0,2,0,0,2]. In the third operation, choose x = 2. Now, nums = [0,0,0,0,0]. **Example 2:** **Input:** nums = [0] **Output:** 0 **Explanation:** Each element in nums is already 0 so no operations are needed. **Constraints:** * `1 <= nums.length <= 100` * `0 <= nums[i] <= 100`","completion":"def minOperations(nums): count = 0 nums.sort() i = 0 while i < len(nums): if nums[i] > 0: target = nums[i] while i < len(nums) and nums[i] == target: i += 1 count += 1 else: i += 1 return count"},{"prompt":"Given two strings `s1` and `s2`, return _the lowest **ASCII** sum of deleted characters to make two strings equal_. **Example 1:** **Input:** s1 = sea , s2 = eat **Output:** 231 **Explanation:** Deleting s from sea adds the ASCII value of s (115) to the sum. Deleting t from eat adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this. **Example 2:** **Input:** s1 = delete , s2 = leet **Output:** 403 **Explanation:** Deleting dee from delete to turn the string into let , adds 100[d] + 101[e] + 101[e] to the sum. Deleting e from leet adds 101[e] to the sum. At the end, both strings are equal to let , and the answer is 100+101+101+101 = 403. If instead we turned both strings into lee or eet , we would get answers of 433 or 417, which are higher. **Constraints:** * `1 <= s1.length, s2.length <= 1000` * `s1` and `s2` consist of lowercase English letters.","completion":"def minimumDeleteSum(s1: str, s2: str) -> int: dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)] for i in range(1, len(s1) + 1): dp[i][0] = dp[i - 1][0] + ord(s1[i - 1]) for j in range(1, len(s2) + 1): dp[0][j] = dp[0][j - 1] + ord(s2[j - 1]) for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1])) return dp[len(s1)][len(s2)]"},{"prompt":"There are `n` uniquelysized sticks whose lengths are integers from `1` to `n`. You want to arrange the sticks such that **exactly** `k` sticks are **visible** from the left. A stick is **visible** from the left if there are no **longer** sticks to the **left** of it. * For example, if the sticks are arranged `[1,3,2,5,4]`, then the sticks with lengths `1`, `3`, and `5` are visible from the left. Given `n` and `k`, return _the **number** of such arrangements_. Since the answer may be large, return it **modulo** `109 + 7`. **Example 1:** **Input:** n = 3, k = 2 **Output:** 3 **Explanation:** [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible. The visible sticks are underlined. **Example 2:** **Input:** n = 5, k = 5 **Output:** 1 **Explanation:** [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible. The visible sticks are underlined. **Example 3:** **Input:** n = 20, k = 11 **Output:** 647427950 **Explanation:** There are 647427950 (mod 109 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible. **Constraints:** * `1 <= n <= 1000` * `1 <= k <= n`","completion":"from collections import defaultdict def restoreArray(adjacentPairs): graph = defaultdict(list) for pair in adjacentPairs: graph[pair[0]].append(pair[1]) graph[pair[1]].append(pair[0]) n = len(graph) nums = [0] * n for key, nodes in graph.items(): if len(nodes) == 1: nums[0] = key break nums[1] = graph[nums[0]][0] for i in range(2, n): nums[i] = (graph[nums[i - 1]][1] if (nums[i - 2] == graph[nums[i - 1]][0]) else graph[nums[i - 1]][0]) return nums"},{"prompt":"You are given a string `number` representing a **positive integer** and a character `digit`. Return _the resulting string after removing **exactly one occurrence** of_ `digit` _from_ `number` _such that the value of the resulting string in **decimal** form is **maximized**_. The test cases are generated such that `digit` occurs at least once in `number`. **Example 1:** **Input:** number = 123 , digit = 3 **Output:** 12 **Explanation:** There is only one \'3\' in 123 . After removing \'3\', the result is 12 . **Example 2:** **Input:** number = 1231 , digit = 1 **Output:** 231 **Explanation:** We can remove the first \'1\' to get 231 or remove the second \'1\' to get 123 . Since 231 > 123, we return 231 . **Example 3:** **Input:** number = 551 , digit = 5 **Output:** 51 **Explanation:** We can remove either the first or second \'5\' from 551 . Both result in the string 51 . **Constraints:** * `2 <= number.length <= 100` * `number` consists of digits from `\'1\'` to `\'9\'`. * `digit` is a digit from `\'1\'` to `\'9\'`. * `digit` occurs at least once in `number`.","completion":"def max_number_after_remove_digit(number: str, digit: str) -> str: index = number.find(digit) return number[:index] + number[index + 1:]"},{"prompt":"There is a group of `n` people labeled from `0` to `n 1` where each person has a different amount of money and a different level of quietness. You are given an array `richer` where `richer[i] = [ai, bi]` indicates that `ai` has more money than `bi` and an integer array `quiet` where `quiet[i]` is the quietness of the `ith` person. All the given data in richer are **logically correct** (i.e., the data will not lead you to a situation where `x` is richer than `y` and `y` is richer than `x` at the same time). Return _an integer array_ `answer` _where_ `answer[x] = y` _if_ `y` _is the least quiet person (that is, the person_ `y` _with the smallest value of_ `quiet[y]`_) among all people who definitely have equal to or more money than the person_ `x`. **Example 1:** **Input:** richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] **Output:** [5,5,2,5,4,5,6,7] **Explanation:** answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0. answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7. The other answers can be filled out with similar reasoning. **Example 2:** **Input:** richer = [], quiet = [0] **Output:** [0] **Constraints:** * `n == quiet.length` * `1 <= n <= 500` * `0 <= quiet[i] < n` * All the values of `quiet` are **unique**. * `0 <= richer.length <= n * (n 1) / 2` * `0 <= ai, bi < n` * `ai != bi` * All the pairs of `richer` are **unique**. * The observations in `richer` are all logically consistent.","completion":"def to_goat_latin(sentence: str) -> str: words = sentence.split() vowels = set(\\"AEIOUaeiou\\") result = [] for i, word in enumerate(words): if word[0] not in vowels: word = word[1:] + word[0] result.append(word + \\"ma\\" + \\"a\\" * (i + 1)) return \' \'.join(result)"},{"prompt":"Given an array of integers `arr`. We want to select three indices `i`, `j` and `k` where `(0 <= i < j <= k < arr.length)`. Let\'s define `a` and `b` as follows: * `a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j 1]` * `b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]` Note that **^** denotes the **bitwisexor** operation. Return _the number of triplets_ (`i`, `j` and `k`) Where `a == b`. **Example 1:** **Input:** arr = [2,3,1,6,7] **Output:** 4 **Explanation:** The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4) **Example 2:** **Input:** arr = [1,1,1,1,1] **Output:** 10 **Constraints:** * `1 <= arr.length <= 300` * `1 <= arr[i] <= 108`","completion":"def make_connected(n, connections): adj_list = [[] for _ in range(n)] visited = [False] * n components = 0 extra_edges = 0 for a, b in connections: adj_list[a].append(b) adj_list[b].append(a) for i in range(n): if not visited[i]: components += 1 stack = [i] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) else: extra_edges += 1 extra_needed = components - 1 if extra_edges >= extra_needed: return extra_needed return -1"},{"prompt":"A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls. The world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4directionally** adjacent cells, on the shared boundary. Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**. Return _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used. **Example 1:** **Input:** isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]] **Output:** 10 **Explanation:** There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is: On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained. **Example 2:** **Input:** isInfected = [[1,1,1],[1,0,1],[1,1,1]] **Output:** 4 **Explanation:** Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells. **Example 3:** **Input:** isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]] **Output:** 13 **Explanation:** The region on the left only builds two new walls. **Constraints:** * `m == isInfected.length` * `n == isInfected[i].length` * `1 <= m, n <= 50` * `isInfected[i][j]` is either `0` or `1`. * There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.","completion":"def shortest_completing_word(license_plate, words): target = [0] * 26 for c in license_plate: if c.isalpha(): target[ord(c.lower()) - ord(\'a\')] += 1 result = \\"\\" for word in words: current = [0] * 26 for c in word: if c.isalpha(): current[ord(c.lower()) - ord(\'a\')] += 1 if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)): result = word return result"},{"prompt":"You are given two positive integers `left` and `right` with `left <= right`. Calculate the **product** of all integers in the **inclusive** range `[left, right]`. Since the product may be very large, you will **abbreviate** it following these steps: 1. Count all **trailing** zeros in the product and **remove** them. Let us denote this count as `C`. * For example, there are `3` trailing zeros in `1000`, and there are `0` trailing zeros in `546`. 2. Denote the remaining number of digits in the product as `d`. If `d > 10`, then express the product as ... 3. Finally, represent the product as a **string** `` ...eC Return _a string denoting the **abbreviated product** of all integers in the **inclusive** range_ `[left, right]`. **Example 1:** **Input:** left = 1, right = 4 **Output:** 24e0 **Explanation:** The product is 1 * 2 * 3 * 4 = 24. There are no trailing zeros, so 24 remains the same. The abbreviation will end with e0 . Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further. Thus, the final representation is 24e0 . **Example 2:** **Input:** left = 2, right = 11 **Output:** 399168e2 **Explanation:** The product is 39916800. There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with e2 . The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further. Hence, the abbreviated product is 399168e2 . **Example 3:** **Input:** left = 371, right = 375 **Output:** 7219856259e3 **Explanation:** The product is 7219856259000. **Constraints:** * `1 <= left <= right <= 104`","completion":"def findOriginalArray(changed): count = {} for num in changed: count[num] = count.get(num, 0) + 1 sorted_values = sorted(count.keys()) original = [] for num in sorted_values: while count[num] > 0 and count.get(num * 2, 0) > 0: original.append(num) count[num] -= 1 count[num * 2] -= 1 if count[num] > 0: return [] return original"},{"prompt":"Alice and Bob have a different total number of candies. You are given two integer arrays `aliceSizes` and `bobSizes` where `aliceSizes[i]` is the number of candies of the `ith` box of candy that Alice has and `bobSizes[j]` is the number of candies of the `jth` box of candy that Bob has. Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have. Return a_n integer array_ `answer` _where_ `answer[0]` _is the number of candies in the box that Alice must exchange, and_ `answer[1]` _is the number of candies in the box that Bob must exchange_. If there are multiple answers, you may **return any** one of them. It is guaranteed that at least one answer exists. **Example 1:** **Input:** aliceSizes = [1,1], bobSizes = [2,2] **Output:** [1,2] **Example 2:** **Input:** aliceSizes = [1,2], bobSizes = [2,3] **Output:** [1,2] **Example 3:** **Input:** aliceSizes = [2], bobSizes = [1,3] **Output:** [2,3] **Constraints:** * `1 <= aliceSizes.length, bobSizes.length <= 104` * `1 <= aliceSizes[i], bobSizes[j] <= 105` * Alice and Bob have a different total number of candies. * There will be at least one valid answer for the given input.","completion":"def mirrorReflection(p, q): from math import gcd m = p // gcd(p, q) if m % 2 == 0: return 2 if (q // gcd(p, q)) % 2 == 0: return 0 return 1"},{"prompt":"A string is a _valid parentheses string_ (denoted VPS) if and only if it consists of `( ` and `) ` characters only, and: * It is the empty string, or * It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are VPS\'s, or * It can be written as `(A)`, where `A` is a VPS. We can similarly define the _nesting depth_ `depth(S)` of any VPS `S` as follows: * `depth( ) = 0` * `depth(A + B) = max(depth(A), depth(B))`, where `A` and `B` are VPS\'s * `depth( ( + A + ) ) = 1 + depth(A)`, where `A` is a VPS. For example, ` `, `()() `, and `()(()()) ` are VPS\'s (with nesting depths 0, 1, and 2), and `)( ` and `(() ` are not VPS\'s. Given a VPS seq, split it into two disjoint subsequences `A` and `B`, such that `A` and `B` are VPS\'s (and `A.length + B.length = seq.length`). Now choose **any** such `A` and `B` such that `max(depth(A), depth(B))` is the minimum possible value. Return an `answer` array (of length `seq.length`) that encodes such a choice of `A` and `B`: `answer[i] = 0` if `seq[i]` is part of `A`, else `answer[i] = 1`. Note that even though multiple answers may exist, you may return any of them. **Example 1:** **Input:** seq = (()()) **Output:** [0,1,1,1,1,0] **Example 2:** **Input:** seq = ()(())() **Output:** [0,0,0,1,1,0,1,1] **Constraints:** * `1 <= seq.size <= 10000`","completion":"def minScoreTriangulation(values): n = len(values) dp = [[0] * n for _ in range(n)] for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = float(\'inf\') for k in range(i + 1, j): dp[i][j] = min(dp[i][j], values[i] * values[j] * values[k] + dp[i][k] + dp[k][j]) return dp[0][n - 1]"},{"prompt":"You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`\'s and `1`\'s. In one move, you can choose two **adjacent** indices and swap their values. Return _the **minimum** number of moves required so that_ `nums` _has_ `k` _**consecutive**_ `1`_\'s_. **Example 1:** **Input:** nums = [1,0,0,1,0,1], k = 2 **Output:** 1 **Explanation:** In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1\'s. **Example 2:** **Input:** nums = [1,0,0,0,0,0,1,1], k = 3 **Output:** 5 **Explanation:** In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1]. **Example 3:** **Input:** nums = [1,1,0,1], k = 2 **Output:** 0 **Explanation:** nums already has 2 consecutive 1\'s. **Constraints:** * `1 <= nums.length <= 105` * `nums[i]` is `0` or `1`. * `1 <= k <= sum(nums)`","completion":"def minMoves(nums, k): ones_pos = [i for i, x in enumerate(nums) if x == 1] to_move = [i_b - i_a for i_a, i_b in zip(range(k), ones_pos)] min_moves = sum(to_move[k // 2:]) move = min_moves for left, right in zip( to_move[:-k], # left \\"window\\" of k-sized sliding window to_move[k // 2 + 1:], # right \\"window\\" of k-sized sliding window ): move += left - right min_moves = min(min_moves, move) return min_moves"},{"prompt":"Given a string `s` consisting of **only** the characters `\'a\'` and `\'b\'`, return `true` _if **every**_ `\'a\'` _appears before **every**_ `\'b\'` _in the string_. Otherwise, return `false`. **Example 1:** **Input:** s = aaabbb **Output:** true **Explanation:** The \'a\'s are at indices 0, 1, and 2, while the \'b\'s are at indices 3, 4, and 5. Hence, every \'a\' appears before every \'b\' and we return true. **Example 2:** **Input:** s = abab **Output:** false **Explanation:** There is an \'a\' at index 2 and a \'b\' at index 1. Hence, not every \'a\' appears before every \'b\' and we return false. **Example 3:** **Input:** s = bbb **Output:** true **Explanation:** There are no \'a\'s, hence, every \'a\' appears before every \'b\' and we return true. **Constraints:** * `1 <= s.length <= 100` * `s[i]` is either `\'a\'` or `\'b\'`.","completion":"def firstDayBeenInAllRooms(nextVisit): n = len(nextVisit) ans = 0 MOD = 10**9 + 7 dp = [0] * n for i in range(1, n): dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD ans = (ans + dp[i]) % MOD return ans"},{"prompt":"An array `nums` of length `n` is **beautiful** if: * `nums` is a permutation of the integers in the range `[1, n]`. * For every `0 <= i < j < n`, there is no index `k` with `i < k < j` where `2 * nums[k] == nums[i] + nums[j]`. Given the integer `n`, return _any **beautiful** array_ `nums` _of length_ `n`. There will be at least one valid answer for the given `n`. **Example 1:** **Input:** n = 4 **Output:** [2,1,4,3] **Example 2:** **Input:** n = 5 **Output:** [3,1,2,5,4] **Constraints:** * `1 <= n <= 1000`","completion":"def isMonotonic(nums): increasing = decreasing = True for i in range(1, len(nums)): if nums[i] > nums[i - 1]: decreasing = False if nums[i] < nums[i - 1]: increasing = False return increasing or decreasing"},{"prompt":"A scenic location is represented by its `name` and attractiveness `score`, where `name` is a **unique** string among all locations and `score` is an integer. Locations can be ranked from the best to the worst. The **higher** the score, the better the location. If the scores of two locations are equal, then the location with the **lexicographically smaller** name is better. You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports: * **Adding** scenic locations, **one at a time**. * **Querying** the `ith` **best** location of **all locations already added**, where `i` is the number of times the system has been queried (including the current query). * For example, when the system is queried for the `4th` time, it returns the `4th` best location of all locations already added. Note that the test data are generated so that **at any time**, the number of queries **does not exceed** the number of locations added to the system. Implement the `SORTracker` class: * `SORTracker()` Initializes the tracker system. * `void add(string name, int score)` Adds a scenic location with `name` and `score` to the system. * `string get()` Queries and returns the `ith` best location, where `i` is the number of times this method has been invoked (including this invocation). **Example 1:** **Input** [ SORTracker , add , add , get , add , get , add , get , add , get , add , get , get ] [[], [ bradford , 2], [ branford , 3], [], [ alps , 2], [], [ orland , 2], [], [ orlando , 3], [], [ alpine , 2], [], []] **Output** [null, null, null, branford , null, alps , null, bradford , null, bradford , null, bradford , orland ] **Explanation** SORTracker tracker = new SORTracker(); // Initialize the tracker system. tracker.add( bradford , 2); // Add location with name= bradford and score=2 to the system. tracker.add( branford , 3); // Add location with name= branford and score=3 to the system. tracker.get(); // The sorted locations, from best to worst, are: branford, bradford. // Note that branford precedes bradford due to its **higher score** (3 > 2). // This is the 1st time get() is called, so return the best location: branford . tracker.add( alps , 2); // Add location with name= alps and score=2 to the system. tracker.get(); // Sorted locations: branford, alps, bradford. // Note that alps precedes bradford even though they have the same score (2). // This is because alps is **lexicographically smaller** than bradford . // Return the 2nd best location alps , as it is the 2nd time get() is called. tracker.add( orland , 2); // Add location with name= orland and score=2 to the system. tracker.get(); // Sorted locations: branford, alps, bradford, orland. // Return bradford , as it is the 3rd time get() is called. tracker.add( orlando , 3); // Add location with name= orlando and score=3 to the system. tracker.get(); // Sorted locations: branford, orlando, alps, bradford, orland. // Return bradford . tracker.add( alpine , 2); // Add location with name= alpine and score=2 to the system. tracker.get(); // Sorted locations: branford, orlando, alpine, alps, bradford, orland. // Return bradford . tracker.get(); // Sorted locations: branford, orlando, alpine, alps, bradford, orland. // Return orland . **Constraints:** * `name` consists of lowercase English letters, and is unique among all locations. * `1 <= name.length <= 10` * `1 <= score <= 105` * At any time, the number of calls to `get` does not exceed the number of calls to `add`. * At most `4 * 104` calls **in total** will be made to `add` and `get`.","completion":"def findMiddleIndex(nums): total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): total_sum -= num if left_sum == total_sum: return i left_sum += num return -1"},{"prompt":"the universe Earth C137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has `n` empty baskets, the `ith` basket is at `position[i]`, Morty has `m` balls and needs to distribute the balls into the baskets such that the **minimum magnetic force** between any two balls is **maximum**. Rick stated that magnetic force between two different balls at positions `x` and `y` is `|x y|`. Given the integer array `position` and the integer `m`. Return _the required force_. **Example 1:** **Input:** position = [1,2,3,4,7], m = 3 **Output:** 3 **Explanation:** Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3. **Example 2:** **Input:** position = [5,4,3,2,1,1000000000], m = 2 **Output:** 999999999 **Explanation:** We can use baskets 1 and 1000000000. **Constraints:** * `n == position.length` * `2 <= n <= 105` * `1 <= position[i] <= 109` * All integers in `position` are **distinct**. * `2 <= m <= position.length`","completion":"def build_array(target, n): result = [] current = 1 for num in target: while current < num: result.append(\\"Push\\") result.append(\\"Pop\\") current += 1 result.append(\\"Push\\") current += 1 return result"},{"prompt":"You are given a **0indexed** integer array `nums`. You can apply the following operation any number of times: * Pick any element from `nums` and put it at the end of `nums`. The prefix sum array of `nums` is an array `prefix` of the same length as `nums` such that `prefix[i]` is the sum of all the integers `nums[j]` where `j` is in the inclusive range `[0, i]`. Return _the minimum number of operations such that the prefix sum array does not contain negative integers_. The test cases are generated such that it is always possible to make the prefix sum array nonnegative. **Example 1:** **Input:** nums = [2,3,5,4] **Output:** 0 **Explanation:** we do not need to do any operations. The array is [2,3,5,4]. The prefix sum array is [2, 5, 0, 4]. **Example 2:** **Input:** nums = [3,5,2,6] **Output:** 1 **Explanation:** we can do one operation on index 1. The array after the operation is [3,2,6,5]. The prefix sum array is [3, 1, 7, 2]. **Constraints:** * `1 <= nums.length <= 105` * `109 <= nums[i] <= 109`","completion":"def min_operations(nums): min_prefix = 0 prefix = 0 for num in nums: prefix += num min_prefix = min(min_prefix, prefix) return -min_prefix if min_prefix < 0 else 0"},{"prompt":"Given an integer array `nums` of length `n`, return `true` if there is a triplet `(i, j, k)` which satisfies the following conditions: * `0 < i, i + 1 < j, j + 1 < k < n 1` * The sum of subarrays `(0, i 1)`, `(i + 1, j 1)`, `(j + 1, k 1)` and `(k + 1, n 1)` is equal. A subarray `(l, r)` represents a slice of the original array starting from the element indexed `l` to the element indexed `r`. **Example 1:** **Input:** nums = [1,2,1,2,1,2,1] **Output:** true **Explanation:** i = 1, j = 3, k = 5. sum(0, i 1) = sum(0, 0) = 1 sum(i + 1, j 1) = sum(2, 2) = 1 sum(j + 1, k 1) = sum(4, 4) = 1 sum(k + 1, n 1) = sum(6, 6) = 1 **Example 2:** **Input:** nums = [1,2,1,2,1,2,1,2] **Output:** false **Constraints:** * `n == nums.length` * `1 <= n <= 2000` * `106 <= nums[i] <= 106`","completion":"def find_triplet_equal_sum(nums): n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] for i in range(1, n - 2): for j in range(i + 2, n - 1): for k in range(j + 2, n): s1 = prefix_sum[i] s2 = prefix_sum[j] - prefix_sum[i + 1] s3 = prefix_sum[k] - prefix_sum[j + 1] s4 = prefix_sum[n] - prefix_sum[k + 1] if s1 == s2 == s3 == s4: return True return False"},{"prompt":"Given a string `s`, remove the vowels `\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, and `\'u\'` from it, and return the new string. **Example 1:** **Input:** s = leetcodeisacommunityforcoders **Output:** ltcdscmmntyfrcdrs **Example 2:** **Input:** s = aeiou **Output:** **Constraints:** * `1 <= s.length <= 1000` * `s` consists of only lowercase English letters.","completion":"def is_robot_bounded(instructions: str) -> bool: x, y, dir = 0, 0, 0 moves = [(0, 1), (1, 0), (0, -1), (-1, 0)] for c in instructions: if c == \'G\': x += moves[dir][0] y += moves[dir][1] elif c == \'L\': dir = (dir + 3) % 4 else: dir = (dir + 1) % 4 return (x == 0 and y == 0) or dir != 0"},{"prompt":"You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array `days`. Each day is an integer from `1` to `365`. Train tickets are sold in **three different ways**: * a **1day** pass is sold for `costs[0]` dollars, * a **7day** pass is sold for `costs[1]` dollars, and * a **30day** pass is sold for `costs[2]` dollars. The passes allow that many days of consecutive travel. * For example, if we get a **7day** pass on day `2`, then we can travel for `7` days: `2`, `3`, `4`, `5`, `6`, `7`, and `8`. Return _the minimum number of dollars you need to travel every day in the given list of days_. **Example 1:** **Input:** days = [1,4,6,7,8,20], costs = [2,7,15] **Output:** 11 **Explanation:** For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1day pass for costs[0] = 2, which covered day 1. On day 3, you bought a 7day pass for costs[1] = 7, which covered days 3, 4, ..., 9. On day 20, you bought a 1day pass for costs[0] = 2, which covered day 20. In total, you spent 11 and covered all the days of your travel. **Example 2:** **Input:** days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] **Output:** 17 **Explanation:** For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30day pass for costs[2] = 15 which covered days 1, 2, ..., 30. On day 31, you bought a 1day pass for costs[0] = 2 which covered day 31. In total, you spent 17 and covered all the days of your travel. **Constraints:** * `1 <= days.length <= 365` * `1 <= days[i] <= 365` * `days` is in strictly increasing order. * `costs.length == 3` * `1 <= costs[i] <= 1000`","completion":"def validateStackSequences(pushed, popped): stack = [] popIndex = 0 for pushValue in pushed: stack.append(pushValue) while stack and stack[-1] == popped[popIndex]: stack.pop() popIndex += 1 return not stack"},{"prompt":"A newly designed keypad was tested, where a tester pressed a sequence of `n` keys, one at a time. You are given a string `keysPressed` of length `n`, where `keysPressed[i]` was the `ith` key pressed in the testing sequence, and a sorted list `releaseTimes`, where `releaseTimes[i]` was the time the `ith` key was released. Both arrays are **0indexed**. The `0th` key was pressed at the time `0`, and every subsequent key was pressed at the **exact** time the previous key was released. The tester wants to know the key of the keypress that had the **longest duration**. The `ith` keypress had a **duration** of `releaseTimes[i] releaseTimes[i 1]`, and the `0th` keypress had a duration of `releaseTimes[0]`. Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key **may not** have had the same **duration**. _Return the key of the keypress that had the **longest duration**. If there are multiple such keypresses, return the lexicographically largest key of the keypresses._ **Example 1:** **Input:** releaseTimes = [9,29,49,50], keysPressed = cbcd **Output:** c **Explanation:** The keypresses were as follows: Keypress for \'c\' had a duration of 9 (pressed at time 0 and released at time 9). Keypress for \'b\' had a duration of 29 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29). Keypress for \'c\' had a duration of 49 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49). Keypress for \'d\' had a duration of 50 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50). The longest of these was the keypress for \'b\' and the second keypress for \'c\', both with duration 20. \'c\' is lexicographically larger than \'b\', so the answer is \'c\'. **Example 2:** **Input:** releaseTimes = [12,23,36,46,62], keysPressed = spuda **Output:** a **Explanation:** The keypresses were as follows: Keypress for \'s\' had a duration of 12. Keypress for \'p\' had a duration of 23 12 = 11. Keypress for \'u\' had a duration of 36 23 = 13. Keypress for \'d\' had a duration of 46 36 = 10. Keypress for \'a\' had a duration of 62 46 = 16. The longest of these was the keypress for \'a\' with duration 16. **Constraints:** * `releaseTimes.length == n` * `keysPressed.length == n` * `2 <= n <= 1000` * `1 <= releaseTimes[i] <= 109` * `releaseTimes[i] < releaseTimes[i+1]` * `keysPressed` contains only lowercase English letters.","completion":"def minInteger(num: str, k: int) -> str: if k == 0: return num num = list(num) n = len(num) for i in range(n): idx = i for j in range(i + 1, n): if j - i > k: break if num[j] < num[idx]: idx = j min_digit = num[idx] for j in range(idx, i, -1): num[j] = num[j - 1] num[i] = min_digit k -= idx - i return \'\'.join(num)"},{"prompt":"You are given a string `s`, a string `chars` of **distinct** characters and an integer array `vals` of the same length as `chars`. The **cost of the substring** is the sum of the values of each character in the substring. The cost of an empty string is considered `0`. The **value of the character** is defined in the following way: * If the character is not in the string `chars`, then its value is its corresponding position **(1indexed)** in the alphabet. * For example, the value of `\'a\'` is `1`, the value of `\'b\'` is `2`, and so on. The value of `\'z\'` is `26`. * Otherwise, assuming `i` is the index where the character occurs in the string `chars`, then its value is `vals[i]`. Return _the maximum cost among all substrings of the string_ `s`. **Example 1:** **Input:** s = adaa , chars = d , vals = [1000] **Output:** 2 **Explanation:** The value of the characters a and d is 1 and 1000 respectively. The substring with the maximum cost is aa and its cost is 1 + 1 = 2. It can be proven that 2 is the maximum cost. **Example 2:** **Input:** s = abc , chars = abc , vals = [1,1,1] **Output:** 0 **Explanation:** The value of the characters a , b and c is 1, 1, and 1 respectively. The substring with the maximum cost is the empty substring and its cost is 0. It can be proven that 0 is the maximum cost. **Constraints:** * `1 <= s.length <= 105` * `s` consist of lowercase English letters. * `1 <= chars.length <= 26` * `chars` consist of **distinct** lowercase English letters. * `vals.length == chars.length` * `1000 <= vals[i] <= 1000`","completion":"def max_value_substring(s, chars, vals): values = {key: val for key, val in zip(chars, vals)} max_cost = 0 cost = 0 for c in s: value = values.get(c) if c in values else ord(c) - ord(\'a\') + 1 cost = max(0, cost + value) max_cost = max(max_cost, cost) return max_cost"},{"prompt":"A digit string is **good** if the digits **(0indexed)** at **even** indices are **even** and the digits at **odd** indices are **prime** (`2`, `3`, `5`, or `7`). * For example, `2582 ` is good because the digits (`2` and `8`) at even positions are even and the digits (`5` and `2`) at odd positions are prime. However, `3245 ` is **not** good because `3` is at an even index but is not even. Given an integer `n`, return _the **total** number of good digit strings of length_ `n`. Since the answer may be large, **return it modulo** `109 + 7`. A **digit string** is a string consisting of digits `0` through `9` that may contain leading zeros. **Example 1:** **Input:** n = 1 **Output:** 5 **Explanation:** The good numbers of length 1 are 0 , 2 , 4 , 6 , 8 . **Example 2:** **Input:** n = 4 **Output:** 400 **Example 3:** **Input:** n = 50 **Output:** 564908303 **Constraints:** * `1 <= n <= 1015`","completion":"def goodDigitStrings(n: int) -> int: MOD = 1000000007 even_count, prime_count = 1, 1 for i in range(n): if i % 2 == 0: even_count = (even_count * 5) % MOD else: prime_count = (prime_count * 4) % MOD return (even_count * prime_count) % MOD"},{"prompt":"Given an array of integers `arr`, replace each element with its rank. The rank represents how large the element is. The rank has the following rules: * Rank is an integer starting from 1. * The larger the element, the larger the rank. If two elements are equal, their rank must be the same. * Rank should be as small as possible. **Example 1:** **Input:** arr = [40,10,20,30] **Output:** [4,1,2,3] **Explanation**: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest. **Example 2:** **Input:** arr = [100,100,100] **Output:** [1,1,1] **Explanation**: Same elements share the same rank. **Example 3:** **Input:** arr = [37,12,28,9,100,56,80,5,12] **Output:** [5,3,4,2,8,6,7,1,3] **Constraints:** * `0 <= arr.length <= 105` * `109 <= arr[i] <= 109` Every time you are in a cell you will collect all the gold in that cell. From your position, you can walk one step to the left, right, up, or down. You can\'t visit the same cell more than once. Never visit a cell with 0 gold. You can start and stop collecting gold from any position in the grid that has some gold.","completion":"def getMaximumGold(grid): m, n, max_gold = len(grid), len(grid[0]), 0 def getMaximumGoldHelper(x, y): if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] == 0: return 0 original_gold = grid[x][y] grid[x][y] = 0 max_gold = 0 max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y)) max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y)) max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1)) max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1)) grid[x][y] = original_gold return max_gold + original_gold for i in range(m): for j in range(n): if grid[i][j] != 0: max_gold = max(max_gold, getMaximumGoldHelper(i, j)) return max_gold"},{"prompt":"You are given an `m x n` integer matrix `grid`​​​, where `m` and `n` are both **even** integers, and an integer `k`. The matrix is composed of several layers, which is shown in the below image, where each color is its own layer: A cyclic rotation of the matrix is done by cyclically rotating **each layer** in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the **counterclockwise** direction. An example rotation is shown below: Return _the matrix after applying_ `k` _cyclic rotations to it_. **Example 1:** **Input:** grid = [[40,10],[30,20]], k = 1 **Output:** [[10,20],[40,30]] **Explanation:** The figures above represent the grid at every state. **Example 2:** **Input:** grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2 **Output:** [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] **Explanation:** The figures above represent the grid at every state. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `2 <= m, n <= 50` * Both `m` and `n` are **even** integers. * `1 <= grid[i][j] <= 5000` * `1 <= k <= 109`","completion":"def rotateGrid(grid, k): if not grid: return grid m, n = len(grid), len(grid[0]) numLayers = min(m, n) // 2 for layer in range(numLayers): numToRotate = (m - 2 * layer) * 2 + (n - 2 * layer - 2) * 2 effective_k = k % numToRotate while effective_k: temp = grid[layer][layer] for i in range(layer + 1, m - layer): temp, grid[i][layer] = grid[i][layer], temp for j in range(layer + 1, n - layer): temp, grid[m - layer - 1][j] = grid[m - layer - 1][j], temp for i in range(m - layer - 2, layer - 1, -1): temp, grid[i][n - layer - 1] = grid[i][n - layer - 1], temp for j in range(n - layer - 2, layer, -1): temp, grid[layer][j] = grid[layer][j], temp effective_k -= 1 return grid"},{"prompt":"A **complete binary tree** is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion. Implement the `CBTInserter` class: * `CBTInserter(TreeNode root)` Initializes the data structure with the `root` of the complete binary tree. * `int insert(int v)` Inserts a `TreeNode` into the tree with value `Node.val == val` so that the tree remains complete, and returns the value of the parent of the inserted `TreeNode`. * `TreeNode get_root()` Returns the root node of the tree. **Example 1:** **Input** [ CBTInserter , insert , insert , get_root ] [[[1, 2]], [3], [4], []] **Output** [null, 1, 2, [1, 2, 3, 4]] **Explanation** CBTInserter cBTInserter = new CBTInserter([1, 2]); cBTInserter.insert(3); // return 1 cBTInserter.insert(4); // return 2 cBTInserter.get_root(); // return [1, 2, 3, 4] **Constraints:** * The number of nodes in the tree will be in the range `[1, 1000]`. * `0 <= Node.val <= 5000` * `root` is a complete binary tree. * `0 <= val <= 5000` * At most `104` calls will be made to `insert` and `get_root`.","completion":"def projectionArea(grid): n = len(grid) top, front, side = 0, 0, 0 for i in range(n): max_front, max_side = 0, 0 for j in range(n): if grid[i][j] > 0: top += 1 max_front = max(max_front, grid[i][j]) max_side = max(max_side, grid[j][i]) front += max_front side += max_side return top + front + side"},{"prompt":"You are given an integer `n`. You roll a fair 6sided dice `n` times. Determine the total number of **distinct** sequences of rolls possible such that the following conditions are satisfied: 1. The **greatest common divisor** of any **adjacent** values in the sequence is equal to `1`. 2. There is **at least** a gap of `2` rolls between **equal** valued rolls. More formally, if the value of the `ith` roll is **equal** to the value of the `jth` roll, then `abs(i j) > 2`. Return _the **total number** of distinct sequences possible_. Since the answer may be very large, return it **modulo** `109 + 7`. Two sequences are considered distinct if at least one element is different. **Example 1:** **Input:** n = 4 **Output:** 184 **Explanation:** Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc. Some invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6). (1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 3) = 2 (i and j are 1indexed). (1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3. There are a total of 184 distinct sequences possible, so we return 184. **Example 2:** **Input:** n = 2 **Output:** 22 **Explanation:** Some of the possible sequences are (1, 2), (2, 1), (3, 2). Some invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1. There are a total of 22 distinct sequences possible, so we return 22. **Constraints:** * `1 <= n <= 104`","completion":"def bob_arrows(num_arrows, alice_arrows): bob = [0] * 12 for i in range(11, -1, -1): if num_arrows > 0 and alice_arrows[i] == 0: shot = min(num_arrows, i+1) bob[i] = shot num_arrows -= shot return bob"},{"prompt":"You are given four integers `minLength`, `maxLength`, `oneGroup` and `zeroGroup`. A binary string is **good** if it satisfies the following conditions: * The length of the string is in the range `[minLength, maxLength]`. * The size of each block of consecutive `1`\'s is a multiple of `oneGroup`. * For example in a binary string `00110111100` sizes of each block of consecutive ones are `[2,4]`. * The size of each block of consecutive `0`\'s is a multiple of `zeroGroup`. * For example, in a binary string `00110111100` sizes of each block of consecutive ones are `[2,1,2]`. Return _the number of **good** binary strings_. Since the answer may be too large, return it **modulo** `109 + 7`. **Note** that `0` is considered a multiple of all the numbers. **Example 1:** **Input:** minLength = 2, maxLength = 3, oneGroup = 1, zeroGroup = 2 **Output:** 5 **Explanation:** There are 5 good binary strings in this example: 00 , 11 , 001 , 100 , and 111 . It can be proven that there are only 5 good strings satisfying all conditions. **Example 2:** **Input:** minLength = 4, maxLength = 4, oneGroup = 4, zeroGroup = 3 **Output:** 1 **Explanation:** There is only 1 good binary string in this example: 1111 . It can be proven that there is only 1 good string satisfying all conditions. **Constraints:** * `1 <= minLength <= maxLength <= 105` * `1 <= oneGroup, zeroGroup <= maxLength`","completion":"def countGoodStrings(minLength, maxLength, oneGroup, zeroGroup): mod = 1000000007 maxCount = maxLength // oneGroup + maxLength // zeroGroup dp = [0] * (maxCount + 1) dp[0] = 1 for i in range(1, maxCount + 1): dp[i] = dp[i - 1] * (1 if i % oneGroup == 0 or i % zeroGroup == 0 else 0) % mod ans = 0 for i in range(maxCount + 1): ans = (ans + dp[minLength // oneGroup + minLength // zeroGroup - i] - (0 if minLength - 1 // oneGroup + minLength - 1 // zeroGroup - i < 0 else dp[(minLength - 1) // oneGroup + (minLength - 1) // zeroGroup - i])) % mod return ans"},{"prompt":"There are `n` cars going to the same destination along a onelane road. The destination is `target` miles away. You are given two integer array `position` and `speed`, both of length `n`, where `position[i]` is the position of the `ith` car and `speed[i]` is the speed of the `ith` car (in miles per hour). A car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper **at the same speed**. The faster car will **slow down** to match the slower car\'s speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position). A **car fleet** is some nonempty set of cars driving at the same position and same speed. Note that a single car is also a car fleet. If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet. Return _the **number of car fleets** that will arrive at the destination_. **Example 1:** **Input:** target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] **Output:** 3 **Explanation:** The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The car starting at 0 does not catch up to any other car, so it is a fleet by itself. The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target. Note that no other cars meet these fleets before the destination, so the answer is 3. **Example 2:** **Input:** target = 10, position = [3], speed = [3] **Output:** 1 **Explanation:** There is only one car, hence there is only one fleet. **Example 3:** **Input:** target = 100, position = [0,2,4], speed = [4,2,1] **Output:** 1 **Explanation:** The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2. Then, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target. **Constraints:** * `n == position.length == speed.length` * `1 <= n <= 105` * `0 < target <= 106` * `0 <= position[i] < target` * All the values of `position` are **unique**. * `0 < speed[i] <= 106`","completion":"def max_profit_assignment(difficulty, profit, worker): jobs = sorted(zip(difficulty, profit)) worker.sort() i, max_profit, total_profit = 0, 0, 0 for ability in worker: while i < len(difficulty) and ability >= jobs[i][0]: max_profit = max(max_profit, jobs[i][1]) i += 1 total_profit += max_profit return total_profit"},{"prompt":"You are given an array of strings `arr`. A string `s` is formed by the **concatenation** of a **subsequence** of `arr` that has **unique characters**. Return _the **maximum** possible length_ of `s`. A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. **Example 1:** **Input:** arr = [ un , iq , ue ] **Output:** 4 **Explanation:** All the valid concatenations are: un iq ue uniq ( un + iq ) ique ( iq + ue ) Maximum length is 4. **Example 2:** **Input:** arr = [ cha , r , act , ers ] **Output:** 6 **Explanation:** Possible longest valid concatenations are chaers ( cha + ers ) and acters ( act + ers ). **Example 3:** **Input:** arr = [ abcdefghijklmnopqrstuvwxyz ] **Output:** 26 **Explanation:** The only string in arr has all 26 characters. **Constraints:** * `1 <= arr.length <= 16` * `1 <= arr[i].length <= 26` * `arr[i]` contains only lowercase English letters.","completion":"def largest1BorderedSquare(grid): m, n = len(grid), len(grid[0]) horizontal, vertical = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)] max_square_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: horizontal[i][j] = 1 if j == 0 else horizontal[i][j - 1] + 1 vertical[i][j] = 1 if i == 0 else vertical[i - 1][j] + 1 min_size = min(horizontal[i][j], vertical[i][j]) while min_size > max_square_size: if (horizontal[i - min_size + 1][j] >= min_size and vertical[i][j - min_size + 1] >= min_size): max_square_size = min_size min_size -= 1 return max_square_size * max_square_size"},{"prompt":"There is an undirected connected tree with `n` nodes labeled from `0` to `n 1` and `n 1` edges. You are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. Return an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes. **Example 1:** **Input:** n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] **Output:** [8,12,6,10,10,10] **Explanation:** The tree is shown above. We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8. Hence, answer[0] = 8, and so on. **Example 2:** **Input:** n = 1, edges = [] **Output:** [0] **Example 3:** **Input:** n = 2, edges = [[1,0]] **Output:** [1,1] **Constraints:** * `1 <= n <= 3 * 104` * `edges.length == n 1` * `edges[i].length == 2` * `0 <= ai, bi < n` * `ai != bi` * The given input represents a valid tree.","completion":"def ambiguousCoordinates(s): def generateNumber(s): if not s or (len(s) > 1 and s[0] == \'0\' and s[-1] == \'0\'): return [] if len(s) > 1 and s[0] == \'0\': return [\\"0.\\" + s[1:]] res = [s] if len(s) == 1 or s[-1] == \'0\': return res for i in range(1, len(s)): res.append(s[:i] + \\".\\" + s[i:]) return res n = len(s) res = [] for i in range(2, n - 1): first = generateNumber(s[1:i]) second = generateNumber(s[i:n - 1]) for f in first: for sec in second: res.append(\\"(\\" + f + \\", \\" + sec + \\")\\") return res"},{"prompt":"Given `n` `points` on a 2D plane where `points[i] = [xi, yi]`, Return _the **widest vertical area** between two points such that no points are inside the area._ A **vertical area** is an area of fixedwidth extending infinitely along the yaxis (i.e., infinite height). The **widest vertical area** is the one with the maximum width. Note that points **on the edge** of a vertical area **are not** considered included in the area. **Example 1:** ​ **Input:** points = [[8,7],[9,9],[7,4],[9,7]] **Output:** 1 **Explanation:** Both the red and the blue area are optimal. **Example 2:** **Input:** points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]] **Output:** 3 **Constraints:** * `n == points.length` * `2 <= n <= 105` * `points[i].length == 2` * `0 <= xi, yi <= 109`","completion":"def min_length_encoded(s: str, k: int) -> int: n = len(s) dp = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(k + 1): cnt = 1 dp[i][j] = i - j l = i - 2 while l >= 0 and i - 2 - l <= j: if s[l] == s[i - 1]: cnt += 1 else: cnt = 1 used = i - 2 - l new_aposition = i - 1 - cnt - used + 1 if cnt >= 100: new_aposition += 4 elif cnt >= 10: new_aposition += 3 elif cnt >= 2: new_aposition += 2 else: new_aposition += 1 dp[i][j] = min(dp[i][j], new_aposition + dp[l][j - used]) l -= 1 return dp[n][k]"},{"prompt":"You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day. A **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule. Return _the number of **smooth descent periods**_. **Example 1:** **Input:** prices = [3,2,1,4] **Output:** 7 **Explanation:** There are 7 smooth descent periods: [3], [2], [1], [4], [3,2], [2,1], and [3,2,1] Note that a period with one day is a smooth descent period by the definition. **Example 2:** **Input:** prices = [8,6,7,7] **Output:** 4 **Explanation:** There are 4 smooth descent periods: [8], [6], [7], and [7] Note that [8,6] is not a smooth descent period as 8 6 ≠ 1. **Example 3:** **Input:** prices = [1] **Output:** 1 **Explanation:** There is 1 smooth descent period: [1] **Constraints:** * `1 <= prices.length <= 105` * `1 <= prices[i] <= 105`","completion":"def num_smooth_descent_periods(prices): result = 0 count = 0 for i in range(1, len(prices)): if prices[i] == prices[i - 1] - 1: count += 1 else: count = 0 result += count + 1 return result + 1"},{"prompt":"The **complement** of an integer is the integer you get when you flip all the `0`\'s to `1`\'s and all the `1`\'s to `0`\'s in its binary representation. * For example, The integer `5` is `101 ` in binary and its **complement** is `010 ` which is the integer `2`. Given an integer `n`, return _its complement_. **Example 1:** **Input:** n = 5 **Output:** 2 **Explanation:** 5 is 101 in binary, with complement 010 in binary, which is 2 in base10. **Example 2:** **Input:** n = 7 **Output:** 0 **Explanation:** 7 is 111 in binary, with complement 000 in binary, which is 0 in base10. **Example 3:** **Input:** n = 10 **Output:** 5 **Explanation:** 10 is 1010 in binary, with complement 0101 in binary, which is 5 in base10. **Constraints:** * `0 <= n < 109` **Note:** This question is the same as 476: [https://leetcode.com/problems/numbercomplement/](https://leetcode.com/problems/numbercomplement/)","completion":"def pancakeSort(arr): flips = [] for size in range(len(arr), 1, -1): maxIdx = arr.index(max(arr[:size])) flips.extend([maxIdx + 1, size]) arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1]) arr[:size] = reversed(arr[:size]) return flips"},{"prompt":"Design a special dictionary that searches the words in it by a prefix and a suffix. Implement the `WordFilter` class: * `WordFilter(string[] words)` Initializes the object with the `words` in the dictionary. * `f(string pref, string suff)` Returns _the index of the word in the dictionary,_ which has the prefix `pref` and the suffix `suff`. If there is more than one valid index, return **the largest** of them. If there is no such word in the dictionary, return `1`. **Example 1:** **Input** [ WordFilter , f ] [[[ apple ]], [ a , e ]] **Output** [null, 0] **Explanation** WordFilter wordFilter = new WordFilter([ apple ]); wordFilter.f( a , e ); // return 0, because the word at index 0 has prefix = a and suffix = e . **Constraints:** * `1 <= words.length <= 104` * `1 <= words[i].length <= 7` * `1 <= pref.length, suff.length <= 7` * `words[i]`, `pref` and `suff` consist of lowercase English letters only. * At most `104` calls will be made to the function `f`.","completion":"def next_greatest_letter(letters, target): for letter in letters: if letter > target: return letter return letters[0]"},{"prompt":"Given a string of English letters `s`, return _the **greatest** English letter which occurs as **both** a lowercase and uppercase letter in_ `s`. The returned letter should be in **uppercase**. If no such letter exists, return _an empty string_. An English letter `b` is **greater** than another letter `a` if `b` appears **after** `a` in the English alphabet. **Example 1:** **Input:** s = l**Ee**TcOd**E** **Output:** E **Explanation:** The letter \'E\' is the only letter to appear in both lower and upper case. **Example 2:** **Input:** s = a**rR**AzFif **Output:** R **Explanation:** The letter \'R\' is the greatest letter to appear in both lower and upper case. Note that \'A\' and \'F\' also appear in both lower and upper case, but \'R\' is greater than \'F\' or \'A\'. **Example 3:** **Input:** s = AbCdEfGhIjK **Output:** **Explanation:** There is no letter that appears in both lower and upper case. **Constraints:** * `1 <= s.length <= 1000` * `s` consists of lowercase and uppercase English letters.","completion":"def get_max_occurrences(text: str, pattern: str) -> int: count = [0, 0] for c in text: if c == pattern[1]: count[1] += count[0] elif c == pattern[0]: count[0] += 1 return count[1]"},{"prompt":"Given two numbers `arr1` and `arr2` in base **2**, return the result of adding them together. Each number is given in _array format_: as an array of 0s and 1s, from most significant bit to least significant bit. For example, `arr = [1,1,0,1]` represents the number `(2)^3 + (2)^2 + (2)^0 = 3`. A number `arr` in _array, format_ is also guaranteed to have no leading zeros: either `arr == [0]` or `arr[0] == 1`. Return the result of adding `arr1` and `arr2` in the same format: as an array of 0s and 1s with no leading zeros. **Example 1:** **Input:** arr1 = [1,1,1,1,1], arr2 = [1,0,1] **Output:** [1,0,0,0,0] **Explanation:** arr1 represents 11, arr2 represents 5, the output represents 16. **Example 2:** **Input:** arr1 = [0], arr2 = [0] **Output:** [0] **Example 3:** **Input:** arr1 = [0], arr2 = [1] **Output:** [1] **Constraints:** * `1 <= arr1.length, arr2.length <= 1000` * `arr1[i]` and `arr2[i]` are `0` or `1` * `arr1` and `arr2` have no leading zeros","completion":"from collections import deque def addNegabinary(arr1, arr2): res = deque() carry, i, j = 0, len(arr1) - 1, len(arr2) - 1 while i >= 0 or j >= 0 or carry: if i >= 0: carry += arr1[i] i -= 1 if j >= 0: carry += arr2[j] j -= 1 res.appendleft(carry & 1) carry = -(carry >> 1) while len(res) > 1 and res[0] == 0: res.popleft() return list(res)"},{"prompt":"Given the following details of a matrix with `n` columns and `2` rows : * The matrix is a binary matrix, which means each element in the matrix can be `0` or `1`. * The sum of elements of the 0th(upper) row is given as `upper`. * The sum of elements of the 1st(lower) row is given as `lower`. * The sum of elements in the ith column(0indexed) is `colsum[i]`, where `colsum` is given as an integer array with length `n`. Your task is to reconstruct the matrix with `upper`, `lower` and `colsum`. Return it as a 2D integer array. If there are more than one valid solution, any of them will be accepted. If no valid solution exists, return an empty 2D array. **Example 1:** **Input:** upper = 2, lower = 1, colsum = [1,1,1] **Output:** [[1,1,0],[0,0,1]] **Explanation:** [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers. **Example 2:** **Input:** upper = 2, lower = 3, colsum = [2,2,1,1] **Output:** [] **Example 3:** **Input:** upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1] **Output:** [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]] **Constraints:** * `1 <= colsum.length <= 10^5` * `0 <= upper, lower <= colsum.length` * `0 <= colsum[i] <= 2`","completion":"from heapq import heappush, heappop def diagonalSort(mat): m, n = len(mat), len(mat[0]) for i in range(m): pq = [] row, col = i, 0 while row < m and col < n: heappush(pq, mat[row][col]) row += 1 col += 1 row, col = i, 0 while row < m and col < n: mat[row][col] = heappop(pq) row += 1 col += 1 for i in range(1, n): pq = [] row, col = 0, i while row < m and col < n: heappush(pq, mat[row][col]) row += 1 col += 1 row, col = 0, i while row < m and col < n: mat[row][col] = heappop(pq) row += 1 col += 1 return mat"},{"prompt":"Given a digit string `s`, return _the number of **unique substrings** of_ `s` _where every digit appears the same number of times._ **Example 1:** **Input:** s = 1212 **Output:** 5 **Explanation:** The substrings that meet the requirements are 1 , 2 , 12 , 21 , 1212 . Note that although the substring 12 appears twice, it is only counted once. **Example 2:** **Input:** s = 12321 **Output:** 9 **Explanation:** The substrings that meet the requirements are 1 , 2 , 3 , 12 , 23 , 32 , 21 , 123 , 321 . **Constraints:** * `1 <= s.length <= 1000` * `s` consists of digits.","completion":"def are_numbers_increasing(s: str) -> bool: tokens = s.split() numbers = [] for token in tokens: if token.isdigit(): num = int(token) if numbers and numbers[-1] >= num: return False numbers.append(num) return True"},{"prompt":"Given a list of `words`, list of single `letters` (might be repeating) and `score` of every character. Return the maximum score of **any** valid set of words formed by using the given letters (`words[i]` cannot be used two or more times). It is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `\'a\'`, `\'b\'`, `\'c\'`, ... ,`\'z\'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively. **Example 1:** **Input:** words = [ dog , cat , dad , good ], letters = [ a , a , c , d , d , d , g , o , o ], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] **Output:** 23 **Explanation:** Score a=1, c=9, d=5, g=3, o=2 Given letters, we can form the words dad (5+1+5) and good (3+2+2+5) with a score of 23. Words dad and dog only get a score of 21. **Example 2:** **Input:** words = [ xxxz , ax , bx , cx ], letters = [ z , a , b , c , x , x , x ], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10] **Output:** 27 **Explanation:** Score a=4, b=4, c=4, x=5, z=10 Given letters, we can form the words ax (4+5), bx (4+5) and cx (4+5) with a score of 27. Word xxxz only get a score of 25. **Example 3:** **Input:** words = [ leetcode ], letters = [ l , e , t , c , o , d ], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0] **Output:** 0 **Explanation:** Letter e can only be used once. **Constraints:** * `1 <= words.length <= 14` * `1 <= words[i].length <= 15` * `1 <= letters.length <= 100` * `letters[i].length == 1` * `score.length == 26` * `0 <= score[i] <= 10` * `words[i]`, `letters[i]` contains only lower case English letters.","completion":"def maxValueAfterReverse(nums): total, diff = 0, 0 min2, max2 = float(\'inf\'), float(\'-inf\') for i in range(len(nums) - 1): total += abs(nums[i] - nums[i + 1]) min2 = min(min2, max(nums[i], nums[i + 1])) max2 = max(max2, min(nums[i], nums[i + 1])) diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i])) diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1])) return total + max(diff, 2 * (max2 - min2))"},{"prompt":"A **triplet** is an array of three integers. You are given a 2D integer array `triplets`, where `triplets[i] = [ai, bi, ci]` describes the `ith` **triplet**. You are also given an integer array `target = [x, y, z]` that describes the **triplet** you want to obtain. To obtain `target`, you may apply the following operation on `triplets` **any number** of times (possibly **zero**): * Choose two indices (**0indexed**) `i` and `j` (`i != j`) and **update** `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`. * For example, if `triplets[i] = [2, 5, 3]` and `triplets[j] = [1, 7, 5]`, `triplets[j]` will be updated to `[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]`. Return `true` _if it is possible to obtain the_ `target` _**triplet**_ `[x, y, z]` _as an **element** of_ `triplets`_, or_ `false` _otherwise_. **Example 1:** **Input:** triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5] **Output:** true **Explanation:** Perform the following operations: Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]] The target triplet [2,7,5] is now an element of triplets. **Example 2:** **Input:** triplets = [[3,4,5],[4,5,6]], target = [3,2,5] **Output:** false **Explanation:** It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets. **Example 3:** **Input:** triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5] **Output:** true **Explanation:** Perform the following operations: Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]]. The target triplet [5,5,5] is now an element of triplets. **Constraints:** * `1 <= triplets.length <= 105` * `triplets[i].length == target.length == 3` * `1 <= ai, bi, ci, x, y, z <= 1000`","completion":"def count_matches(items, rule_key, rule_value): rule = {\\"type\\": 0, \\"color\\": 1, \\"name\\": 2} count = 0 for item in items: if item[rule[rule_key]] == rule_value: count += 1 return count"},{"prompt":"Given an array of integers `nums`, half of the integers in `nums` are **odd**, and the other half are **even**. Sort the array so that whenever `nums[i]` is odd, `i` is **odd**, and whenever `nums[i]` is even, `i` is **even**. Return _any answer array that satisfies this condition_. **Example 1:** **Input:** nums = [4,2,5,7] **Output:** [4,5,2,7] **Explanation:** [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. **Example 2:** **Input:** nums = [2,3] **Output:** [2,3] **Constraints:** * `2 <= nums.length <= 2 * 104` * `nums.length` is even. * Half of the integers in `nums` are even. * `0 <= nums[i] <= 1000`","completion":"from collections import defaultdict def possible_bipartition(n, dislikes): def dfs(person, group): if person in groups: return groups[person] == group groups[person] = group for other in dislike_list[person]: if not dfs(other, -group): return False return True groups = {} dislike_list = defaultdict(list) for p1, p2 in dislikes: dislike_list[p1].append(p2) dislike_list[p2].append(p1) for person in range(1, n + 1): if person not in groups and not dfs(person, 1): return False return True"},{"prompt":"Given a string `s`, return _the last substring of_ `s` _in lexicographical order_. **Example 1:** **Input:** s = abab **Output:** bab **Explanation:** The substrings are [ a , ab , aba , abab , b , ba , bab ]. The lexicographically maximum substring is bab . **Example 2:** **Input:** s = leetcode **Output:** tcode **Constraints:** * `1 <= s.length <= 4 * 105` * `s` contains only lowercase English letters.","completion":"def lastSubstring(s: str) -> str: maxIndex = 0 curIndex = 1 while curIndex < len(s): i = 0 while curIndex + i < len(s) and s[maxIndex + i] == s[curIndex + i]: i += 1 if curIndex + i == len(s): break if s[maxIndex + i] < s[curIndex + i]: maxIndex = curIndex curIndex += 1 return s[maxIndex:]"},{"prompt":"You are given an integer array `values` where values[i] represents the value of the `ith` sightseeing spot. Two sightseeing spots `i` and `j` have a **distance** `j i` between them. The score of a pair (`i < j`) of sightseeing spots is `values[i] + values[j] + i j`: the sum of the values of the sightseeing spots, minus the distance between them. Return _the maximum score of a pair of sightseeing spots_. **Example 1:** **Input:** values = [8,1,5,2,6] **Output:** 11 **Explanation:** i = 0, j = 2, values[i] + values[j] + i j = 8 + 5 + 0 2 = 11 **Example 2:** **Input:** values = [1,2] **Output:** 2 **Constraints:** * `2 <= values.length <= 5 * 104` * `1 <= values[i] <= 1000`","completion":"def kClosest(points, k): points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2) return points[:k]"},{"prompt":"You want to build `n` new buildings in a city. The new buildings will be built in a line and are labeled from `1` to `n`. However, there are city restrictions on the heights of the new buildings: * The height of each building must be a nonnegative integer. * The height of the first building **must** be `0`. * The height difference between any two adjacent buildings **cannot exceed** `1`. Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array `restrictions` where `restrictions[i] = [idi, maxHeighti]` indicates that building `idi` must have a height **less than or equal to** `maxHeighti`. It is guaranteed that each building will appear **at most once** in `restrictions`, and building `1` will **not** be in `restrictions`. Return _the **maximum possible height** of the **tallest** building_. **Example 1:** **Input:** n = 5, restrictions = [[2,1],[4,1]] **Output:** 2 **Explanation:** The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2. **Example 2:** **Input:** n = 6, restrictions = [] **Output:** 5 **Explanation:** The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5. **Example 3:** **Input:** n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]] **Output:** 5 **Explanation:** The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5. **Constraints:** * `2 <= n <= 109` * `0 <= restrictions.length <= min(n 1, 105)` * `2 <= idi <= n` * `idi` is **unique**. * `0 <= maxHeighti <= 109`","completion":"from collections import defaultdict def dfs(node, visited, graph, group): if visited[node]: return visited[node] = 1 group.append(node) for neighbor in graph[node]: dfs(neighbor, visited, graph, group) def minimumHammingDistance(source, target, allowedSwaps): n = len(source) graph = defaultdict(list) for a, b in allowedSwaps: graph[a].append(b) graph[b].append(a) res = 0 visited = [0] * n for i in range(n): if not visited[i]: group = [] dfs(i, visited, graph, group) count = defaultdict(int) for node in group: count[source[node]] += 1 for node in group: if count[target[node]] > 0: res += 1 count[target[node]] -= 1 return n - res"},{"prompt":"Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number `n` on the chalkboard. On each player\'s turn, that player makes a move consisting of: * Choosing any `x` with `0 < x < n` and `n % x == 0`. * Replacing the number `n` on the chalkboard with `n x`. Also, if a player cannot make a move, they lose the game. Return `true` _if and only if Alice wins the game, assuming both players play optimally_. **Example 1:** **Input:** n = 2 **Output:** true **Explanation:** Alice chooses 1, and Bob has no more moves. **Example 2:** **Input:** n = 3 **Output:** false **Explanation:** Alice chooses 1, Bob chooses 1, and Alice has no more moves. **Constraints:** * `1 <= n <= 1000`","completion":"def mincostTickets(days, costs): travel_days = set(days) dp = [0] * 366 for i in range(1, 366): if i not in travel_days: dp[i] = dp[i - 1] else: dp[i] = min(dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]) return dp[365]"},{"prompt":"Design a queuelike data structure that moves the most recently used element to the end of the queue. Implement the `MRUQueue` class: * `MRUQueue(int n)` constructs the `MRUQueue` with `n` elements: `[1,2,3,...,n]`. * `int fetch(int k)` moves the `kth` element **(1indexed)** to the end of the queue and returns it. **Example 1:** **Input:** [ MRUQueue , fetch , fetch , fetch , fetch ] [[8], [3], [5], [2], [8]] **Output:** [null, 3, 6, 2, 2] **Explanation:** MRUQueue mRUQueue = new MRUQueue(8); // Initializes the queue to [1,2,3,4,5,6,7,8]. mRUQueue.fetch(3); // Moves the 3rd element (3) to the end of the queue to become [1,2,4,5,6,7,8,3] and returns it. mRUQueue.fetch(5); // Moves the 5th element (6) to the end of the queue to become [1,2,4,5,7,8,3,6] and returns it. mRUQueue.fetch(2); // Moves the 2nd element (2) to the end of the queue to become [1,4,5,7,8,3,6,2] and returns it. mRUQueue.fetch(8); // The 8th element (2) is already at the end of the queue so just return it. **Constraints:** * `1 <= n <= 2000` * `1 <= k <= n` * At most `2000` calls will be made to `fetch`.","completion":"def min_deletions(s: str) -> int: a_count, deletions = 0, 0 for c in s: if c == \'a\': a_count += 1 else: if a_count > 0: a_count -= 1 else: deletions += 1 return deletions"},{"prompt":"You are given an integer `money` denoting the amount of money (in dollars) that you have and another integer `children` denoting the number of children that you must distribute the money to. You have to distribute the money according to the following rules: * All money must be distributed. * Everyone must receive at least `1` dollar. * Nobody receives `4` dollars. Return _the **maximum** number of children who may receive **exactly**_ `8` _dollars if you distribute the money according to the aforementioned rules_. If there is no way to distribute the money, return `1`. **Example 1:** **Input:** money = 20, children = 3 **Output:** 1 **Explanation:** The maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is: 8 dollars to the first child. 9 dollars to the second child. 3 dollars to the third child. It can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1. **Example 2:** **Input:** money = 16, children = 2 **Output:** 2 **Explanation:** Each child can be given 8 dollars. **Constraints:** * `1 <= money <= 200` * `2 <= children <= 30`","completion":"def maximum_children_with_eight_dollars(money, children): if money < children * 1 or money > children * 8: return -1 max_eights = (money - children) // 7 return children if max_eights >= children else max_eights"},{"prompt":"Given the `edges` of a directed graph where `edges[i] = [ai, bi]` indicates there is an edge between nodes `ai` and `bi`, and two nodes `source` and `destination` of this graph, determine whether or not all paths starting from `source` eventually, end at `destination`, that is: * At least one path exists from the `source` node to the `destination` node * If a path exists from the `source` node to a node with no outgoing edges, then that node is equal to `destination`. * The number of possible paths from `source` to `destination` is a finite number. Return `true` if and only if all roads from `source` lead to `destination`. **Example 1:** **Input:** n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2 **Output:** false **Explanation:** It is possible to reach and get stuck on both node 1 and node 2. **Example 2:** **Input:** n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3 **Output:** false **Explanation:** We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely. **Example 3:** **Input:** n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3 **Output:** true **Constraints:** * `1 <= n <= 104` * `0 <= edges.length <= 104` * `edges.length == 2` * `0 <= ai, bi <= n 1` * `0 <= source <= n 1` * `0 <= destination <= n 1` * The given graph may have selfloops and parallel edges.","completion":"from collections import defaultdict def leadsToDestination(n, edges, source, destination): graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [0] * n return dfs(source, graph, visited, destination) def dfs(node, graph, visited, destination): if node not in graph: return node == destination if visited[node] != 0: return visited[node] == 2 visited[node] = 1 for neighbor in graph[node]: if not dfs(neighbor, graph, visited, destination): return False visited[node] = 2 return True"},{"prompt":"You are given an array of **unique** integers `salary` where `salary[i]` is the salary of the `ith` employee. Return _the average salary of employees excluding the minimum and maximum salary_. Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** salary = [4000,3000,1000,2000] **Output:** 2500.00000 **Explanation:** Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 **Example 2:** **Input:** salary = [1000,2000,3000] **Output:** 2000.00000 **Explanation:** Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 **Constraints:** * `3 <= salary.length <= 100` * `1000 <= salary[i] <= 106` * All the integers of `salary` are **unique**.","completion":"def count_prefix_aligned(flips): count = 0 for i in range(len(flips)): if flips[i] == i + 1: count += 1 return count"},{"prompt":"Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. **Example 1:** **Input:** n = 5 **Output:** true **Explanation:** The binary representation of 5 is: 101 **Example 2:** **Input:** n = 7 **Output:** false **Explanation:** The binary representation of 7 is: 111. **Example 3:** **Input:** n = 11 **Output:** false **Explanation:** The binary representation of 11 is: 1011. **Constraints:** * `1 <= n <= 231 1`","completion":"def has_alternating_bits(n): prev_bit = n % 2 n //= 2 while n > 0: curr_bit = n % 2 if curr_bit == prev_bit: return False prev_bit = curr_bit n //= 2 return True"},{"prompt":"Given an integer array `nums` and two integers `firstLen` and `secondLen`, return _the maximum sum of elements in two nonoverlapping **subarrays** with lengths_ `firstLen` _and_ `secondLen`. The array with length `firstLen` could occur before or after the array with length `secondLen`, but they have to be nonoverlapping. A **subarray** is a **contiguous** part of an array. **Example 1:** **Input:** nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2 **Output:** 20 **Explanation:** One choice of subarrays is [9] with length 1, and [6,5] with length 2. **Example 2:** **Input:** nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2 **Output:** 29 **Explanation:** One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2. **Example 3:** **Input:** nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3 **Output:** 31 **Explanation:** One choice of subarrays is [5,6,0,9] with length 4, and [0,3,8] with length 3. **Constraints:** * `1 <= firstLen, secondLen <= 1000` * `2 <= firstLen + secondLen <= 1000` * `firstLen + secondLen <= nums.length <= 1000` * `0 <= nums[i] <= 1000`","completion":"def add_to_array_form(num, k): for i in range(len(num) - 1, -1, -1): k, num[i] = divmod(num[i] + k, 10) if k == 0: break while k: k, digit = divmod(k, 10) num.insert(0, digit) return num"},{"prompt":"Given two positive integers `left` and `right`, find the two integers `num1` and `num2` such that: * `left <= nums1 < nums2 <= right` . * `nums1` and `nums2` are both **prime** numbers. * `nums2 nums1` is the **minimum** amongst all other pairs satisfying the above conditions. Return _the positive integer array_ `ans = [nums1, nums2]`. _If there are multiple pairs satisfying these conditions, return the one with the minimum_ `nums1` _value or_ `[1, 1]` _if such numbers do not exist._ A number greater than `1` is called **prime** if it is only divisible by `1` and itself. **Example 1:** **Input:** left = 10, right = 19 **Output:** [11,13] **Explanation:** The prime numbers between 10 and 19 are 11, 13, 17, and 19. The closest gap between any pair is 2, which can be achieved by [11,13] or [17,19]. Since 11 is smaller than 17, we return the first pair. **Example 2:** **Input:** left = 4, right = 6 **Output:** [1,1] **Explanation:** There exists only one prime number in the given range, so the conditions cannot be satisfied. **Constraints:** * `1 <= left <= right <= 106` .spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; fontsize:150%; fontweight: bold; color:#000000; backgroundcolor:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {webkittransition: all 0s ease;moztransition: margin 0s ease;otransition: all 0s ease;transition: margin 0s ease;} .spoilerbutton[value=Show Message] + .spoiler > div {margintop:500%;} .spoilerbutton[value=Hide Message] + .spoiler {padding:5px;}","completion":"def is_prime(n): if n <= 1: return False i = 2 while i * i <= n: if n % i == 0: return False i += 1 return True def closest_prime_pair(left, right): min_dist = right - left + 1 ans = [-1, -1] for i in range(left, right + 1): if is_prime(i): for j in range(i + 1, right + 1): if is_prime(j) and j - i < min_dist: min_dist = j - i ans = [i, j] return ans"},{"prompt":"You are given an integer array `nums` and an integer `k`. For each index `i` where `0 <= i < nums.length`, change `nums[i]` to be either `nums[i] + k` or `nums[i] k`. The **score** of `nums` is the difference between the maximum and minimum elements in `nums`. Return _the minimum **score** of_ `nums` _after changing the values at each index_. **Example 1:** **Input:** nums = [1], k = 0 **Output:** 0 **Explanation:** The score is max(nums) min(nums) = 1 1 = 0. **Example 2:** **Input:** nums = [0,10], k = 2 **Output:** 6 **Explanation:** Change nums to be [2, 8]. The score is max(nums) min(nums) = 8 2 = 6. **Example 3:** **Input:** nums = [1,3,6], k = 3 **Output:** 3 **Explanation:** Change nums to be [4, 6, 3]. The score is max(nums) min(nums) = 6 3 = 3. **Constraints:** * `1 <= nums.length <= 104` * `0 <= nums[i] <= 104` * `0 <= k <= 104`","completion":"def nthMagicalNumber(n, a, b): mod = 1000000007 lcm = a * b // gcd(a, b) left, right = 1, 10**14 while left < right: mid = left + (right - left) // 2 if (mid // a + mid // b - mid // lcm) < n: left = mid + 1 else: right = mid return left % mod def gcd(a, b): return a if b == 0 else gcd(b, a % b)"},{"prompt":"You are given a **0indexed** integer array `nums` representing the contents of a **pile**, where `nums[0]` is the topmost element of the pile. In one move, you can perform **either** of the following: * If the pile is not empty, **remove** the topmost element of the pile. * If there are one or more removed elements, **add** any one of them back onto the pile. This element becomes the new topmost element. You are also given an integer `k`, which denotes the total number of moves to be made. Return _the **maximum value** of the topmost element of the pile possible after **exactly**_ `k` _moves_. In case it is not possible to obtain a nonempty pile after `k` moves, return `1`. **Example 1:** **Input:** nums = [5,2,2,4,0,6], k = 4 **Output:** 5 **Explanation:** One of the ways we can end with 5 at the top of the pile after 4 moves is as follows: Step 1: Remove the topmost element = 5. The pile becomes [2,2,4,0,6]. Step 2: Remove the topmost element = 2. The pile becomes [2,4,0,6]. Step 3: Remove the topmost element = 2. The pile becomes [4,0,6]. Step 4: Add 5 back onto the pile. The pile becomes [5,4,0,6]. Note that this is not the only way to end with 5 at the top of the pile. It can be shown that 5 is the largest answer possible after 4 moves. **Example 2:** **Input:** nums = [2], k = 1 **Output:** 1 **Explanation:** In the first move, our only option is to pop the topmost element of the pile. Since it is not possible to obtain a nonempty pile after one move, we return 1. **Constraints:** * `1 <= nums.length <= 105` * `0 <= nums[i], k <= 109`","completion":"def to_base_k(num, k): base_k_num = \'\' while num: base_k_num = str(num % k) + base_k_num num //= k return base_k_num def is_k_mirror(num, k): base_10_num = str(num) base_k_num = to_base_k(num, k) return base_10_num == base_10_num[::-1] and base_k_num == base_k_num[::-1] def sum_k_mirror_numbers(k, n): total = 0 num = 0 while n: if is_k_mirror(num, k): total += num n -= 1 num += 1 return total"},{"prompt":"You are given a string `s` consisting of lowercase letters and an integer `k`. We call a string `t` **ideal** if the following conditions are satisfied: * `t` is a **subsequence** of the string `s`. * The absolute difference in the alphabet order of every two **adjacent** letters in `t` is less than or equal to `k`. Return _the length of the **longest** ideal string_. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. **Note** that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of `\'a\'` and `\'z\'` is `25`, not `1`. **Example 1:** **Input:** s = acfgbd , k = 2 **Output:** 4 **Explanation:** The longest ideal string is acbd . The length of this string is 4, so 4 is returned. Note that acfgbd is not ideal because \'c\' and \'f\' have a difference of 3 in alphabet order. **Example 2:** **Input:** s = abcd , k = 3 **Output:** 4 **Explanation:** The longest ideal string is abcd . The length of this string is 4, so 4 is returned. **Constraints:** * `1 <= s.length <= 105` * `0 <= k <= 25` * `s` consists of lowercase English letters.","completion":"def longest_ideal_string(s: str, k: int) -> int: dp = [0] * 26 for c in s: current = 1 for i in range(26): if abs(i - (ord(c) - ord(\'a\'))) <= k: current = max(current, dp[i] + 1) dp[ord(c) - ord(\'a\')] = max(dp[ord(c) - ord(\'a\')], current) return max(dp)"},{"prompt":"You are given a **0indexed** integer array `nums`, where `nums[i]` is a digit between `0` and `9` (**inclusive**). The **triangular sum** of `nums` is the value of the only element present in `nums` after the following process terminates: 1. Let `nums` comprise of `n` elements. If `n == 1`, **end** the process. Otherwise, **create** a new **0indexed** integer array `newNums` of length `n 1`. 2. For each index `i`, where `0 <= i < n 1`, **assign** the value of `newNums[i]` as `(nums[i] + nums[i+1]) % 10`, where `%` denotes modulo operator. 3. **Replace** the array `nums` with `newNums`. 4. **Repeat** the entire process starting from step 1. Return _the triangular sum of_ `nums`. **Example 1:** **Input:** nums = [1,2,3,4,5] **Output:** 8 **Explanation:** The above diagram depicts the process from which we obtain the triangular sum of the array. **Example 2:** **Input:** nums = [5] **Output:** 5 **Explanation:** Since there is only one element in nums, the triangular sum is the value of that element itself. **Constraints:** * `1 <= nums.length <= 1000` * `0 <= nums[i] <= 9`","completion":"def is_valid_parentheses_string(s: str, locked: str) -> bool: balance = 0 for i in range(len(s)): if locked[i] == \'0\': balance += 1 if s[i] == \'(\' else -1 if balance < 0: return False return balance == 0"},{"prompt":"You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`. Return _a list of integers representing the size of these parts_. **Example 1:** **Input:** s = ababcbacadefegdehijhklij **Output:** [9,7,8] **Explanation:** The partition is ababcbaca , defegde , hijhklij . This is a partition so that each letter appears in at most one part. A partition like ababcbacadefegde , hijhklij is incorrect, because it splits s into less parts. **Example 2:** **Input:** s = eccbbbbdec **Output:** [10] **Constraints:** * `1 <= s.length <= 500` * `s` consists of lowercase English letters.","completion":"def partition_labels(s): last = {c: i for i, c in enumerate(s)} ans = [] j = anchor = 0 for i, c in enumerate(s): j = max(j, last[c]) if i == j: ans.append(i - anchor + 1) anchor = i + 1 return ans"},{"prompt":"You are playing a game that has `n` levels numbered from `0` to `n 1`. You are given a **0indexed** integer array `damage` where `damage[i]` is the amount of health you will lose to complete the `ith` level. You are also given an integer `armor`. You may use your armor ability **at most once** during the game on **any** level which will protect you from **at most** `armor` damage. You must complete the levels in order and your health must be **greater than** `0` at all times to beat the game. Return _the **minimum** health you need to start with to beat the game._ **Example 1:** **Input:** damage = [2,7,4,3], armor = 4 **Output:** 13 **Explanation:** One optimal way to beat the game starting at 13 health is: On round 1, take 2 damage. You have 13 2 = 11 health. On round 2, take 7 damage. You have 11 7 = 4 health. On round 3, use your armor to protect you from 4 damage. You have 4 0 = 4 health. On round 4, take 3 damage. You have 4 3 = 1 health. Note that 13 is the minimum health you need to start with to beat the game. **Example 2:** **Input:** damage = [2,5,3,4], armor = 7 **Output:** 10 **Explanation:** One optimal way to beat the game starting at 10 health is: On round 1, take 2 damage. You have 10 2 = 8 health. On round 2, use your armor to protect you from 5 damage. You have 8 0 = 8 health. On round 3, take 3 damage. You have 8 3 = 5 health. On round 4, take 4 damage. You have 5 4 = 1 health. Note that 10 is the minimum health you need to start with to beat the game. **Example 3:** **Input:** damage = [3,3,3], armor = 0 **Output:** 10 **Explanation:** One optimal way to beat the game starting at 10 health is: On round 1, take 3 damage. You have 10 3 = 7 health. On round 2, take 3 damage. You have 7 3 = 4 health. On round 3, take 3 damage. You have 4 3 = 1 health. Note that you did not use your armor ability. **Constraints:** * `n == damage.length` * `1 <= n <= 105` * `0 <= damage[i] <= 105` * `0 <= armor <= 105`","completion":"def min_health(damage, armor): health = 0 for dmg in reversed(damage): health += dmg if health > armor: health -= armor armor = 0 return health + 1"},{"prompt":"Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows: Given an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at. You should perform the cuts in order, you can change the order of the cuts as you wish. The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation. Return _the minimum total cost_ of the cuts. **Example 1:** **Input:** n = 7, cuts = [1,3,4,5] **Output:** 16 **Explanation:** Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario: The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20. Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16). **Example 2:** **Input:** n = 9, cuts = [5,6,1,4,2] **Output:** 22 **Explanation:** If you try the given cuts ordering the cost will be 25. There are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible. **Constraints:** * `2 <= n <= 106` * `1 <= cuts.length <= min(n 1, 100)` * `1 <= cuts[i] <= n 1` * All the integers in `cuts` array are **distinct**.","completion":"def destCity(paths): starting_cities = set() for path in paths: starting_cities.add(path[0]) for path in paths: if path[1] not in starting_cities: return path[1] return \\"\\""},{"prompt":"You are given an **even** number of people `numPeople` that stand around a circle and each person shakes hands with someone else so that there are `numPeople / 2` handshakes total. Return _the number of ways these handshakes could occur such that none of the handshakes cross_. Since the answer could be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** numPeople = 4 **Output:** 2 **Explanation:** There are two ways to do it, the first way is [(1,2),(3,4)] and the second one is [(2,3),(4,1)]. **Example 2:** **Input:** numPeople = 6 **Output:** 5 **Constraints:** * `2 <= numPeople <= 1000` * `numPeople` is even.","completion":"def numberOfWays(numPeople: int) -> int: MOD = 1000000007 dp = [0] * (numPeople // 2 + 1) dp[0] = 1 for i in range(1, numPeople // 2 + 1): for j in range(1, i + 1): dp[i] = (dp[i] + dp[i - j] * dp[j - 1]) % MOD return dp[numPeople // 2]"},{"prompt":"Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is **maximized**. Return _the maximized sum_. **Example 1:** **Input:** nums = [1,4,3,2] **Output:** 4 **Explanation:** All possible pairings (ignoring the ordering of elements) are: 1. (1, 4), (2, 3) > min(1, 4) + min(2, 3) = 1 + 2 = 3 2. (1, 3), (2, 4) > min(1, 3) + min(2, 4) = 1 + 2 = 3 3. (1, 2), (3, 4) > min(1, 2) + min(3, 4) = 1 + 3 = 4 So the maximum possible sum is 4. **Example 2:** **Input:** nums = [6,2,6,5,1,2] **Output:** 9 **Explanation:** The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9. **Constraints:** * `1 <= n <= 104` * `nums.length == 2 * n` * `104 <= nums[i] <= 104`","completion":"def array_pair_sum(nums): nums.sort() return sum(nums[::2])"},{"prompt":"A **valid cut** in a circle can be: * A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or * A cut that is represented by a straight line that touches one point on the edge of the circle and its center. Some valid and invalid cuts are shown in the figures below. Given the integer `n`, return _the **minimum** number of cuts needed to divide a circle into_ `n` _equal slices_. **Example 1:** **Input:** n = 4 **Output:** 2 **Explanation:** The above figure shows how cutting the circle twice through the middle divides it into 4 equal slices. **Example 2:** **Input:** n = 3 **Output:** 3 **Explanation:** At least 3 cuts are needed to divide the circle into 3 equal slices. It can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape. Also note that the first cut will not divide the circle into distinct parts. **Constraints:** * `1 <= n <= 100`","completion":"def min_cuts(n): if n % 2 == 0: return n // 2 else: return n"},{"prompt":"There is an **undirected** graph consisting of `n` nodes numbered from `1` to `n`. You are given the integer `n` and a **2D** array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi`. The graph can be disconnected. You can add **at most** two additional edges (possibly none) to this graph so that there are no repeated edges and no selfloops. Return `true` _if it is possible to make the degree of each node in the graph even, otherwise return_ `false`_._ The degree of a node is the number of edges connected to it. **Example 1:** **Input:** n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]] **Output:** true **Explanation:** The above diagram shows a valid way of adding an edge. Every node in the resulting graph is connected to an even number of edges. **Example 2:** **Input:** n = 4, edges = [[1,2],[3,4]] **Output:** true **Explanation:** The above diagram shows a valid way of adding two edges. **Example 3:** **Input:** n = 4, edges = [[1,2],[1,3],[1,4]] **Output:** false **Explanation:** It is not possible to obtain a valid graph with adding at most 2 edges. **Constraints:** * `3 <= n <= 105` * `2 <= edges.length <= 105` * `edges[i].length == 2` * `1 <= ai, bi <= n` * `ai != bi` * There are no repeated edges.","completion":"from collections import defaultdict def possible_degree_even(n, edges): degrees = defaultdict(int) for a, b in edges: degrees[a] += 1 degrees[b] += 1 odd_degrees = sum(1 for d in range(1, n + 1) if degrees[d] % 2 != 0) return odd_degrees == 0 or odd_degrees == 2"},{"prompt":"Given an integer array `nums` and an integer `k`, return `true` if it is possible to divide this array into `k` nonempty subsets whose sums are all equal. **Example 1:** **Input:** nums = [4,3,2,3,5,2,1], k = 4 **Output:** true **Explanation:** It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. **Example 2:** **Input:** nums = [1,2,3,4], k = 3 **Output:** false **Constraints:** * `1 <= k <= nums.length <= 16` * `1 <= nums[i] <= 104` * The frequency of each element is in the range `[1, 4]`.","completion":"def canPartitionKSubsets(nums, k): total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k visited = [False] * len(nums) return dfs(nums, visited, 0, target, 0, k) def dfs(nums, visited, start, target, curr_sum, k): if k == 1: return True if curr_sum == target: return dfs(nums, visited, 0, target, 0, k - 1) for i in range(start, len(nums)): if not visited[i] and curr_sum + nums[i] <= target: visited[i] = True if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k): return True visited[i] = False return False"},{"prompt":"There is a **binary** tree rooted at `0` consisting of `n` nodes. The nodes are labeled from `0` to `n 1`. You are given a **0indexed** integer array `parents` representing the tree, where `parents[i]` is the parent of node `i`. Since node `0` is the root, `parents[0] == 1`. Each node has a **score**. To find the score of a node, consider if the node and the edges connected to it were **removed**. The tree would become one or more **nonempty** subtrees. The **size** of a subtree is the number of the nodes in it. The **score** of the node is the **product of the sizes** of all those subtrees. Return _the **number** of nodes that have the **highest score**_. **Example 1:** **Input:** parents = [1,2,0,2,0] **Output:** 3 **Explanation:** The score of node 0 is: 3 * 1 = 3 The score of node 1 is: 4 = 4 The score of node 2 is: 1 * 1 * 2 = 2 The score of node 3 is: 4 = 4 The score of node 4 is: 4 = 4 The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score. **Example 2:** **Input:** parents = [1,2,0] **Output:** 2 **Explanation:** The score of node 0 is: 2 = 2 The score of node 1 is: 2 = 2 The score of node 2 is: 1 * 1 = 1 The highest score is 2, and two nodes (node 0 and node 1) have the highest score. **Constraints:** * `n == parents.length` * `2 <= n <= 105` * `parents[0] == 1` * `0 <= parents[i] <= n 1` for `i != 0` * `parents` represents a valid binary tree.","completion":"def eliminate_monsters(dist, speed): n = len(dist) time_to_reach = sorted(dist[i] / speed[i] for i in range(n)) monsters_eliminated = 0 for time in time_to_reach: if monsters_eliminated < time: monsters_eliminated += 1 return monsters_eliminated"},{"prompt":"Given an array of integers `nums`, calculate the **pivot index** of this array. The **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index\'s right. If the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array. Return _the **leftmost pivot index**_. If no such index exists, return `1`. **Example 1:** **Input:** nums = [1,7,3,6,5,6] **Output:** 3 **Explanation:** The pivot index is 3. Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 Right sum = nums[4] + nums[5] = 5 + 6 = 11 **Example 2:** **Input:** nums = [1,2,3] **Output:** 1 **Explanation:** There is no index that satisfies the conditions in the problem statement. **Example 3:** **Input:** nums = [2,1,1] **Output:** 0 **Explanation:** The pivot index is 0. Left sum = 0 (no elements to the left of index 0) Right sum = nums[1] + nums[2] = 1 + 1 = 0 **Constraints:** * `1 <= nums.length <= 104` * `1000 <= nums[i] <= 1000` **Note:** This question is the same as 1991: [https://leetcode.com/problems/findthemiddleindexinarray/](https://leetcode.com/problems/findthemiddleindexinarray/)","completion":"def pivotIndex(nums): total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == total_sum - left_sum - num: return i left_sum += num return -1"},{"prompt":"You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target. We will send a signal from a given node `k`. Return _the **minimum** time it takes for all the_ `n` _nodes to receive the signal_. If it is impossible for all the `n` nodes to receive the signal, return `1`. **Example 1:** **Input:** times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 **Output:** 2 **Example 2:** **Input:** times = [[1,2,1]], n = 2, k = 1 **Output:** 1 **Example 3:** **Input:** times = [[1,2,1]], n = 2, k = 2 **Output:** 1 **Constraints:** * `1 <= k <= n <= 100` * `1 <= times.length <= 6000` * `times[i].length == 3` * `1 <= ui, vi <= n` * `ui != vi` * `0 <= wi <= 100` * All the pairs `(ui, vi)` are **unique**. (i.e., no multiple edges.)","completion":"import heapq def networkDelayTime(times, n, k): graph = {i: [] for i in range(1, n+1)} for u, v, w in times: graph[u].append((v, w)) dist = {u: float(\'inf\') for u in range(1, n+1)} dist[k] = 0 pq = [(0, k)] while pq: curr_dist, u = heapq.heappop(pq) for v, weight in graph[u]: new_dist = curr_dist + weight if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(pq, (new_dist, v)) max_time = max(dist.values()) return max_time if max_time < float(\'inf\') else -1"},{"prompt":"You are given a **0indexed** array `arr` consisting of `n` positive integers, and a positive integer `k`. The array `arr` is called **Kincreasing** if `arr[ik] <= arr[i]` holds for every index `i`, where `k <= i <= n1`. * For example, `arr = [4, 1, 5, 2, 6, 2]` is Kincreasing for `k = 2` because: * `arr[0] <= arr[2] (4 <= 5)` * `arr[1] <= arr[3] (1 <= 2)` * `arr[2] <= arr[4] (5 <= 6)` * `arr[3] <= arr[5] (2 <= 2)` * However, the same `arr` is not Kincreasing for `k = 1` (because `arr[0] > arr[1]`) or `k = 3` (because `arr[0] > arr[3]`). In one **operation**, you can choose an index `i` and **change** `arr[i]` into **any** positive integer. Return _the **minimum number of operations** required to make the array Kincreasing for the given_ `k`. **Example 1:** **Input:** arr = [5,4,3,2,1], k = 1 **Output:** 4 **Explanation:** For k = 1, the resultant array has to be nondecreasing. Some of the Kincreasing arrays that can be formed are [5,**6**,**7**,**8**,**9**], [**1**,**1**,**1**,**1**,1], [**2**,**2**,3,**4**,**4**]. All of them require 4 operations. It is suboptimal to change the array to, for example, [**6**,**7**,**8**,**9**,**10**] because it would take 5 operations. It can be shown that we cannot make the array Kincreasing in less than 4 operations. **Example 2:** **Input:** arr = [4,1,5,2,6,2], k = 2 **Output:** 0 **Explanation:** This is the same example as the one in the problem description. Here, for every index i where 2 <= i <= 5, arr[i2] <= arr[i]. Since the given array is already Kincreasing, we do not need to perform any operations. **Example 3:** **Input:** arr = [4,1,5,2,6,2], k = 3 **Output:** 2 **Explanation:** Indices 3 and 5 are the only ones not satisfying arr[i3] <= arr[i] for 3 <= i <= 5. One of the ways we can make the array Kincreasing is by changing arr[3] to 4 and arr[5] to 5. The array will now be [4,1,5,**4**,6,**5**]. Note that there can be other ways to make the array Kincreasing, but none of them require less than 2 operations. **Constraints:** * `1 <= arr.length <= 105` * `1 <= arr[i], k <= arr.length`","completion":"def minOperations(arr, k): dp = [0] * len(arr) for i in range(k, len(arr)): dp[i] = max(dp[i - k] + 1 - (arr[i] - arr[i - k]), 0) return sum(dp)"},{"prompt":"Given an integer `n` (in base `10`) and a base `k`, return _the **sum** of the digits of_ `n` _**after** converting_ `n` _from base_ `10` _to base_ `k`. After converting, each digit should be interpreted as a base `10` number, and the sum should be returned in base `10`. **Example 1:** **Input:** n = 34, k = 6 **Output:** 9 **Explanation:** 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9. **Example 2:** **Input:** n = 10, k = 10 **Output:** 1 **Explanation:** n is already in base 10. 1 + 0 = 1. **Constraints:** * `1 <= n <= 100` * `2 <= k <= 10`","completion":"def sum_base(n: int, k: int) -> int: s = 0 while n: s += n % k n //= k return s"},{"prompt":"Given two strings `s` and `t`, return `true` _if they are equal when both are typed into empty text editors_. `\'#\'` means a backspace character. Note that after backspacing an empty text, the text will continue empty. **Example 1:** **Input:** s = ab#c , t = ad#c **Output:** true **Explanation:** Both s and t become ac . **Example 2:** **Input:** s = ab , t = c#d# **Output:** true **Explanation:** Both s and t become . **Example 3:** **Input:** s = a#c , t = b **Output:** false **Explanation:** s becomes c while t becomes b . **Constraints:** * `1 <= s.length, t.length <= 200` * `s` and `t` only contain lowercase letters and `\'#\'` characters.","completion":"def backspaceCompare(s: str, t: str) -> bool: i, j = len(s) - 1, len(t) - 1 while True: back = 0 while i >= 0 and (back > 0 or s[i] == \'#\'): back = back + 1 if s[i] == \'#\' else back - 1 i -= 1 back = 0 while j >= 0 and (back > 0 or t[j] == \'#\'): back = back + 1 if t[j] == \'#\' else back - 1 j -= 1 if i >= 0 and j >= 0 and s[i] == t[j]: i, j = i - 1, j - 1 else: return i == -1 and j == -1"},{"prompt":"You are given a **0indexed** array `nums` that consists of `n` **distinct** positive integers. Apply `m` operations to this array, where in the `ith` operation you replace the number `operations[i][0]` with `operations[i][1]`. It is guaranteed that in the `ith` operation: * `operations[i][0]` **exists** in `nums`. * `operations[i][1]` does **not** exist in `nums`. Return _the array obtained after applying all the operations_. **Example 1:** **Input:** nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]] **Output:** [3,2,7,1] **Explanation:** We perform the following operations on nums: Replace the number 1 with 3. nums becomes [**3**,2,4,6]. Replace the number 4 with 7. nums becomes [3,2,**7**,6]. Replace the number 6 with 1. nums becomes [3,2,7,**1**]. We return the final array [3,2,7,1]. **Example 2:** **Input:** nums = [1,2], operations = [[1,3],[2,1],[3,2]] **Output:** [2,1] **Explanation:** We perform the following operations to nums: Replace the number 1 with 3. nums becomes [**3**,2]. Replace the number 2 with 1. nums becomes [3,**1**]. Replace the number 3 with 2. nums becomes [**2**,1]. We return the array [2,1]. **Constraints:** * `n == nums.length` * `m == operations.length` * `1 <= n, m <= 105` * All the values of `nums` are **distinct**. * `operations[i].length == 2` * `1 <= nums[i], operations[i][0], operations[i][1] <= 106` * `operations[i][0]` will exist in `nums` when applying the `ith` operation. * `operations[i][1]` will not exist in `nums` when applying the `ith` operation.","completion":"def min_race_time(tires, changeTime, numLaps): n = len(tires) times = [fi + (numLaps - 1) * ri for fi, ri in tires] min_time = min(times) + (numLaps - 1) * changeTime for i in range(n): for j in range(n): if i != j: min_time = min(min_time, times[i] + times[j] - tires[i][0] + (numLaps - 2) * changeTime) return min_time"},{"prompt":"Given an integer array `nums`, return the sum of `floor(nums[i] / nums[j])` for all pairs of indices `0 <= i, j < nums.length` in the array. Since the answer may be too large, return it **modulo** `109 + 7`. The `floor()` function returns the integer part of the division. **Example 1:** **Input:** nums = [2,5,9] **Output:** 10 **Explanation:** floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0 floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1 floor(5 / 2) = 2 floor(9 / 2) = 4 floor(9 / 5) = 1 We calculate the floor of the division for every pair of indices in the array then sum them up. **Example 2:** **Input:** nums = [7,7,7,7,7,7,7] **Output:** 49 **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 105`","completion":"def sum_of_floored_pairs(nums): MOD = 10**9 + 7 n = len(nums) max_element = max(nums) cnt = [0] * (max_element + 1) for num in nums: cnt[num] += 1 for i in range(1, max_element + 1): cnt[i] += cnt[i - 1] res = 0 for num in nums: j, k = 1, 1 while k <= max_element: res += j * (cnt[min(k + num - 1, max_element)] - cnt[k - 1]) res %= MOD j += 1 k += num return res"},{"prompt":"Given an array `arr`, replace every element in that array with the greatest element among the elements to its right, and replace the last element with `1`. After doing so, return the array. **Example 1:** **Input:** arr = [17,18,5,4,6,1] **Output:** [18,6,6,6,1,1] **Explanation:** index 0 > the greatest element to the right of index 0 is index 1 (18). index 1 > the greatest element to the right of index 1 is index 4 (6). index 2 > the greatest element to the right of index 2 is index 4 (6). index 3 > the greatest element to the right of index 3 is index 4 (6). index 4 > the greatest element to the right of index 4 is index 5 (1). index 5 > there are no elements to the right of index 5, so we put 1. **Example 2:** **Input:** arr = [400] **Output:** [1] **Explanation:** There are no elements to the right of index 0. **Constraints:** * `1 <= arr.length <= 104` * `1 <= arr[i] <= 105`","completion":"def kConcatenationMaxSum(arr, k): M = 10**9 + 7 s = sum(arr) max_sum = max_ending_here = 0 for i in range(len(arr) * min(2, k)): max_ending_here = max(arr[i % len(arr)], max_ending_here + arr[i % len(arr)]) max_sum = max(max_sum, max_ending_here) return 0 if k == 1 else (((max_sum - max_ending_here) % M) * (k - 2) % M + max_ending_here) % M"},{"prompt":"Given an `n x n` binary `grid`, in one step you can choose two **adjacent rows** of the grid and swap them. A grid is said to be **valid** if all the cells above the main diagonal are **zeros**. Return _the minimum number of steps_ needed to make the grid valid, or **1** if the grid cannot be valid. The main diagonal of a grid is the diagonal that starts at cell `(1, 1)` and ends at cell `(n, n)`. **Example 1:** **Input:** grid = [[0,0,1],[1,1,0],[1,0,0]] **Output:** 3 **Example 2:** **Input:** grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]] **Output:** 1 **Explanation:** All rows are similar, swaps have no effect on the grid. **Example 3:** **Input:** grid = [[1,0,0],[1,1,0],[1,1,1]] **Output:** 0 **Constraints:** * `n == grid.length` `== grid[i].length` * `1 <= n <= 200` * `grid[i][j]` is either `0` or `1`","completion":"def minSwaps(grid): n = len(grid) steps = 0 for i in range(n): row = -1 for j in range(i, n): if grid[j][i] == 0: row = j break if row == -1: return -1 while row > i: grid[row], grid[row - 1] = grid[row - 1], grid[row] steps += 1 row -= 1 return steps"},{"prompt":"You have a keyboard layout as shown above in the **XY** plane, where each English uppercase letter is located at some coordinate. * For example, the letter `\'A\'` is located at coordinate `(0, 0)`, the letter `\'B\'` is located at coordinate `(0, 1)`, the letter `\'P\'` is located at coordinate `(2, 3)` and the letter `\'Z\'` is located at coordinate `(4, 1)`. Given the string `word`, return _the minimum total **distance** to type such string using only two fingers_. The **distance** between coordinates `(x1, y1)` and `(x2, y2)` is `|x1 x2| + |y1 y2|`. **Note** that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters. **Example 1:** **Input:** word = CAKE **Output:** 3 **Explanation:** Using two fingers, one optimal way to type CAKE is: Finger 1 on letter \'C\' > cost = 0 Finger 1 on letter \'A\' > cost = Distance from letter \'C\' to letter \'A\' = 2 Finger 2 on letter \'K\' > cost = 0 Finger 2 on letter \'E\' > cost = Distance from letter \'K\' to letter \'E\' = 1 Total distance = 3 **Example 2:** **Input:** word = HAPPY **Output:** 6 **Explanation:** Using two fingers, one optimal way to type HAPPY is: Finger 1 on letter \'H\' > cost = 0 Finger 1 on letter \'A\' > cost = Distance from letter \'H\' to letter \'A\' = 2 Finger 2 on letter \'P\' > cost = 0 Finger 2 on letter \'P\' > cost = Distance from letter \'P\' to letter \'P\' = 0 Finger 1 on letter \'Y\' > cost = Distance from letter \'A\' to letter \'Y\' = 4 Total distance = 6 **Constraints:** * `2 <= word.length <= 300` * `word` consists of uppercase English letters.","completion":"def removeDuplicates(s: str, k: int) -> str: stack = [] for c in s: if stack and stack[-1][0] == c: stack[-1][1] += 1 if stack[-1][1] == k: stack.pop() else: stack.append([c, 1]) return \'\'.join(c * n for c, n in stack)"},{"prompt":"Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a nonnegative integer `n` that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks. Return _the least number of units of times that the CPU will take to finish all the given tasks_. **Example 1:** **Input:** tasks = [ A , A , A , B , B , B ], n = 2 **Output:** 8 **Explanation:** A > B > idle > A > B > idle > A > B There is at least 2 units of time between any two same tasks. **Example 2:** **Input:** tasks = [ A , A , A , B , B , B ], n = 0 **Output:** 6 **Explanation:** On this case any permutation of size 6 would work since n = 0. [ A , A , A , B , B , B ] [ A , B , A , B , A , B ] [ B , B , B , A , A , A ] ... And so on. **Example 3:** **Input:** tasks = [ A , A , A , A , A , A , B , C , D , E , F , G ], n = 2 **Output:** 16 **Explanation:** One possible solution is A > B > C > A > D > E > A > F > G > A > idle > idle > A > idle > idle > A **Constraints:** * `1 <= task.length <= 104` * `tasks[i]` is uppercase English letter. * The integer `n` is in the range `[0, 100]`.","completion":"from collections import Counter def least_interval(tasks, n): task_freq = Counter(tasks) max_f = max(task_freq.values()) max_count = sum(1 for count in task_freq.values() if count == max_f) return max(len(tasks), (max_f - 1) * (n + 1) + max_count)"},{"prompt":"an alien language, surprisingly, they also use English lowercase letters, but possibly in a different `order`. The `order` of the alphabet is some permutation of lowercase letters. Given a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographically in this alien language. **Example 1:** **Input:** words = [ hello , leetcode ], order = hlabcdefgijkmnopqrstuvwxyz **Output:** true **Explanation:** As \'h\' comes before \'l\' in this language, then the sequence is sorted. **Example 2:** **Input:** words = [ word , world , row ], order = worldabcefghijkmnpqstuvxyz **Output:** false **Explanation:** As \'d\' comes after \'l\' in this language, then words[0] > words[1], hence the sequence is unsorted. **Example 3:** **Input:** words = [ apple , app ], order = abcdefghijklmnopqrstuvwxyz **Output:** false **Explanation:** The first three characters app match, and the second string is shorter (in size.) According to lexicographical rules apple > app , because \'l\' > \'∅\', where \'∅\' is defined as the blank character which is less than any other character ([More info](https://en.wikipedia.org/wiki/Lexicographical_order)). **Constraints:** * `1 <= words.length <= 100` * `1 <= words[i].length <= 20` * `order.length == 26` * All characters in `words[i]` and `order` are English lowercase letters.","completion":"def reverse_string(s): return s[::-1]"},{"prompt":"Given an integer array `nums` of **positive** integers, return _the average value of all even integers that are divisible by_ `3`_._ Note that the **average** of `n` elements is the **sum** of the `n` elements divided by `n` and **rounded down** to the nearest integer. **Example 1:** **Input:** nums = [1,3,6,10,12,15] **Output:** 9 **Explanation:** 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9. **Example 2:** **Input:** nums = [1,2,4,7,10] **Output:** 0 **Explanation:** There is no single number that satisfies the requirement, so return 0. **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i] <= 1000`","completion":"def average_even_divisible_by_three(nums): total = 0 count = 0 for num in nums: if num % 2 == 0 and num % 3 == 0: total += num count += 1 return total // count if count > 0 else 0"},{"prompt":"There are `n` piles of `stones` arranged in a row. The `ith` pile has `stones[i]` stones. A move consists of merging exactly `k` **consecutive** piles into one pile, and the cost of this move is equal to the total number of stones in these `k` piles. Return _the minimum cost to merge all piles of stones into one pile_. If it is impossible, return `1`. **Example 1:** **Input:** stones = [3,2,4,1], k = 2 **Output:** 20 **Explanation:** We start with [3, 2, 4, 1]. We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1]. We merge [4, 1] for a cost of 5, and we are left with [5, 5]. We merge [5, 5] for a cost of 10, and we are left with [10]. The total cost was 20, and this is the minimum possible. **Example 2:** **Input:** stones = [3,2,4,1], k = 3 **Output:** 1 **Explanation:** After any merge operation, there are 2 piles left, and we can\'t merge anymore. So the task is impossible. **Example 3:** **Input:** stones = [3,5,1,2,6], k = 3 **Output:** 25 **Explanation:** We start with [3, 5, 1, 2, 6]. We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6]. We merge [3, 8, 6] for a cost of 17, and we are left with [17]. The total cost was 25, and this is the minimum possible. **Constraints:** * `n == stones.length` * `1 <= n <= 30` * `1 <= stones[i] <= 100` * `2 <= k <= 30`","completion":"def min_deletion_size(strs): rows, cols = len(strs), len(strs[0]) count = 0 for c in range(cols): for r in range(1, rows): if strs[r - 1][c] > strs[r][c]: count += 1 break return count"},{"prompt":"You are given a string `time` in the form of `hh:mm`, where some of the digits in the string are hidden (represented by `?`). The valid times are those inclusively between `00:00` and `23:59`. Return _the latest valid time you can get from_ `time` _by replacing the hidden_ _digits_. **Example 1:** **Input:** time = 2?:?0 **Output:** 23:50 **Explanation:** The latest hour beginning with the digit \'2\' is 23 and the latest minute ending with the digit \'0\' is 50. **Example 2:** **Input:** time = 0?:3? **Output:** 09:39 **Example 3:** **Input:** time = 1?:22 **Output:** 19:22 **Constraints:** * `time` is in the format `hh:mm`. * It is guaranteed that you can produce a valid time from the given string.","completion":"def maximumTime(time: str) -> str: time_list = list(time) if time_list[0] == \'?\': time_list[0] = \'2\' if time_list[1] <= \'3\' or time_list[1] == \'?\' else \'1\' if time_list[1] == \'?\': time_list[1] = \'3\' if time_list[0] == \'2\' else \'9\' if time_list[3] == \'?\': time_list[3] = \'5\' if time_list[4] == \'?\': time_list[4] = \'9\' return \\"\\".join(time_list)"},{"prompt":"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course. You must find the **minimum** number of months needed to complete all the courses following these rules: * You may start taking a course at **any time** if the prerequisites are met. * **Any number of courses** can be taken at the **same time**. Return _the **minimum** number of months needed to complete all the courses_. **Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph). **Example 1:** **Input:** n = 3, relations = [[1,3],[2,3]], time = [3,2,5] **Output:** 8 **Explanation:** The figure above represents the given graph and the time required to complete each course. We start course 1 and course 2 simultaneously at month 0. Course 1 takes 3 months and course 2 takes 2 months to complete respectively. Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months. **Example 2:** **Input:** n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5] **Output:** 12 **Explanation:** The figure above represents the given graph and the time required to complete each course. You can start courses 1, 2, and 3 at month 0. You can complete them after 1, 2, and 3 months respectively. Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months. Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months. Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months. **Constraints:** * `1 <= n <= 5 * 104` * `0 <= relations.length <= min(n * (n 1) / 2, 5 * 104)` * `relations[j].length == 2` * `1 <= prevCoursej, nextCoursej <= n` * `prevCoursej != nextCoursej` * All the pairs `[prevCoursej, nextCoursej]` are **unique**. * `time.length == n` * `1 <= time[i] <= 104` * The given graph is a directed acyclic graph.","completion":"def count_good_digit_strings(n): mod = 10 ** 9 + 7 even_digits, prime_digits = 5, 4 total = 1 for i in range(n): total = total * (even_digits if i % 2 == 0 else prime_digits) % mod return total"},{"prompt":"You are given a string `s`, which contains stars `*`. In one operation, you can: * Choose a star in `s`. * Remove the closest **nonstar** character to its **left**, as well as remove the star itself. Return _the string after **all** stars have been removed_. **Note:** * The input will be generated such that the operation is always possible. * It can be shown that the resulting string will always be unique. **Example 1:** **Input:** s = leet**cod*e **Output:** lecoe **Explanation:** Performing the removals from left to right: The closest character to the 1st star is \'t\' in lee**t****cod*e . s becomes lee*cod*e . The closest character to the 2nd star is \'e\' in le**e***cod*e . s becomes lecod*e . The closest character to the 3rd star is \'d\' in leco**d***e . s becomes lecoe . There are no more stars, so we return lecoe . **Example 2:** **Input:** s = erase***** **Output:** **Explanation:** The entire string is removed, so we return an empty string. **Constraints:** * `1 <= s.length <= 105` * `s` consists of lowercase English letters and stars `*`. * The operation above can be performed on `s`.","completion":"def remove_stars(s: str) -> str: result = [] for c in s: if c == \'*\': if result: result.pop() else: result.append(c) return \'\'.join(result)"},{"prompt":"Given an `m x n` binary matrix `mat`, return _the length of the longest line of consecutive one in the matrix_. The line could be horizontal, vertical, diagonal, or antidiagonal. **Example 1:** **Input:** mat = [[0,1,1,0],[0,1,1,0],[0,0,0,1]] **Output:** 3 **Example 2:** **Input:** mat = [[1,1,1,1],[0,1,1,0],[0,0,0,1]] **Output:** 4 **Constraints:** * `m == mat.length` * `n == mat[i].length` * `1 <= m, n <= 104` * `1 <= m * n <= 104` * `mat[i][j]` is either `0` or `1`.","completion":"def longestLine(mat): rows, cols = len(mat), len(mat[0]) max_length = 0 dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)] for r in range(rows): for c in range(cols): if mat[r][c] == 1: dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1 dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1 dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1 dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1 max_length = max(max_length, max(dp[r][c])) return max_length"},{"prompt":"There are `n` **piles** of coins on a table. Each pile consists of a **positive number** of coins of assorted denominations. In one move, you can choose any coin on **top** of any pile, remove it, and add it to your wallet. Given a list `piles`, where `piles[i]` is a list of integers denoting the composition of the `ith` pile from **top to bottom**, and a positive integer `k`, return _the **maximum total value** of coins you can have in your wallet if you choose **exactly**_ `k` _coins optimally_. **Example 1:** **Input:** piles = [[1,100,3],[7,8,9]], k = 2 **Output:** 101 **Explanation:** The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. **Example 2:** **Input:** piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 **Output:** 706 **Explanation:** The maximum total can be obtained if we choose all coins from the last pile. **Constraints:** * `n == piles.length` * `1 <= n <= 1000` * `1 <= piles[i][j] <= 105` * `1 <= k <= sum(piles[i].length) <= 2000`","completion":"import heapq def maxCoins(piles, k): pq = [] for pile in piles: for coin in pile: heapq.heappush(pq, -coin) max_value = 0 while k > 0: max_value += -heapq.heappop(pq) k -= 1 return max_value"},{"prompt":"Given an array of strings `words`, return _the smallest string that contains each string in_ `words` _as a substring_. If there are multiple valid strings of the smallest length, return **any of them**. You may assume that no string in `words` is a substring of another string in `words`. **Example 1:** **Input:** words = [ alex , loves , leetcode ] **Output:** alexlovesleetcode **Explanation:** All permutations of alex , loves , leetcode would also be accepted. **Example 2:** **Input:** words = [ catg , ctaagt , gcta , ttca , atgcatc ] **Output:** gctaagttcatgcatc **Constraints:** * `1 <= words.length <= 12` * `1 <= words[i].length <= 20` * `words[i]` consists of lowercase English letters. * All the strings of `words` are **unique**.","completion":"def sum_of_mins(arr): mod = 10**9 + 7 n = len(arr) left, right = [0] * n, [0] * n st = [] for i in range(n): while st and arr[st[-1]] > arr[i]: st.pop() left[i] = st[-1] if st else -1 st.append(i) st.clear() for i in range(n - 1, -1, -1): while st and arr[st[-1]] > arr[i]: st.pop() right[i] = st[-1] if st else n st.append(i) ans = 0 for i in range(n): ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod return ans"},{"prompt":"Given a **positive** integer `n`, return _the smallest positive integer that is a multiple of **both**_ `2` _and_ `n`. **Example 1:** **Input:** n = 5 **Output:** 10 **Explanation:** The smallest multiple of both 5 and 2 is 10. **Example 2:** **Input:** n = 6 **Output:** 6 **Explanation:** The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself. **Constraints:** * `1 <= n <= 150`","completion":"def smallest_multiple(n): return n if n % 2 == 0 else n * 2"},{"prompt":"You have `n` boxes labeled from `0` to `n 1`. You are given four arrays: `status`, `candies`, `keys`, and `containedBoxes` where: * `status[i]` is `1` if the `ith` box is open and `0` if the `ith` box is closed, * `candies[i]` is the number of candies in the `ith` box, * `keys[i]` is a list of the labels of the boxes you can open after opening the `ith` box. * `containedBoxes[i]` is a list of the boxes you found inside the `ith` box. You are given an integer array `initialBoxes` that contains the labels of the boxes you initially have. You can take all the candies in **any open box** and you can use the keys in it to open new boxes and you also can use the boxes you find in it. Return _the maximum number of candies you can get following the rules above_. **Example 1:** **Input:** status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0] **Output:** 16 **Explanation:** You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2. Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2. In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed. Total number of candies collected = 7 + 4 + 5 = 16 candy. **Example 2:** **Input:** status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0] **Output:** 6 **Explanation:** You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys. The total number of candies will be 6. **Constraints:** * `n == status.length == candies.length == keys.length == containedBoxes.length` * `1 <= n <= 1000` * `status[i]` is either `0` or `1`. * `1 <= candies[i] <= 1000` * `0 <= keys[i].length <= n` * `0 <= keys[i][j] < n` * All values of `keys[i]` are **unique**. * `0 <= containedBoxes[i].length <= n` * `0 <= containedBoxes[i][j] < n` * All values of `containedBoxes[i]` are unique. * Each box is contained in one box at most. * `0 <= initialBoxes.length <= n` * `0 <= initialBoxes[i] < n`","completion":"def reverseParentheses(s: str) -> str: st = [] result = [] for c in s: if c != \')\': st.append(c) else: temp = [] while st and st[-1] != \'(\': temp.append(st.pop()) if st: st.pop() # Remove \'(\' st.extend(temp) result = \\"\\".join(st) return result"},{"prompt":"Let the function `f(s)` be the **frequency of the lexicographically smallest character** in a nonempty string `s`. For example, if `s = dcce ` then `f(s) = 2` because the lexicographically smallest character is `\'c\'`, which has a frequency of 2. You are given an array of strings `words` and another array of query strings `queries`. For each query `queries[i]`, count the **number of words** in `words` such that `f(queries[i])` < `f(W)` for each `W` in `words`. Return _an integer array_ `answer`_, where each_ `answer[i]` _is the answer to the_ `ith` _query_. **Example 1:** **Input:** queries = [ cbd ], words = [ zaaaz ] **Output:** [1] **Explanation:** On the first query we have f( cbd ) = 1, f( zaaaz ) = 3 so f( cbd ) < f( zaaaz ). **Example 2:** **Input:** queries = [ bbb , cc ], words = [ a , aa , aaa , aaaa ] **Output:** [1,2] **Explanation:** On the first query only f( bbb ) < f( aaaa ). On the second query both f( aaa ) and f( aaaa ) are both > f( cc ). **Constraints:** * `1 <= queries.length <= 2000` * `1 <= words.length <= 2000` * `1 <= queries[i].length, words[i].length <= 10` * `queries[i][j]`, `words[i][j]` consist of lowercase English letters.","completion":"def shortest_common_supersequence(str1, str2): m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i - 1] == str2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) i, j = m, n result = [] while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: result.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: j -= 1 result.append(str2[j]) else: i -= 1 result.append(str1[i]) while i > 0: i -= 1 result.append(str1[i]) while j > 0: j -= 1 result.append(str2[j]) return \\"\\".join(result[::-1])"},{"prompt":"There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`. You are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `1`. **Example 1:** **Input:** n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1 **Output:** 700 **Explanation:** The graph is shown above. The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700. Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops. **Example 2:** **Input:** n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 **Output:** 200 **Explanation:** The graph is shown above. The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200. **Example 3:** **Input:** n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0 **Output:** 500 **Explanation:** The graph is shown above. The optimal path with no stops from city 0 to 2 is marked in red and has cost 500. **Constraints:** * `1 <= n <= 100` * `0 <= flights.length <= (n * (n 1) / 2)` * `flights[i].length == 3` * `0 <= fromi, toi < n` * `fromi != toi` * `1 <= pricei <= 104` * There will not be any multiple flights between two cities. * `0 <= src, dst, k < n` * `src != dst`","completion":"from collections import deque def slidingPuzzle(board): m, n = 2, 3 target = \\"123450\\" start = \\"\\".join(str(num) for row in board for num in row) dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]] q = deque([start]) res = 0 visited = {start} while q: for _ in range(len(q)): cur = q.popleft() if cur == target: return res zero_idx = cur.index(\\"0\\") for dir in dirs[zero_idx]: neighbor = list(cur) neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx] neighbor = \\"\\".join(neighbor) if neighbor not in visited: visited.add(neighbor) q.append(neighbor) res += 1 return -1"},{"prompt":"You are given an array `nums` consisting of **positive** integers. You can perform the following operation on the array **any** number of times: * Choose any two **adjacent** elements and **replace** them with their **sum**. * For example, if `nums = [1,2,3,1]`, you can apply one operation to make it `[1,5,1]`. Return _the **minimum** number of operations needed to turn the array into a **palindrome**_. **Example 1:** **Input:** nums = [4,3,2,1,2,3,1] **Output:** 2 **Explanation:** We can turn the array into a palindrome in 2 operations as follows: Apply the operation on the fourth and fifth element of the array, nums becomes equal to [4,3,2,**3**,3,1]. Apply the operation on the fifth and sixth element of the array, nums becomes equal to [4,3,2,3,**4**]. The array [4,3,2,3,4] is a palindrome. It can be shown that 2 is the minimum number of operations needed. **Example 2:** **Input:** nums = [1,2,3,4] **Output:** 3 **Explanation:** We do the operation 3 times in any position, we obtain the array [10] at the end which is a palindrome. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 106`","completion":"def minOperations(nums): n = len(nums) i, j = 0, n - 1 operations = 0 while i < j: if nums[i] == nums[j]: i += 1 j -= 1 elif nums[i] < nums[j]: nums[i + 1] += nums[i] i += 1 operations += 1 else: nums[j - 1] += nums[j] j -= 1 operations += 1 return operations"},{"prompt":"Given an array `arr` of positive integers sorted in a **strictly increasing order**, and an integer `k`. Return _the_ `kth` _**positive** integer that is **missing** from this array._ **Example 1:** **Input:** arr = [2,3,4,7,11], k = 5 **Output:** 9 **Explanation:** The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. **Example 2:** **Input:** arr = [1,2,3,4], k = 2 **Output:** 6 **Explanation:** The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6. **Constraints:** * `1 <= arr.length <= 1000` * `1 <= arr[i] <= 1000` * `1 <= k <= 1000` * `arr[i] < arr[j]` for `1 <= i < j <= arr.length`","completion":"def find_diagonal_order(nums): diagonals = {} for i in range(len(nums)): for j in range(len(nums[i])): if i + j not in diagonals: diagonals[i + j] = [] diagonals[i + j].append(nums[i][j]) res = [] for key in diagonals: res.extend(reversed(diagonals[key])) return res"},{"prompt":"You are given a **0indexed** array of `n` integers `arr`. The **interval** between two elements in `arr` is defined as the **absolute difference** between their indices. More formally, the **interval** between `arr[i]` and `arr[j]` is `|i j|`. Return _an array_ `intervals` _of length_ `n` _where_ `intervals[i]` _is **the sum of intervals** between_ `arr[i]` _and each element in_ `arr` _with the same value as_ `arr[i]`_._ **Note:** `|x|` is the absolute value of `x`. **Example 1:** **Input:** arr = [2,1,3,1,2,3,3] **Output:** [4,2,7,2,4,4,5] **Explanation:** Index 0: Another 2 is found at index 4. |0 4| = 4 Index 1: Another 1 is found at index 3. |1 3| = 2 Index 2: Two more 3s are found at indices 5 and 6. |2 5| + |2 6| = 7 Index 3: Another 1 is found at index 1. |3 1| = 2 Index 4: Another 2 is found at index 0. |4 0| = 4 Index 5: Two more 3s are found at indices 2 and 6. |5 2| + |5 6| = 4 Index 6: Two more 3s are found at indices 2 and 5. |6 2| + |6 5| = 5 **Example 2:** **Input:** arr = [10,5,10,10] **Output:** [5,0,3,4] **Explanation:** Index 0: Two more 10s are found at indices 2 and 3. |0 2| + |0 3| = 5 Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0. Index 2: Two more 10s are found at indices 0 and 3. |2 0| + |2 3| = 3 Index 3: Two more 10s are found at indices 0 and 2. |3 0| + |3 2| = 4 **Constraints:** * `n == arr.length` * `1 <= n <= 105` * `1 <= arr[i] <= 105`","completion":"from collections import defaultdict, deque def has_path(n, edges, source, destination): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) q = deque([source]) visited = [False] * n while q: current = q.popleft() visited[current] = True if current == destination: return True for neighbor in graph[current]: if not visited[neighbor]: q.append(neighbor) return False"},{"prompt":"You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins. There are `n` coins in total throughout the whole tree. In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent. Return _the **minimum** number of moves required to make every node have **exactly** one coin_. **Example 1:** **Input:** root = [3,0,0] **Output:** 2 **Explanation:** From the root of the tree, we move one coin to its left child, and one coin to its right child. **Example 2:** **Input:** root = [0,3,0] **Output:** 3 **Explanation:** From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. **Constraints:** * The number of nodes in the tree is `n`. * `1 <= n <= 100` * `0 <= Node.val <= n` * The sum of all `Node.val` is `n`.","completion":"def decode_permutation(s: str): n = len(s) perm = [0] * (n + 1) next_zero, next_one = 0, n for c in s: if c == \'0\': perm[next_zero] = next_one next_zero += 1 next_one -= 1 else: perm[next_one] = next_zero next_one -= 1 next_zero += 1 perm[next_zero] = next_one return perm"},{"prompt":"There are n people in a social group labeled from `0` to `n 1`. You are given an array `logs` where `logs[i] = [timestampi, xi, yi]` indicates that `xi` and `yi` will be friends at the time `timestampi`. Friendship is **symmetric**. That means if `a` is friends with `b`, then `b` is friends with `a`. Also, person `a` is acquainted with a person `b` if `a` is friends with `b`, or `a` is a friend of someone acquainted with `b`. Return _the earliest time for which every person became acquainted with every other person_. If there is no such earliest time, return `1`. **Example 1:** **Input:** logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], n = 6 **Output:** 20190301 **Explanation:** The first event occurs at timestamp = 20190101, and after 0 and 1 become friends, we have the following friendship groups [0,1], [2], [3], [4], [5]. The second event occurs at timestamp = 20190104, and after 3 and 4 become friends, we have the following friendship groups [0,1], [2], [3,4], [5]. The third event occurs at timestamp = 20190107, and after 2 and 3 become friends, we have the following friendship groups [0,1], [2,3,4], [5]. The fourth event occurs at timestamp = 20190211, and after 1 and 5 become friends, we have the following friendship groups [0,1,5], [2,3,4]. The fifth event occurs at timestamp = 20190224, and as 2 and 4 are already friends, nothing happens. The sixth event occurs at timestamp = 20190301, and after 0 and 3 become friends, we all become friends. **Example 2:** **Input:** logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4 **Output:** 3 **Explanation:** At timestamp = 3, all the persons (i.e., 0, 1, 2, and 3) become friends. **Constraints:** * `2 <= n <= 100` * `1 <= logs.length <= 104` * `logs[i].length == 3` * `0 <= timestampi <= 109` * `0 <= xi, yi <= n 1` * `xi != yi` * All the values `timestampi` are **unique**. * All the pairs `(xi, yi)` occur at most one time in the input.","completion":"def earliestAcq(logs, n): def find(x): if x != parents[x]: parents[x] = find(parents[x]) return parents[x] parents = list(range(n)) logs.sort() group_count = n for timestamp, x, y in logs: root_x, root_y = find(x), find(y) if root_x != root_y: parents[root_x] = root_y group_count -= 1 if group_count == 1: return timestamp return -1"},{"prompt":"Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the `nth` lake, the `nth` lake becomes full of water. If it rains over a lake that is **full of water**, there will be a **flood**. Your goal is to avoid floods in any lake. Given an integer array `rains` where: * `rains[i] > 0` means there will be rains over the `rains[i]` lake. * `rains[i] == 0` means there are no rains this day and you can choose **one lake** this day and **dry it**. Return _an array `ans`_ where: * `ans.length == rains.length` * `ans[i] == 1` if `rains[i] > 0`. * `ans[i]` is the lake you choose to dry in the `ith` day if `rains[i] == 0`. If there are multiple valid answers return **any** of them. If it is impossible to avoid flood return **an empty array**. Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes. **Example 1:** **Input:** rains = [1,2,3,4] **Output:** [1,1,1,1] **Explanation:** After the first day full lakes are [1] After the second day full lakes are [1,2] After the third day full lakes are [1,2,3] After the fourth day full lakes are [1,2,3,4] There\'s no day to dry any lake and there is no flood in any lake. **Example 2:** **Input:** rains = [1,2,0,0,2,1] **Output:** [1,1,2,1,1,1] **Explanation:** After the first day full lakes are [1] After the second day full lakes are [1,2] After the third day, we dry lake 2. Full lakes are [1] After the fourth day, we dry lake 1. There is no full lakes. After the fifth day, full lakes are [2]. After the sixth day, full lakes are [1,2]. It is easy that this scenario is floodfree. [1,1,1,2,1,1] is another acceptable scenario. **Example 3:** **Input:** rains = [1,2,0,1,2] **Output:** [] **Explanation:** After the second day, full lakes are [1,2]. We have to dry one lake in the third day. After that, it will rain over lakes [1,2]. It\'s easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood. **Constraints:** * `1 <= rains.length <= 105` * `0 <= rains[i] <= 109`","completion":"def get_power(x): steps = 0 while x != 1: if x % 2 == 0: x //= 2 else: x = 3 * x + 1 steps += 1 return steps def sort_by_power(lo, hi, k): nums = [(get_power(i), i) for i in range(lo, hi + 1)] nums.sort() return nums[k - 1][1]"},{"prompt":"There is a long and thin painting that can be represented by a number line. You are given a **0indexed** 2D integer array `paint` of length `n`, where `paint[i] = [starti, endi]`. This means that on the `ith` day you need to paint the area **between** `starti` and `endi`. Painting the same area multiple times will create an uneven painting so you only want to paint each area of the painting at most **once**. Return _an integer array_ `worklog` _of length_ `n`_, where_ `worklog[i]` _is the amount of **new** area that you painted on the_ `ith` _day._ **Example 1:** **Input:** paint = [[1,4],[4,7],[5,8]] **Output:** [3,3,1] **Explanation:** On day 0, paint everything between 1 and 4. The amount of new area painted on day 0 is 4 1 = 3. On day 1, paint everything between 4 and 7. The amount of new area painted on day 1 is 7 4 = 3. On day 2, paint everything between 7 and 8. Everything between 5 and 7 was already painted on day 1. The amount of new area painted on day 2 is 8 7 = 1. **Example 2:** **Input:** paint = [[1,4],[5,8],[4,7]] **Output:** [3,3,1] **Explanation:** On day 0, paint everything between 1 and 4. The amount of new area painted on day 0 is 4 1 = 3. On day 1, paint everything between 5 and 8. The amount of new area painted on day 1 is 8 5 = 3. On day 2, paint everything between 4 and 5. Everything between 5 and 7 was already painted on day 1. The amount of new area painted on day 2 is 5 4 = 1. **Example 3:** **Input:** paint = [[1,5],[2,4]] **Output:** [4,0] **Explanation:** On day 0, paint everything between 1 and 5. The amount of new area painted on day 0 is 5 1 = 4. On day 1, paint nothing because everything between 2 and 4 was already painted on day 0. The amount of new area painted on day 1 is 0. **Constraints:** * `1 <= paint.length <= 105` * `paint[i].length == 2` * `0 <= starti < endi <= 5 * 104`","completion":"def painting_plan(paint): worklog = [0] * len(paint) painted = set() for i in range(len(paint)): start, end = paint[i] for j in range(start, end): if j not in painted: painted.add(j) worklog[i] += 1 return worklog"},{"prompt":"You are currently designing a dynamic array. You are given a **0indexed** integer array `nums`, where `nums[i]` is the number of elements that will be in the array at time `i`. In addition, you are given an integer `k`, the **maximum** number of times you can **resize** the array (to **any** size). The size of the array at time `t`, `sizet`, must be at least `nums[t]` because there needs to be enough space in the array to hold all the elements. The **space wasted** at time `t` is defined as `sizet nums[t]`, and the **total** space wasted is the **sum** of the space wasted across every time `t` where `0 <= t < nums.length`. Return _the **minimum** **total space wasted** if you can resize the array at most_ `k` _times_. **Note:** The array can have **any size** at the start and does **not** count towards the number of resizing operations. **Example 1:** **Input:** nums = [10,20], k = 0 **Output:** 10 **Explanation:** size = [20,20]. We can set the initial size to be 20. The total wasted space is (20 10) + (20 20) = 10. **Example 2:** **Input:** nums = [10,20,30], k = 1 **Output:** 10 **Explanation:** size = [20,20,30]. We can set the initial size to be 20 and resize to 30 at time 2. The total wasted space is (20 10) + (20 20) + (30 30) = 10. **Example 3:** **Input:** nums = [10,20,15,30,20], k = 2 **Output:** 15 **Explanation:** size = [10,20,20,30,30]. We can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3. The total wasted space is (10 10) + (20 20) + (20 15) + (30 30) + (30 20) = 15. **Constraints:** * `1 <= nums.length <= 200` * `1 <= nums[i] <= 106` * `0 <= k <= nums.length 1`","completion":"def minSpaceWastedKResizing(nums, k): n = len(nums) dp = [[float(\'inf\')] * (k + 1) for _ in range(n + 1)] sum_nums = [0] * (n + 1) dp[0][0] = 0 for i in range(1, n + 1): sum_nums[i] = sum_nums[i - 1] + nums[i - 1] max_val = nums[i - 1] for j in range(i - 1, -1, -1): max_val = max(max_val, nums[j]) waste = max_val * (i - j) - (sum_nums[i] - sum_nums[j]) for c in range(k): dp[i][c + 1] = min(dp[i][c + 1], dp[j][c] + waste) return dp[n][k]"},{"prompt":"Given a positive integer num, return _the smallest positive integer_ `x` _whose multiplication of each digit equals_ `num`. If there is no answer or the answer is not fit in **32bit** signed integer, return `0`. **Example 1:** **Input:** num = 48 **Output:** 68 **Example 2:** **Input:** num = 15 **Output:** 35 **Constraints:** * `1 <= num <= 231 1`","completion":"def smallestFactorization(num: int) -> int: if num == 1: return 1 result = 0 factor = 1 for i in range(9, 1, -1): while num % i == 0: num //= i result += i * factor factor *= 10 if result > 2**31 - 1: return 0 return result if num == 1 else 0"},{"prompt":"You are given a **0indexed** integer array `nums`. In one step, **remove** all elements `nums[i]` where `nums[i 1] > nums[i]` for all `0 < i < nums.length`. Return _the number of steps performed until_ `nums` _becomes a **nondecreasing** array_. **Example 1:** **Input:** nums = [5,3,4,4,7,3,6,11,8,5,11] **Output:** 3 **Explanation:** The following are the steps performed: Step 1: [5,**3**,4,4,7,**3**,6,11,**8**,**5**,11] becomes [5,4,4,7,6,11,11] Step 2: [5,**4**,4,7,**6**,11,11] becomes [5,4,7,11,11] Step 3: [5,**4**,7,11,11] becomes [5,7,11,11] [5,7,11,11] is a nondecreasing array. Therefore, we return 3. **Example 2:** **Input:** nums = [4,5,7,7,13] **Output:** 0 **Explanation:** nums is already a nondecreasing array. Therefore, we return 0. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109`","completion":"def min_operations(nums): n = len(nums) even, odd = 0, 0 for i in range(n): if i % 2 == 0 and nums[i] % 2 != 0: even += 1 elif i % 2 != 0 and nums[i] % 2 == 0: odd += 1 return min(even, odd)"},{"prompt":"A **subsequence** of a string is good if it is not empty and the frequency of each one of its characters is the same. Given a string `s`, return _the number of good subsequences of_ `s`. Since the answer may be too large, return it modulo `109 + 7`. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. **Example 1:** **Input:** s = aabb **Output:** 11 **Explanation:** The total number of subsequences is `24.` There are five subsequences which are not good: **aab**b , a**abb** , **a**a**bb** , **aa**b**b** , and the empty subsequence. Hence, the number of good subsequences is `245 = 11`. **Example 2:** **Input:** s = leet **Output:** 12 **Explanation:** There are four subsequences which are not good: **l_ee_**t , l**eet** , **leet** , and the empty subsequence. Hence, the number of good subsequences is `244 = 12`. **Example 3:** **Input:** s = abcd **Output:** 15 **Explanation:** All of the nonempty subsequences are good subsequences. Hence, the number of good subsequences is `241 = 15`. **Constraints:** * `1 <= s.length <= 104` * `s` consists of only lowercase English letters.","completion":"def numberOfGoodSubsequences(s: str) -> int: count = [0] * 26 ans = 0 MOD = 1000000007 for c in s: count[ord(c) - ord(\'a\')] += 1 for val in count: ans = (ans + (1 << val) - 1) % MOD return ans"},{"prompt":"Given an integer `n`, return `true` _if it is possible to represent_ `n` _as the sum of distinct powers of three._ Otherwise, return `false`. An integer `y` is a power of three if there exists an integer `x` such that `y == 3x`. **Example 1:** **Input:** n = 12 **Output:** true **Explanation:** 12 = 31 + 32 **Example 2:** **Input:** n = 91 **Output:** true **Explanation:** 91 = 30 + 32 + 34 **Example 3:** **Input:** n = 21 **Output:** false **Constraints:** * `1 <= n <= 107`","completion":"def check_powers_of_three(n: int) -> bool: while n > 0: if n % 3 == 2: return False n //= 3 return True"},{"prompt":"You are given an array representing a row of `seats` where `seats[i] = 1` represents a person sitting in the `ith` seat, and `seats[i] = 0` represents that the `ith` seat is empty **(0indexed)**. There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. Return _that maximum distance to the closest person_. **Example 1:** **Input:** seats = [1,0,0,0,1,0,1] **Output:** 2 **Explanation:** If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2. **Example 2:** **Input:** seats = [1,0,0,0] **Output:** 3 **Explanation:** If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3. **Example 3:** **Input:** seats = [0,1] **Output:** 1 **Constraints:** * `2 <= seats.length <= 2 * 104` * `seats[i]` is `0` or `1`. * At least one seat is **empty**. * At least one seat is **occupied**.","completion":"def maxDistToClosest(seats): n = len(seats) maxDist = 0 lastPerson = -1 for i in range(n): if seats[i] == 1: if lastPerson == -1: maxDist = i else: maxDist = max(maxDist, (i - lastPerson) // 2) lastPerson = i maxDist = max(maxDist, n - 1 - lastPerson) return maxDist"},{"prompt":"You are given a **0indexed** positive integer array `nums` and a positive integer `k`. A pair of numbers `(num1, num2)` is called **excellent** if the following conditions are satisfied: * **Both** the numbers `num1` and `num2` exist in the array `nums`. * The sum of the number of set bits in `num1 OR num2` and `num1 AND num2` is greater than or equal to `k`, where `OR` is the bitwise **OR** operation and `AND` is the bitwise **AND** operation. Return _the number of **distinct** excellent pairs_. Two pairs `(a, b)` and `(c, d)` are considered distinct if either `a != c` or `b != d`. For example, `(1, 2)` and `(2, 1)` are distinct. **Note** that a pair `(num1, num2)` such that `num1 == num2` can also be excellent if you have at least **one** occurrence of `num1` in the array. **Example 1:** **Input:** nums = [1,2,3,1], k = 3 **Output:** 5 **Explanation:** The excellent pairs are the following: (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3. (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3. (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3. So the number of excellent pairs is 5. **Example 2:** **Input:** nums = [5,1,1], k = 10 **Output:** 0 **Explanation:** There are no excellent pairs for this array. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109` * `1 <= k <= 60`","completion":"from collections import Counter def countExcellentPairs(nums, k): frequency = Counter(nums) count = 0 for num1, freq1 in frequency.items(): for num2, freq2 in frequency.items(): setBits = bin(num1 | num2).count(\'1\') + bin(num1 & num2).count(\'1\') if setBits >= k: count += freq1 * freq2 if num1 != num2 else freq1 * (freq1 - 1) // 2 return count"},{"prompt":"Given two arrays of **unique** digits `nums1` and `nums2`, return _the **smallest** number that contains **at least** one digit from each array_. **Example 1:** **Input:** nums1 = [4,1,3], nums2 = [5,7] **Output:** 15 **Explanation:** The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have. **Example 2:** **Input:** nums1 = [3,5,2,6], nums2 = [3,1,7] **Output:** 3 **Explanation:** The number 3 contains the digit 3 which exists in both arrays. **Constraints:** * `1 <= nums1.length, nums2.length <= 9` * `1 <= nums1[i], nums2[i] <= 9` * All digits in each array are **unique**.","completion":"def smallest_number_with_at_least_one_digit_from_each_array(nums1, nums2): min1 = min(nums1) min2 = min(nums2) for num1 in nums1: for num2 in nums2: if num1 == num2: return num1 return min1 * 10 + min2"},{"prompt":"You are given a **0indexed** integer array `buses` of length `n`, where `buses[i]` represents the departure time of the `ith` bus. You are also given a **0indexed** integer array `passengers` of length `m`, where `passengers[j]` represents the arrival time of the `jth` passenger. All bus departure times are unique. All passenger arrival times are unique. You are given an integer `capacity`, which represents the **maximum** number of passengers that can get on each bus. When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at `x` minutes if you arrive at `y` minutes where `y <= x`, and the bus is not full. Passengers with the **earliest** arrival times get on the bus first. More formally when a bus arrives, either: * If `capacity` or fewer passengers are waiting for a bus, they will **all** get on the bus, or * The `capacity` passengers with the **earliest** arrival times will get on the bus. Return _the latest time you may arrive at the bus station to catch a bus_. You **cannot** arrive at the same time as another passenger. **Note:** The arrays `buses` and `passengers` are not necessarily sorted. **Example 1:** **Input:** buses = [10,20], passengers = [2,17,18,19], capacity = 2 **Output:** 16 **Explanation:** Suppose you arrive at time 16. At time 10, the first bus departs with the 0th passenger. At time 20, the second bus departs with you and the 1st passenger. Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus. **Example 2:** **Input:** buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2 **Output:** 20 **Explanation:** Suppose you arrive at time 20. At time 10, the first bus departs with the 3rd passenger. At time 20, the second bus departs with the 5th and 1st passengers. At time 30, the third bus departs with the 0th passenger and you. Notice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus. **Constraints:** * `n == buses.length` * `m == passengers.length` * `1 <= n, m, capacity <= 105` * `2 <= buses[i], passengers[i] <= 109` * Each element in `buses` is **unique**. * Each element in `passengers` is **unique**.","completion":"def last_passenger_time(buses, passengers, capacity): buses.sort() passengers.sort() last_index = 0 for bus in buses: cnt = 0 while last_index < len(passengers) and passengers[last_index] <= bus and cnt < capacity: cnt += 1 last_index += 1 return buses[0] - 1 if last_index == 0 else passengers[last_index - 1] - 1"},{"prompt":"A string is **good** if there are no repeated characters. Given a string `s`​​​​​, return _the number of **good substrings** of length **three** in_ `s`​​​​​​. Note that if there are multiple occurrences of the same substring, every occurrence should be counted. A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** s = xyzzaz **Output:** 1 **Explanation:** There are 4 substrings of size 3: xyz , yzz , zza , and zaz . The only good substring of length 3 is xyz . **Example 2:** **Input:** s = aababcabc **Output:** 4 **Explanation:** There are 7 substrings of size 3: aab , aba , bab , abc , bca , cab , and abc . The good substrings are abc , bca , cab , and abc . **Constraints:** * `1 <= s.length <= 100` * `s`​​​​​​ consists of lowercase English letters.","completion":"from collections import deque def highest_island(is_water): m, n = len(is_water), len(is_water[0]) height = [[-1] * n for _ in range(m)] q = deque() for i in range(m): for j in range(n): if is_water[i][j] == 1: height[i][j] = 0 q.append((i, j)) dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] while q: x, y = q.popleft() for i in range(4): newX = x + dx[i] newY = y + dy[i] if 0 <= newX < m and 0 <= newY < n and height[newX][newY] == -1: height[newX][newY] = height[x][y] + 1 q.append((newX, newY)) return height"},{"prompt":"Given the `root` of a binary tree, return _the same tree where every subtree (of the given tree) not containing a_ `1` _has been removed_. A subtree of a node `node` is `node` plus every node that is a descendant of `node`. **Example 1:** **Input:** root = [1,null,0,0,1] **Output:** [1,null,0,null,1] **Explanation:** Only the red nodes satisfy the property every subtree not containing a 1 . The diagram on the right represents the answer. **Example 2:** **Input:** root = [1,0,1,0,0,0,1] **Output:** [1,null,1,null,1] **Example 3:** **Input:** root = [1,1,0,1,1,0,1,0] **Output:** [1,1,0,1,1,null,1] **Constraints:** * The number of nodes in the tree is in the range `[1, 200]`. * `Node.val` is either `0` or `1`.","completion":"def best_rotation(nums): n = len(nums) change = [0] * n for i in range(n): change[(i - nums[i] + 1 + n) % n] -= 1 change[(i + 1) % n] += 1 max_score = 0 cur_score = change[0] for i in range(1, n): cur_score += change[i] if cur_score > max_score: max_score = cur_score return max_score"},{"prompt":"There are `n` people in a line queuing to buy tickets, where the `0th` person is at the **front** of the line and the `(n 1)th` person is at the **back** of the line. You are given a **0indexed** integer array `tickets` of length `n` where the number of tickets that the `ith` person would like to buy is `tickets[i]`. Each person takes **exactly 1 second** to buy a ticket. A person can only buy **1 ticket at a time** and has to go back to **the end** of the line (which happens **instantaneously**) in order to buy more tickets. If a person does not have any tickets left to buy, the person will **leave** the line. Return _the **time taken** for the person at position_ `k` **_(0indexed)_** _to finish buying tickets_. **Example 1:** **Input:** tickets = [2,3,2], k = 2 **Output:** 6 **Explanation:** In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1]. In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0]. The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds. **Example 2:** **Input:** tickets = [5,1,1,1], k = 0 **Output:** 8 **Explanation:** In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0]. In the next 4 passes, only the person in position 0 is buying tickets. The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds. **Constraints:** * `n == tickets.length` * `1 <= n <= 100` * `1 <= tickets[i] <= 100` * `0 <= k < n`","completion":"def time_to_buy_tickets(tickets, k): time = 0 while tickets[k] > 0: for i in range(len(tickets)): if tickets[i] > 0: tickets[i] -= 1 time += 1 if i == k and tickets[k] == 0: break return time"},{"prompt":"There are `n` cars on an infinitely long road. The cars are numbered from `0` to `n 1` from left to right and each car is present at a **unique** point. You are given a **0indexed** string `directions` of length `n`. `directions[i]` can be either `\'L\'`, `\'R\'`, or `\'S\'` denoting whether the `ith` car is moving towards the **left**, towards the **right**, or **staying** at its current point respectively. Each moving car has the **same speed**. The number of collisions can be calculated as follows: * When two cars moving in **opposite** directions collide with each other, the number of collisions increases by `2`. * When a moving car collides with a stationary car, the number of collisions increases by `1`. After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion. Return _the **total number of collisions** that will happen on the road_. **Example 1:** **Input:** directions = RLRSLL **Output:** 5 **Explanation:** The collisions that will happen on the road are: Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2. Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3. Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4. Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5. Thus, the total number of collisions that will happen on the road is 5. **Example 2:** **Input:** directions = LLRR **Output:** 0 **Explanation:** No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0. **Constraints:** * `1 <= directions.length <= 105` * `directions[i]` is either `\'L\'`, `\'R\'`, or `\'S\'`.","completion":"def k_radius_average(nums, k): n = len(nums) avgs = [-1] * n for i in range(k, n - k): sum = 0 for j in range(i - k, i + k + 1): sum += nums[j] avgs[i] = sum // (2 * k + 1) return avgs"},{"prompt":"You are given an integer array `banned` and two integers `n` and `maxSum`. You are choosing some number of integers following the below rules: * The chosen integers have to be in the range `[1, n]`. * Each integer can be chosen **at most once**. * The chosen integers should not be in the array `banned`. * The sum of the chosen integers should not exceed `maxSum`. Return _the **maximum** number of integers you can choose following the mentioned rules_. **Example 1:** **Input:** banned = [1,6,5], n = 5, maxSum = 6 **Output:** 2 **Explanation:** You can choose the integers 2 and 4. 2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum. **Example 2:** **Input:** banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1 **Output:** 0 **Explanation:** You cannot choose any integer while following the mentioned conditions. **Example 3:** **Input:** banned = [11], n = 7, maxSum = 50 **Output:** 7 **Explanation:** You can choose the integers 1, 2, 3, 4, 5, 6, and 7. They are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum. **Constraints:** * `1 <= banned.length <= 104` * `1 <= banned[i], n <= 104` * `1 <= maxSum <= 109`","completion":"def max_chosen_integers(banned, n, max_sum): banned_set = set(banned) count = 0 total_sum = 0 for i in range(n, 0, -1): if i not in banned_set and max_sum - total_sum >= i: total_sum += i count += 1 return count"},{"prompt":"You are given a **0indexed** string `s` and are tasked with finding two **nonintersecting palindromic** substrings of **odd** length such that the product of their lengths is maximized. More formally, you want to choose four integers `i`, `j`, `k`, `l` such that `0 <= i <= j < k <= l < s.length` and both the substrings `s[i...j]` and `s[k...l]` are palindromes and have odd lengths. `s[i...j]` denotes a substring from index `i` to index `j` **inclusive**. Return _the **maximum** possible product of the lengths of the two nonintersecting palindromic substrings._ A **palindrome** is a string that is the same forward and backward. A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** s = ababbb **Output:** 9 **Explanation:** Substrings aba and bbb are palindromes with odd length. product = 3 * 3 = 9. **Example 2:** **Input:** s = zaaaxbbby **Output:** 9 **Explanation:** Substrings aaa and bbb are palindromes with odd length. product = 3 * 3 = 9. **Constraints:** * `2 <= s.length <= 105` * `s` consists of lowercase English letters.","completion":"def is_pangram(sentence): alphabet = [False] * 26 for c in sentence: alphabet[ord(c) - ord(\'a\')] = True return all(alphabet)"},{"prompt":"Given the `root` of a binary tree with unique values and the values of two different nodes of the tree `x` and `y`, return `true` _if the nodes corresponding to the values_ `x` _and_ `y` _in the tree are **cousins**, or_ `false` _otherwise._ Two nodes of a binary tree are **cousins** if they have the same depth with different parents. Note that in a binary tree, the root node is at the depth `0`, and children of each depth `k` node are at the depth `k + 1`. **Example 1:** **Input:** root = [1,2,3,4], x = 4, y = 3 **Output:** false **Example 2:** **Input:** root = [1,2,3,null,4,null,5], x = 5, y = 4 **Output:** true **Example 3:** **Input:** root = [1,2,3,null,4], x = 2, y = 3 **Output:** false **Constraints:** * The number of nodes in the tree is in the range `[2, 100]`. * `1 <= Node.val <= 100` * Each node has a **unique** value. * `x != y` * `x` and `y` are exist in the tree.","completion":"def tallestBillboard(rods): n = len(rods) totalLength = sum(rods) dp = [[-1] * (totalLength + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n + 1): for j in range(totalLength + 1): dp[i][j] = dp[i - 1][j] if rods[i - 1] <= j: dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]) if rods[i - 1] <= totalLength - j: dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]]) return dp[n][0] // 2"},{"prompt":"You are given an integer `num`. You know that Danny Mittal will sneakily **remap** one of the `10` possible digits (`0` to `9`) to another digit. Return _the difference between the maximum and minimum_ _values Danny can make by remapping **exactly** **one** digit_ _in_ `num`. **Notes:** * When Danny remaps a digit d1 to another digit d2, Danny replaces all occurrences of `d1` in `num` with `d2`. * Danny can remap a digit to itself, in which case `num` does not change. * Danny can remap different digits for obtaining minimum and maximum values respectively. * The resulting number after remapping can contain leading zeroes. * We mentioned Danny Mittal to congratulate him on being in the top 10 in Weekly Contest 326. **Example 1:** **Input:** num = 11891 **Output:** 99009 **Explanation:** To achieve the maximum value, Danny can remap the digit 1 to the digit 9 to yield 99899. To achieve the minimum value, Danny can remap the digit 1 to the digit 0, yielding 890. The difference between these two numbers is 99009. **Example 2:** **Input:** num = 90 **Output:** 99 **Explanation:** The maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0). Thus, we return 99. **Constraints:** * `1 <= num <= 108`","completion":"def diffMaxMin(num): max_remap = 1 min_remap = 9 num_str = str(num) for c in num_str: digit = int(c) max_remap = max(max_remap, 9 - digit) if digit != 0: min_remap = min(min_remap, digit) max_value = num + max_remap * (len(num_str) - num_str.count(str(9 - max_remap))) min_value = num - min_remap * num_str.count(str(min_remap)) return max_value - min_value"},{"prompt":"You are given two string arrays `positive_feedback` and `negative_feedback`, containing the words denoting positive and negative feedback, respectively. Note that **no** word is both positive and negative. Initially every student has `0` points. Each positive word in a feedback report **increases** the points of a student by `3`, whereas each negative word **decreases** the points by `1`. You are given `n` feedback reports, represented by a **0indexed** string array `report` and a **0indexed** integer array `student_id`, where `student_id[i]` represents the ID of the student who has received the feedback report `report[i]`. The ID of each student is **unique**. Given an integer `k`, return _the top_ `k` _students after ranking them in **nonincreasing** order by their points_. In case more than one student has the same points, the one with the lower ID ranks higher. **Example 1:** **Input:** positive_feedback = [ smart , brilliant , studious ], negative_feedback = [ not ], report = [ this student is studious , the student is smart ], student_id = [1,2], k = 2 **Output:** [1,2] **Explanation:** Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher. **Example 2:** **Input:** positive_feedback = [ smart , brilliant , studious ], negative_feedback = [ not ], report = [ this student is not studious , the student is smart ], student_id = [1,2], k = 2 **Output:** [2,1] **Explanation:** The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 31=2 points. The student with ID 2 has 1 positive feedback, so he has 3 points. Since student 2 has more points, [2,1] is returned. **Constraints:** * `1 <= positive_feedback.length, negative_feedback.length <= 104` * `1 <= positive_feedback[i].length, negative_feedback[j].length <= 100` * Both `positive_feedback[i]` and `negative_feedback[j]` consists of lowercase English letters. * No word is present in both `positive_feedback` and `negative_feedback`. * `n == report.length == student_id.length` * `1 <= n <= 104` * `report[i]` consists of lowercase English letters and spaces `\' \'`. * There is a single space between consecutive words of `report[i]`. * `1 <= report[i].length <= 100` * `1 <= student_id[i] <= 109` * All the values of `student_id[i]` are **unique**. * `1 <= k <= n`","completion":"def top_k_students(positive_feedback, negative_feedback, report, student_id, k): points = {} for i in range(len(report)): pos_count, neg_count = 0, 0 for pos in positive_feedback: pos_index = report[i].find(pos) while pos_index != -1: pos_count += 1 pos_index = report[i].find(pos, pos_index + len(pos)) for neg in negative_feedback: neg_index = report[i].find(neg) while neg_index != -1: neg_count += 1 neg_index = report[i].find(neg, neg_index + len(neg)) points[student_id[i]] = points.get(student_id[i], 0) + 3 * pos_count - neg_count students = sorted(student_id, key=lambda x: (-points[x], x)) return students[:k]"},{"prompt":"Given the `root` of a binary tree, return _the maximum **average** value of a **subtree** of that tree_. Answers within `105` of the actual answer will be accepted. A **subtree** of a tree is any node of that tree plus all its descendants. The **average** value of a tree is the sum of its values, divided by the number of nodes. **Example 1:** **Input:** root = [5,6,1] **Output:** 6.00000 **Explanation:** For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4. For the node with value = 6 we have an average of 6 / 1 = 6. For the node with value = 1 we have an average of 1 / 1 = 1. So the answer is 6 which is the maximum. **Example 2:** **Input:** root = [0,null,1] **Output:** 1.00000 **Constraints:** * The number of nodes in the tree is in the range `[1, 104]`. * `0 <= Node.val <= 105`","completion":"from collections import defaultdict def gardenNoAdj(n, paths): graph = defaultdict(set) for x, y in paths: graph[x - 1].add(y - 1) graph[y - 1].add(x - 1) result = [0] * n for i in range(n): used_flowers = {result[neighbor] for neighbor in graph[i]} for flower in range(1, 5): if flower not in used_flowers: result[i] = flower break return result"},{"prompt":"Given a string `n` representing an integer, return _the closest integer (not including itself), which is a palindrome_. If there is a tie, return _**the smaller one**_. The closest is defined as the absolute difference minimized between two integers. **Example 1:** **Input:** n = 123 **Output:** 121 **Example 2:** **Input:** n = 1 **Output:** 0 **Explanation:** 0 and 2 are the closest palindromes but we return the smallest which is 0. **Constraints:** * `1 <= n.length <= 18` * `n` consists of only digits. * `n` does not have leading zeros. * `n` is representing an integer in the range `[1, 1018 1]`.","completion":"def is_palindrome(s: str) -> bool: return s == s[::-1] def closest_palindrome(n: str) -> int: num = int(n) left = num - 1 right = num + 1 while True: if is_palindrome(str(left)): return left if is_palindrome(str(right)): return right left -= 1 right += 1"},{"prompt":"You are given an integer `n`. Each number from `1` to `n` is grouped according to the sum of its digits. Return _the number of groups that have the largest size_. **Example 1:** **Input:** n = 13 **Output:** 4 **Explanation:** There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13: [1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size. **Example 2:** **Input:** n = 2 **Output:** 2 **Explanation:** There are 2 groups [1], [2] of size 1. **Constraints:** * `1 <= n <= 104`","completion":"def countLargestGroup(n: int) -> int: groups = [0] * 37 largest_group_size = 0 count_largest_groups = 0 for i in range(1, n + 1): sum_of_digits = sum(map(int, str(i))) groups[sum_of_digits] += 1 if groups[sum_of_digits] > largest_group_size: largest_group_size = groups[sum_of_digits] count_largest_groups = 1 elif groups[sum_of_digits] == largest_group_size: count_largest_groups += 1 return count_largest_groups"},{"prompt":"this problem, a rooted tree is a **directed** graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed. The resulting graph is given as a 2Darray of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a **directed** edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`. Return _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2Darray. **Example 1:** **Input:** edges = [[1,2],[1,3],[2,3]] **Output:** [2,3] **Example 2:** **Input:** edges = [[1,2],[2,3],[3,4],[4,1],[1,5]] **Output:** [4,1] **Constraints:** * `n == edges.length` * `3 <= n <= 1000` * `edges[i].length == 2` * `1 <= ui, vi <= n` * `ui != vi`","completion":"def findRedundantDirectedConnection(edges): parent = [0] * (len(edges) + 1) candidateA = candidateB = None for u, v in edges: if parent[v] > 0: candidateA = [parent[v], v] candidateB = [u, v] else: parent[v] = u for i in range(1, len(edges) + 1): cycle = i steps = len(edges) while parent[cycle] != 0 and steps > 0: cycle = parent[cycle] steps -= 1 if steps == 0: if not candidateA: return [parent[i], i] else: return candidateA return candidateB"},{"prompt":"You are given a string `text` of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It\'s guaranteed that `text` **contains at least one word**. Rearrange the spaces so that there is an **equal** number of spaces between every pair of adjacent words and that number is **maximized**. If you cannot redistribute all the spaces equally, place the **extra spaces at the end**, meaning the returned string should be the same length as `text`. Return _the string after rearranging the spaces_. **Example 1:** **Input:** text = this is a sentence **Output:** this is a sentence **Explanation:** There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (41) = 3 spaces. **Example 2:** **Input:** text = practice makes perfect **Output:** practice makes perfect **Explanation:** There are a total of 7 spaces and 3 words. 7 / (31) = 3 spaces plus 1 extra space. We place this extra space at the end of the string. **Constraints:** * `1 <= text.length <= 100` * `text` consists of lowercase English letters and `\' \'`. * `text` contains at least one word.","completion":"def reorderSpaces(text): spaces = text.count(\' \') words = text.split() num_words = len(words) if num_words == 1: spaces_between_words = 0 else: spaces_between_words = spaces // (num_words - 1) extra_spaces = spaces - spaces_between_words * (num_words - 1) return (\' \' * spaces_between_words).join(words) + \' \' * extra_spaces"},{"prompt":"You are given a **0indexed** integer array `nums` and a positive integer `k`. We call an index `i` **kbig** if the following conditions are satisfied: * There exist at least `k` different indices `idx1` such that `idx1 < i` and `nums[idx1] < nums[i]`. * There exist at least `k` different indices `idx2` such that `idx2 > i` and `nums[idx2] < nums[i]`. Return _the number of kbig indices_. **Example 1:** **Input:** nums = [2,3,6,5,2,3], k = 2 **Output:** 2 **Explanation:** There are only two 2big indices in nums: i = 2 > There are two valid idx1: 0 and 1. There are three valid idx2: 2, 3, and 4. i = 3 > There are two valid idx1: 0 and 1. There are two valid idx2: 3 and 4. **Example 2:** **Input:** nums = [1,1,1], k = 3 **Output:** 0 **Explanation:** There are no 3big indices in nums. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i], k <= nums.length`","completion":"def kBigIndices(nums, k): n = len(nums) left, right = [0] * n, [0] * n for i in range(1, n): if nums[i] > nums[i - 1]: left[i] = left[i - 1] + 1 j = n - i - 1 if nums[j] < nums[j + 1]: right[j] = right[j + 1] + 1 return sum(1 for i in range(n) if left[i] >= k and right[i] >= k)"},{"prompt":"A **sentence** is a string of singlespace separated words where each word can contain digits, lowercase letters, and the dollar sign `\'\'`. A word represents a **price** if it is a sequence of digits preceded by a dollar sign. * For example, `100 `, `23 `, and `6 ` represent prices while `100 `, ` `, and `1e5 ` do not. You are given a string `sentence` representing a sentence and an integer `discount`. For each word representing a price, apply a discount of `discount%` on the price and **update** the word in the sentence. All updated prices should be represented with **exactly two** decimal places. Return _a string representing the modified sentence_. Note that all prices will contain **at most** `10` digits. **Example 1:** **Input:** sentence = there are 1 2 and 5 candies in the shop , discount = 50 **Output:** there are 0.50 1.00 and 5 candies in the shop **Explanation:** The words which represent prices are 1 and 2 . A 50% discount on 1 yields 0.50 , so 1 is replaced by 0.50 . A 50% discount on 2 yields 1 . Since we need to have exactly 2 decimal places after a price, we replace 2 with 1.00 . **Example 2:** **Input:** sentence = 1 2 3 4 5 6 7 8 9 10 , discount = 100 **Output:** 1 2 0.00 4 0.00 0.00 7 8 0.00 10 **Explanation:** Applying a 100% discount on any price will result in 0. The words representing prices are 3 , 5 , 6 , and 9 . Each of them is replaced by 0.00 . **Constraints:** * `1 <= sentence.length <= 105` * `sentence` consists of lowercase English letters, digits, `\' \'`, and `\'\'`. * `sentence` does not have leading or trailing spaces. * All words in `sentence` are separated by a single space. * All prices will be **positive** numbers without leading zeros. * All prices will have **at most** `10` digits. * `0 <= discount <= 100`","completion":"def operations(num1, num2): count = 0 while num1 != 0 and num2 != 0: if num1 >= num2: num1 -= num2 else: num2 -= num1 count += 1 return count"},{"prompt":"The **XOR total** of an array is defined as the bitwise `XOR` of **all its elements**, or `0` if the array is **empty**. * For example, the **XOR total** of the array `[2,5,6]` is `2 XOR 5 XOR 6 = 1`. Given an array `nums`, return _the **sum** of all **XOR totals** for every **subset** of_ `nums`. **Note:** Subsets with the **same** elements should be counted **multiple** times. An array `a` is a **subset** of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`. **Example 1:** **Input:** nums = [1,3] **Output:** 6 **Explanation:** The 4 subsets of [1,3] are: The empty subset has an XOR total of 0. [1] has an XOR total of 1. [3] has an XOR total of 3. [1,3] has an XOR total of 1 XOR 3 = 2. 0 + 1 + 3 + 2 = 6 **Example 2:** **Input:** nums = [5,1,6] **Output:** 28 **Explanation:** The 8 subsets of [5,1,6] are: The empty subset has an XOR total of 0. [5] has an XOR total of 5. [1] has an XOR total of 1. [6] has an XOR total of 6. [5,1] has an XOR total of 5 XOR 1 = 4. [5,6] has an XOR total of 5 XOR 6 = 3. [1,6] has an XOR total of 1 XOR 6 = 7. [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2. 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28 **Example 3:** **Input:** nums = [3,4,5,6,7,8] **Output:** 480 **Explanation:** The sum of all XOR totals for every subset is 480. **Constraints:** * `1 <= nums.length <= 12` * `1 <= nums[i] <= 20`","completion":"def subsetXORSum(nums): ans = 0 n = len(nums) max_val = 1 << n for i in range(1, max_val): xor_total = 0 for j in range(n): if i & (1 << j): xor_total ^= nums[j] ans += xor_total return ans"},{"prompt":"Given an `m x n` `picture` consisting of black `\'B\'` and white `\'W\'` pixels and an integer target, return _the number of **black** lonely pixels_. A black lonely pixel is a character `\'B\'` that located at a specific position `(r, c)` where: * Row `r` and column `c` both contain exactly `target` black pixels. * For all rows that have a black pixel at column `c`, they should be exactly the same as row `r`. **Example 1:** **Input:** picture = [[ W , B , W , B , B , W ],[ W , B , W , B , B , W ],[ W , B , W , B , B , W ],[ W , W , B , W , B , W ]], target = 3 **Output:** 6 **Explanation:** All the green \'B\' are the black pixels we need (all \'B\'s at column 1 and 3). Take \'B\' at row r = 0 and column c = 1 as an example: Rule 1, row r = 0 and column c = 1 both have exactly target = 3 black pixels. Rule 2, the rows have black pixel at column c = 1 are row 0, row 1 and row 2. They are exactly the same as row r = 0. **Example 2:** **Input:** picture = [[ W , W , B ],[ W , W , B ],[ W , W , B ]], target = 1 **Output:** 0 **Constraints:** * `m == picture.length` * `n == picture[i].length` * `1 <= m, n <= 200` * `picture[i][j]` is `\'W\'` or `\'B\'`. * `1 <= target <= min(m, n)`","completion":"def findBlackPixel(picture, target): m, n = len(picture), len(picture[0]) rows = [0] * m cols = [0] * n rowCounts = {} for i in range(m): row = \\"\\" for j in range(n): if picture[i][j] == \'B\': rows[i] += 1 cols[j] += 1 row += picture[i][j] if rows[i] == target: rowCounts[row] = rowCounts.get(row, 0) + 1 ans = 0 for row, count in rowCounts.items(): if count == target: for j in range(n): if row[j] == \'B\' and cols[j] == target: ans += count return ans"},{"prompt":"You are given an array `items`, where each `items[i] = [typei, colori, namei]` describes the type, color, and name of the `ith` item. You are also given a rule represented by two strings, `ruleKey` and `ruleValue`. The `ith` item is said to match the rule if **one** of the following is true: * `ruleKey == type ` and `ruleValue == typei`. * `ruleKey == color ` and `ruleValue == colori`. * `ruleKey == name ` and `ruleValue == namei`. Return _the number of items that match the given rule_. **Example 1:** **Input:** items = [[ phone , blue , pixel ],[ computer , silver , lenovo ],[ phone , gold , iphone ]], ruleKey = color , ruleValue = silver **Output:** 1 **Explanation:** There is only one item matching the given rule, which is [ computer , silver , lenovo ]. **Example 2:** **Input:** items = [[ phone , blue , pixel ],[ computer , silver , phone ],[ phone , gold , iphone ]], ruleKey = type , ruleValue = phone **Output:** 2 **Explanation:** There are only two items matching the given rule, which are [ phone , blue , pixel ] and [ phone , gold , iphone ]. Note that the item [ computer , silver , phone ] does not match. **Constraints:** * `1 <= items.length <= 104` * `1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10` * `ruleKey` is equal to either `type `, `color `, or `name `. * All strings consist only of lowercase letters.","completion":"def countMatches(items, ruleKey, ruleValue): count = 0 index = {\\"type\\": 0, \\"color\\": 1, \\"name\\": 2}[ruleKey] for item in items: if item[index] == ruleValue: count += 1 return count"},{"prompt":"You are given an integer `n` and an integer `p` in the range `[0, n 1]`. Representing a **0indexed** array `arr` of length `n` where all positions are set to `0`\'s, except position `p` which is set to `1`. You are also given an integer array `banned` containing some positions from the array. For the **i****th** position in `banned`, `arr[banned[i]] = 0`, and `banned[i] != p`. You can perform **multiple** operations on `arr`. In an operation, you can choose a **subarray** with size `k` and **reverse** the subarray. However, the `1` in `arr` should never go to any of the positions in `banned`. In other words, after each operation `arr[banned[i]]` **remains** `0`. _Return an array_ `ans` _where_ _for each_ `i` _from_ `[0, n 1]`, `ans[i]` _is the **minimum** number of reverse operations needed to bring the_ `1` _to position_ `i` _in arr_, _or_ `1` _if it is impossible_. * A **subarray** is a contiguous **nonempty** sequence of elements within an array. * The values of `ans[i]` are independent for all `i`\'s. * The **reverse** of an array is an array containing the values in **reverse order**. **Example 1:** **Input:** n = 4, p = 0, banned = [1,2], k = 4 **Output:** [0,1,1,1] **Explanation:** In this case `k = 4` so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is `0`. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is `1`. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is `1`. **Example 2:** **Input:** n = 5, p = 0, banned = [2,4], k = 3 **Output:** [0,1,1,1,1] **Explanation:** In this case the 1 is initially at position 0, so the answer for that position is `0`. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray `[0, 2]` for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn\'t happen. So, we can\'t move the 1 from position 0, making the result for all the other positions `1`. **Example 3:** **Input:** n = 4, p = 2, banned = [0,1,3], k = 1 **Output:** [1,1,0,1] **Explanation:** In this case we can only perform reverse operations of size 1. So the 1 never changes its position. **Constraints:** * `1 <= n <= 105` * `0 <= p <= n 1` * `0 <= banned.length <= n 1` * `0 <= banned[i] <= n 1` * `1 <= k <= n` * `banned[i] != p` * all values in `banned` are **unique**","completion":"def reach_position(n, p, banned, k): banned_positions = set(banned) ans = [0] * n for i in range(n): if i in banned_positions or i == p: ans[i] = -1 continue an = abs(p - i) // k if abs(p - i) % k == 0 and (an & 1) == (((n - 1) & 1) ^ (k & 1)): steps = an else: steps = -1 ans[i] = steps ans[p] = 0 return ans"},{"prompt":"Given a string `s` containing only lowercase English letters and the `\'?\'` character, convert **all** the `\'?\'` characters into lowercase letters such that the final string does not contain any **consecutive repeating** characters. You **cannot** modify the non `\'?\'` characters. It is **guaranteed** that there are no consecutive repeating characters in the given string **except** for `\'?\'`. Return _the final string after all the conversions (possibly zero) have been made_. If there is more than one solution, return **any of them**. It can be shown that an answer is always possible with the given constraints. **Example 1:** **Input:** s = ?zs **Output:** azs **Explanation:** There are 25 solutions for this problem. From azs to yzs , all are valid. Only z is an invalid modification as the string will consist of consecutive repeating characters in zzs . **Example 2:** **Input:** s = ubv?w **Output:** ubvaw **Explanation:** There are 24 solutions for this problem. Only v and w are invalid modifications as the strings will consist of consecutive repeating characters in ubvvw and ubvww . **Constraints:** * `1 <= s.length <= 100` * `s` consist of lowercase English letters and `\'?\'`.","completion":"from collections import defaultdict def dfs(node, parent, graph, count): if node != 0 and parent == 0: count[0] += 1 for neighbor in graph[node]: if neighbor != parent: dfs(neighbor, node, graph, count) def minReorder(n, connections): graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) count = [0] dfs(0, -1, graph, count) return count[0]"},{"prompt":"You want to water `n` plants in your garden with a watering can. The plants are arranged in a row and are labeled from `0` to `n 1` from left to right where the `ith` plant is located at `x = i`. There is a river at `x = 1` that you can refill your watering can at. Each plant needs a specific amount of water. You will water the plants in the following way: * Water the plants in order from left to right. * After watering the current plant, if you do not have enough water to **completely** water the next plant, return to the river to fully refill the watering can. * You **cannot** refill the watering can early. You are initially at the river (i.e., `x = 1`). It takes **one step** to move **one unit** on the xaxis. Given a **0indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and an integer `capacity` representing the watering can capacity, return _the **number of steps** needed to water all the plants_. **Example 1:** **Input:** plants = [2,2,3,3], capacity = 5 **Output:** 14 **Explanation:** Start at the river with a full watering can: Walk to plant 0 (1 step) and water it. Watering can has 3 units of water. Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water. Since you cannot completely water plant 2, walk back to the river to refill (2 steps). Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water. Since you cannot completely water plant 3, walk back to the river to refill (3 steps). Walk to plant 3 (4 steps) and water it. Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14. **Example 2:** **Input:** plants = [1,1,1,4,2,3], capacity = 4 **Output:** 30 **Explanation:** Start at the river with a full watering can: Water plants 0, 1, and 2 (3 steps). Return to river (3 steps). Water plant 3 (4 steps). Return to river (4 steps). Water plant 4 (5 steps). Return to river (5 steps). Water plant 5 (6 steps). Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30. **Example 3:** **Input:** plants = [7,7,7,7,7,7,7], capacity = 8 **Output:** 49 **Explanation:** You have to refill before watering each plant. Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49. **Constraints:** * `n == plants.length` * `1 <= n <= 1000` * `1 <= plants[i] <= 106` * `max(plants[i]) <= capacity <= 109`","completion":"from collections import defaultdict def deleteDuplicateFolder(paths): graph = defaultdict(set) count = defaultdict(int) for path in paths: serialized_path = \\"\\" for folder in path: serialized_path += \\"/\\" + folder graph[serialized_path].add(folder) for value in graph.values(): count[str(value)] += 1 ans = [] for path in paths: serialized_path = \\"\\" duplicate = False for folder in path: serialized_path += \\"/\\" + folder if count[str(graph[serialized_path])] > 1: duplicate = True break if not duplicate: ans.append(path) return ans"},{"prompt":"a gold mine `grid` of size `m x n`, each cell in this mine has an integer representing the amount of gold in that cell, `0` if it is empty. Return the maximum amount of gold you can collect under the conditions: * Every time you are located in a cell you will collect all the gold in that cell. * From your position, you can walk one step to the left, right, up, or down. * You can\'t visit the same cell more than once. * Never visit a cell with `0` gold. * You can start and stop collecting gold from **any** position in the grid that has some gold. **Example 1:** **Input:** grid = [[0,6,0],[5,8,7],[0,9,0]] **Output:** 24 **Explanation:** [[0,6,0], [5,8,7], [0,9,0]] Path to get the maximum gold, 9 > 8 > 7. **Example 2:** **Input:** grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] **Output:** 28 **Explanation:** [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] Path to get the maximum gold, 1 > 2 > 3 > 4 > 5 > 6 > 7. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 15` * `0 <= grid[i][j] <= 100` * There are at most **25** cells containing gold.","completion":"def longest_wpi(hours): score = 0 max_length = 0 first_occurrence = {} for i, h in enumerate(hours): score += 1 if h > 8 else -1 if score > 0: max_length = i + 1 else: if score not in first_occurrence: first_occurrence[score] = i if score - 1 in first_occurrence: max_length = max(max_length, i - first_occurrence[score - 1]) return max_length"},{"prompt":"Given a 2D `grid` of size `m x n` and an integer `k`. You need to shift the `grid` `k` times. In one shift operation: * Element at `grid[i][j]` moves to `grid[i][j + 1]`. * Element at `grid[i][n 1]` moves to `grid[i + 1][0]`. * Element at `grid[m 1][n 1]` moves to `grid[0][0]`. Return the _2D grid_ after applying shift operation `k` times. **Example 1:** **Input:** `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 1 **Output:** [[9,1,2],[3,4,5],[6,7,8]] **Example 2:** **Input:** `grid` = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 **Output:** [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] **Example 3:** **Input:** `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 9 **Output:** [[1,2,3],[4,5,6],[7,8,9]] **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m <= 50` * `1 <= n <= 50` * `1000 <= grid[i][j] <= 1000` * `0 <= k <= 100`","completion":"def dayOfYear(date: str) -> int: year, month, day = map(int, date.split(\'-\')) daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0): daysInMonth[2] = 29 dayOfYear = sum(daysInMonth[:month]) + day return dayOfYear"},{"prompt":"You have two types of tiles: a `2 x 1` domino shape and a tromino shape. You may rotate these shapes. Given an integer n, return _the number of ways to tile an_ `2 x n` _board_. Since the answer may be very large, return it **modulo** `109 + 7`. In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile. **Example 1:** **Input:** n = 3 **Output:** 5 **Explanation:** The five different ways are show above. **Example 2:** **Input:** n = 1 **Output:** 1 **Constraints:** * `1 <= n <= 1000`","completion":"def is_ideal_permutation(nums): for i, num in enumerate(nums): if abs(num - i) > 1: return False return True"},{"prompt":"Given a **0indexed** integer array `nums`, find a **0indexed** integer array `answer` where: * `answer.length == nums.length`. * `answer[i] = |leftSum[i] rightSum[i]|`. Where: * `leftSum[i]` is the sum of elements to the left of the index `i` in the array `nums`. If there is no such element, `leftSum[i] = 0`. * `rightSum[i]` is the sum of elements to the right of the index `i` in the array `nums`. If there is no such element, `rightSum[i] = 0`. Return _the array_ `answer`. **Example 1:** **Input:** nums = [10,4,8,3] **Output:** [15,1,11,22] **Explanation:** The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0]. The array answer is [|0 15|,|10 11|,|14 3|,|22 0|] = [15,1,11,22]. **Example 2:** **Input:** nums = [1] **Output:** [0] **Explanation:** The array leftSum is [0] and the array rightSum is [0]. The array answer is [|0 0|] = [0]. **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i] <= 105`","completion":"def get_answer(nums): n = len(nums) left_sum, right_sum, answer = [0] * n, [0] * n, [0] * n for i in range(1, n): left_sum[i] = left_sum[i - 1] + nums[i - 1] for i in range(n - 2, -1, -1): right_sum[i] = right_sum[i + 1] + nums[i + 1] for i in range(n): answer[i] = abs(left_sum[i] - right_sum[i]) return answer"},{"prompt":"_(This problem is an **interactive problem**.)_ Each ship is located at an integer point on the sea represented by a cartesian plane, and each integer point may contain at most 1 ship. You have a function `Sea.hasShips(topRight, bottomLeft)` which takes two points as arguments and returns `true` If there is at least one ship in the rectangle represented by the two points, including on the boundary. Given two points: the top right and bottom left corners of a rectangle, return the number of ships present in that rectangle. It is guaranteed that there are **at most 10 ships** in that rectangle. Submissions making **more than 400 calls** to `hasShips` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification. **Example :** **Input:** ships = [[1,1],[2,2],[3,3],[5,5]], topRight = [4,4], bottomLeft = [0,0] **Output:** 3 **Explanation:** From [0,0] to [4,4] we can count 3 ships within the range. **Example 2:** **Input:** ans = [[1,1],[2,2],[3,3]], topRight = [1000,1000], bottomLeft = [0,0] **Output:** 3 **Constraints:** * On the input `ships` is only given to initialize the map internally. You must solve this problem blindfolded . In other words, you must find the answer using the given `hasShips` API, without knowing the `ships` position. * `0 <= bottomLeft[0] <= topRight[0] <= 1000` * `0 <= bottomLeft[1] <= topRight[1] <= 1000` * `topRight != bottomLeft`","completion":"from datetime import datetime def countDaysBetweenDates(date1, date2): d1 = datetime.strptime(date1, \\"%Y-%m-%d\\") d2 = datetime.strptime(date2, \\"%Y-%m-%d\\") return abs((d2 - d1).days)"},{"prompt":"You are given a **0indexed** string `hamsters` where `hamsters[i]` is either: * `\'H\'` indicating that there is a hamster at index `i`, or * `\'.\'` indicating that index `i` is empty. You will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index `i` can be fed if you place a food bucket at index `i 1` **and/or** at index `i + 1`. Return _the minimum number of food buckets you should **place at empty indices** to feed all the hamsters or_ `1` _if it is impossible to feed all of them_. **Example 1:** **Input:** hamsters = H..H **Output:** 2 **Explanation:** We place two food buckets at indices 1 and 2. It can be shown that if we place only one food bucket, one of the hamsters will not be fed. **Example 2:** **Input:** hamsters = .H.H. **Output:** 1 **Explanation:** We place one food bucket at index 2. **Example 3:** **Input:** hamsters = .HHH. **Output:** 1 **Explanation:** If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat. **Constraints:** * `1 <= hamsters.length <= 105` * `hamsters[i]` is either`\'H\'` or `\'.\'`.","completion":"def num_special_subsequences(nums): zeros, ones, twos = 0, 0, 0 mod = 1000000007 for num in nums: if num == 0: zeros = (zeros + 1) % mod elif num == 1: ones = (ones + zeros) % mod else: twos = (twos + ones) % mod return twos"},{"prompt":"You are given an elevation map represents as an integer array `heights` where `heights[i]` representing the height of the terrain at index `i`. The width at each index is `1`. You are also given two integers `volume` and `k`. `volume` units of water will fall at index `k`. Water first drops at the index `k` and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules: * If the droplet would eventually fall by moving left, then move left. * Otherwise, if the droplet would eventually fall by moving right, then move right. * Otherwise, rise to its current position. Here, **eventually fall ** means that the droplet will eventually be at a lower level if it moves in that direction. Also, level means the height of the terrain plus any water in that column. We can assume there is infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than one grid block, and each unit of water has to be in exactly one block. **Example 1:** **Input:** heights = [2,1,1,2,1,2,2], volume = 4, k = 3 **Output:** [2,2,2,3,2,2,2] **Explanation:** The first drop of water lands at index k = 3. When moving left or right, the water can only move to the same level or a lower level. (By level, we mean the total height of the terrain plus any water in that column.) Since moving left will eventually make it fall, it moves left. (A droplet made to fall means go to a lower height than it was at previously.) Since moving left will not make it fall, it stays in place. The next droplet falls at index k = 3. Since the new droplet moving left will eventually make it fall, it moves left. Notice that the droplet still preferred to move left, even though it could move right (and moving right makes it fall quicker.) The third droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would eventually make it fall, it moves right. Finally, the fourth droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would not eventually make it fall, it stays in place. **Example 2:** **Input:** heights = [1,2,3,4], volume = 2, k = 2 **Output:** [2,3,3,4] **Explanation:** The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height. **Example 3:** **Input:** heights = [3,1,3], volume = 5, k = 1 **Output:** [4,4,4] **Constraints:** * `1 <= heights.length <= 100` * `0 <= heights[i] <= 99` * `0 <= volume <= 2000` * `0 <= k < heights.length`","completion":"def min_moves(target: int) -> int: target = abs(target) step = 0 total = 0 while total < target or (total - target) % 2 != 0: step += 1 total += step return step"},{"prompt":"Given a positive integer `n`, find _the smallest integer which has exactly the same digits existing in the integer_ `n` _and is greater in value than_ `n`. If no such positive integer exists, return `1`. **Note** that the returned integer should fit in **32bit integer**, if there is a valid answer but it does not fit in **32bit integer**, return `1`. **Example 1:** **Input:** n = 12 **Output:** 21 **Example 2:** **Input:** n = 21 **Output:** 1 **Constraints:** * `1 <= n <= 231 1`","completion":"from itertools import permutations def nextGreaterElement(n: int) -> int: num_str = str(n) num_permutations = sorted(set(int(\\"\\".join(p)) for p in permutations(num_str))) index = num_permutations.index(n) if index + 1 < len(num_permutations) and num_permutations[index + 1] <= 2**31 - 1: return num_permutations[index + 1] return -1"},{"prompt":"You are given a string `s` that consists of only digits. Check if we can split `s` into **two or more nonempty substrings** such that the **numerical values** of the substrings are in **descending order** and the **difference** between numerical values of every two **adjacent** **substrings** is equal to `1`. * For example, the string `s = 0090089 ` can be split into `[ 0090 , 089 ]` with numerical values `[90,89]`. The values are in descending order and adjacent values differ by `1`, so this way is valid. * Another example, the string `s = 001 ` can be split into `[ 0 , 01 ]`, `[ 00 , 1 ]`, or `[ 0 , 0 , 1 ]`. However all the ways are invalid because they have numerical values `[0,1]`, `[0,1]`, and `[0,0,1]` respectively, all of which are not in descending order. Return `true` _if it is possible to split_ `s`​​​​​​ _as described above__, or_ `false` _otherwise._ A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** s = 1234 **Output:** false **Explanation:** There is no valid way to split s. **Example 2:** **Input:** s = 050043 **Output:** true **Explanation:** s can be split into [ 05 , 004 , 3 ] with numerical values [5,4,3]. The values are in descending order with adjacent values differing by 1. **Example 3:** **Input:** s = 9080701 **Output:** false **Explanation:** There is no valid way to split s. **Constraints:** * `1 <= s.length <= 20` * `s` only consists of digits.","completion":"def maxAbsoluteSum(nums): max_sum, min_sum, max_so_far, min_so_far = 0, 0, 0, 0 for num in nums: max_so_far = max(num, max_so_far + num) max_sum = max(max_sum, max_so_far) min_so_far = min(num, min_so_far + num) min_sum = min(min_sum, min_so_far) return max(max_sum, abs(min_sum))"},{"prompt":"You are given a string `allowed` consisting of **distinct** characters and an array of strings `words`. A string is **consistent** if all characters in the string appear in the string `allowed`. Return _the number of **consistent** strings in the array_ `words`. **Example 1:** **Input:** allowed = ab , words = [ ad , bd , aaab , baa , badab ] **Output:** 2 **Explanation:** Strings aaab and baa are consistent since they only contain characters \'a\' and \'b\'. **Example 2:** **Input:** allowed = abc , words = [ a , b , c , ab , ac , bc , abc ] **Output:** 7 **Explanation:** All strings are consistent. **Example 3:** **Input:** allowed = cad , words = [ cc , acd , b , ba , bac , bad , ac , d ] **Output:** 4 **Explanation:** Strings cc , acd , ac , and d are consistent. **Constraints:** * `1 <= words.length <= 104` * `1 <= allowed.length <= 26` * `1 <= words[i].length <= 10` * The characters in `allowed` are **distinct**. * `words[i]` and `allowed` contain only lowercase English letters.","completion":"def find_latest_step(arr, m): n = len(arr) length_left, length_right = [0] * (n + 2), [0] * (n + 2) count, result = 0, -1 for i, pos in enumerate(arr): left_length = length_right[pos - 1] right_length = length_left[pos + 1] new_length = left_length + right_length + 1 if left_length == m or right_length == m: count -= 1 if new_length == m: count += 1 if new_length > 0: length_left[pos - left_length] = new_length length_right[pos + right_length] = new_length result = i + 1 return result if count > 0 else -1"},{"prompt":"You are given two strings `start` and `target`, both of length `n`. Each string consists **only** of the characters `\'L\'`, `\'R\'`, and `\'_\'` where: * The characters `\'L\'` and `\'R\'` represent pieces, where a piece `\'L\'` can move to the **left** only if there is a **blank** space directly to its left, and a piece `\'R\'` can move to the **right** only if there is a **blank** space directly to its right. * The character `\'_\'` represents a blank space that can be occupied by **any** of the `\'L\'` or `\'R\'` pieces. Return `true` _if it is possible to obtain the string_ `target` _by moving the pieces of the string_ `start` _**any** number of times_. Otherwise, return `false`. **Example 1:** **Input:** start = _L__R__R_ , target = L______RR **Output:** true **Explanation:** We can obtain the string target from start by doing the following moves: Move the first piece one step to the left, start becomes equal to **L**___R__R_ . Move the last piece one step to the right, start becomes equal to L___R___**R** . Move the second piece three steps to the right, start becomes equal to L______**R**R . Since it is possible to get the string target from start, we return true. **Example 2:** **Input:** start = R_L_ , target = __LR **Output:** false **Explanation:** The \'R\' piece in the string start can move one step to the right to obtain _**R**L_ . After that, no pieces can move anymore, so it is impossible to obtain the string target from start. **Example 3:** **Input:** start = _R , target = R_ **Output:** false **Explanation:** The piece in the string start can move only to the right, so it is impossible to obtain the string target from start. **Constraints:** * `n == start.length == target.length` * `1 <= n <= 105` * `start` and `target` consist of the characters `\'L\'`, `\'R\'`, and `\'_\'`.","completion":"def canTransform(start: str, target: str) -> bool: n = len(start) p, q = 0, 0 while p < n and q < n: while p < n and start[p] == \'_\': p += 1 while q < n and target[q] == \'_\': q += 1 if p == n or q == n: break if start[p] != target[q]: return False if start[p] == \'L\' and p < q: return False if start[p] == \'R\' and p > q: return False p += 1 q += 1 return p == n and q == n"},{"prompt":"You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars. To cut a piece of wood, you must make a vertical or horizontal cut across the **entire** height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you **cannot** rotate a piece to swap its height and width. Return _the **maximum** money you can earn after cutting an_ `m x n` _piece of wood_. Note that you can cut the piece of wood as many times as you want. **Example 1:** **Input:** m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]] **Output:** 19 **Explanation:** The diagram above shows a possible scenario. It consists of: 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14. 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3. 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2. This obtains a total of 14 + 3 + 2 = 19 money earned. It can be shown that 19 is the maximum amount of money that can be earned. **Example 2:** **Input:** m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]] **Output:** 32 **Explanation:** The diagram above shows a possible scenario. It consists of: 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30. 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2. This obtains a total of 30 + 2 = 32 money earned. It can be shown that 32 is the maximum amount of money that can be earned. Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood. **Constraints:** * `1 <= m, n <= 200` * `1 <= prices.length <= 2 * 104` * `prices[i].length == 3` * `1 <= hi <= m` * `1 <= wi <= n` * `1 <= pricei <= 106` * All the shapes of wood `(hi, wi)` are pairwise **distinct**.","completion":"def max_count_target(nums, key): count = {} max_count = 0 max_target = -1 for i in range(1, len(nums)): if nums[i - 1] == key: count[nums[i]] = count.get(nums[i], 0) + 1 if count[nums[i]] > max_count: max_count = count[nums[i]] max_target = nums[i] return max_target"},{"prompt":"mplement the class `SubrectangleQueries` which receives a `rows x cols` rectangle as a matrix of integers in the constructor and supports two methods: 1. `updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)` * Updates all values with `newValue` in the subrectangle whose upper left coordinate is `(row1,col1)` and bottom right coordinate is `(row2,col2)`. 2. `getValue(int row, int col)` * Returns the current value of the coordinate `(row,col)` from the rectangle. **Example 1:** **Input** [ SubrectangleQueries , getValue , updateSubrectangle , getValue , getValue , updateSubrectangle , getValue , getValue ] [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]] **Output** [null,1,null,5,5,null,10,5] **Explanation** SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]); // The initial rectangle (4x3) looks like: // 1 2 1 // 4 3 4 // 3 2 1 // 1 1 1 subrectangleQueries.getValue(0, 2); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 5 5 5 subrectangleQueries.getValue(0, 2); // return 5 subrectangleQueries.getValue(3, 1); // return 5 subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 10 10 10 subrectangleQueries.getValue(3, 1); // return 10 subrectangleQueries.getValue(0, 2); // return 5 **Example 2:** **Input** [ SubrectangleQueries , getValue , updateSubrectangle , getValue , getValue , updateSubrectangle , getValue ] [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]] **Output** [null,1,null,100,100,null,20] **Explanation** SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]); subrectangleQueries.getValue(0, 0); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100); subrectangleQueries.getValue(0, 0); // return 100 subrectangleQueries.getValue(2, 2); // return 100 subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20); subrectangleQueries.getValue(2, 2); // return 20 **Constraints:** * There will be at most `500` operations considering both methods: `updateSubrectangle` and `getValue`. * `1 <= rows, cols <= 100` * `rows == rectangle.length` * `cols == rectangle[i].length` * `0 <= row1 <= row2 < rows` * `0 <= col1 <= col2 < cols` * `1 <= newValue, rectangle[i][j] <= 10^9` * `0 <= row < rows` * `0 <= col < cols`","completion":"def countNegatives(grid): m, n, count, i, j = len(grid), len(grid[0]), 0, 0, len(grid[0]) - 1 while i < m and j >= 0: if grid[i][j] < 0: count += j + 1 i += 1 else: j -= 1 return count"},{"prompt":"You are given a **0indexed** string `num` of length `n` consisting of digits. Return `true` _if for **every** index_ `i` _in the range_ `0 <= i < n`_, the digit_ `i` _occurs_ `num[i]` _times in_ `num`_, otherwise return_ `false`. **Example 1:** **Input:** num = 1210 **Output:** true **Explanation:** num[0] = \'1\'. The digit 0 occurs once in num. num[1] = \'2\'. The digit 1 occurs twice in num. num[2] = \'1\'. The digit 2 occurs once in num. num[3] = \'0\'. The digit 3 occurs zero times in num. The condition holds true for every index in 1210 , so return true. **Example 2:** **Input:** num = 030 **Output:** false **Explanation:** num[0] = \'0\'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = \'3\'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = \'0\'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false. **Constraints:** * `n == num.length` * `1 <= n <= 10` * `num` consists of digits.","completion":"def rearrange_array(nums): nums.sort() for i in range(1, len(nums) - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"prompt":"Given an `n x n` integer matrix `grid`, return _the minimum sum of a **falling path with nonzero shifts**_. A **falling path with nonzero shifts** is a choice of exactly one element from each row of `grid` such that no two elements chosen in adjacent rows are in the same column. **Example 1:** **Input:** arr = [[1,2,3],[4,5,6],[7,8,9]] **Output:** 13 **Explanation:** The possible falling paths are: [1,5,9], [1,5,7], [1,6,7], [1,6,8], [2,4,8], [2,4,9], [2,6,7], [2,6,8], [3,4,8], [3,4,9], [3,5,7], [3,5,9] The falling path with the smallest sum is [1,5,7], so the answer is 13. **Example 2:** **Input:** grid = [[7]] **Output:** 7 **Constraints:** * `n == grid.length == grid[i].length` * `1 <= n <= 200` * `99 <= grid[i][j] <= 99`","completion":"def day_of_the_week(day, month, year): days = [\\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\"] if month < 3: month += 12 year -= 1 k = year % 100 j = year // 100 day_of_week = (day + 13 * (month + 1) // 5 + k + k // 4 + 5 * j + j // 4) % 7 return days[day_of_week]"},{"prompt":"You are given a **0indexed** integer array `nums` and a target element `target`. A **target index** is an index `i` such that `nums[i] == target`. Return _a list of the target indices of_ `nums` after _sorting_ `nums` _in **nondecreasing** order_. If there are no target indices, return _an **empty** list_. The returned list must be sorted in **increasing** order. **Example 1:** **Input:** nums = [1,2,5,2,3], target = 2 **Output:** [1,2] **Explanation:** After sorting, nums is [1,**2**,**2**,3,5]. The indices where nums[i] == 2 are 1 and 2. **Example 2:** **Input:** nums = [1,2,5,2,3], target = 3 **Output:** [3] **Explanation:** After sorting, nums is [1,2,2,**3**,5]. The index where nums[i] == 3 is 3. **Example 3:** **Input:** nums = [1,2,5,2,3], target = 5 **Output:** [4] **Explanation:** After sorting, nums is [1,2,2,3,**5**]. The index where nums[i] == 5 is 4. **Constraints:** * `1 <= nums.length <= 100` * `1 <= nums[i], target <= 100`","completion":"def maxMatrixSum(matrix): n = len(matrix) minValue, negativeCount, total = float(\'inf\'), 0, 0 for i in range(n): for j in range(n): total += abs(matrix[i][j]) minValue = min(minValue, abs(matrix[i][j])) if matrix[i][j] < 0: negativeCount += 1 if negativeCount % 2 == 0: return total else: return total - 2 * minValue"},{"prompt":"You are given two lists of closed intervals, `firstList` and `secondList`, where `firstList[i] = [starti, endi]` and `secondList[j] = [startj, endj]`. Each list of intervals is pairwise **disjoint** and in **sorted order**. Return _the intersection of these two interval lists_. A **closed interval** `[a, b]` (with `a <= b`) denotes the set of real numbers `x` with `a <= x <= b`. The **intersection** of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of `[1, 3]` and `[2, 4]` is `[2, 3]`. **Example 1:** **Input:** firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]] **Output:** [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] **Example 2:** **Input:** firstList = [[1,3],[5,9]], secondList = [] **Output:** [] **Constraints:** * `0 <= firstList.length, secondList.length <= 1000` * `firstList.length + secondList.length >= 1` * `0 <= starti < endi <= 109` * `endi < starti+1` * `0 <= startj < endj <= 109` * `endj < startj+1`","completion":"from itertools import permutations def largestTimeFromDigits(arr): max_time = -1 for h, i, j, k in permutations(arr): hour = h * 10 + i minute = j * 10 + k time = hour * 60 + minute if hour < 24 and minute < 60 and time > max_time: max_time = time if max_time == -1: return \\"\\" else: return \\"{:02d}:{:02d}\\".format(max_time // 60, max_time % 60)"},{"prompt":"You are given an integer array `nums` consisting of `n` elements, and an integer `k`. Find a contiguous subarray whose **length is greater than or equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `105` will be accepted. **Example 1:** **Input:** nums = [1,12,5,6,50,3], k = 4 **Output:** 12.75000 **Explanation:** When the length is 4, averages are [0.5, 12.75, 10.5] and the maximum average is 12.75 When the length is 5, averages are [10.4, 10.8] and the maximum average is 10.8 When the length is 6, averages are [9.16667] and the maximum average is 9.16667 The maximum average is when we choose a subarray of length 4 (i.e., the sub array [12, 5, 6, 50]) which has the max average 12.75, so we return 12.75 Note that we do not consider the subarrays of length < 4. **Example 2:** **Input:** nums = [5], k = 1 **Output:** 5.00000 **Constraints:** * `n == nums.length` * `1 <= k <= n <= 104` * `104 <= nums[i] <= 104`","completion":"def findMaxAverage(nums, k): total = sum(nums[:k]) max_avg = total / k for i in range(k, len(nums)): total += nums[i] - nums[i - k] max_avg = max(max_avg, total / k) return max_avg"},{"prompt":"Given two arrays of integers with equal lengths, return the maximum value of: `|arr1[i] arr1[j]| + |arr2[i] arr2[j]| + |i j|` where the maximum is taken over all `0 <= i, j < arr1.length`. **Example 1:** **Input:** arr1 = [1,2,3,4], arr2 = [1,4,5,6] **Output:** 13 **Example 2:** **Input:** arr1 = [1,2,5,0,10], arr2 = [0,2,1,7,4] **Output:** 20 **Constraints:** * `2 <= arr1.length == arr2.length <= 40000` * `10^6 <= arr1[i], arr2[i] <= 10^6`","completion":"def maxAbsValExpr(arr1, arr2): result = 0 max_sum = [float(\'-inf\')] * 4 for i in range(len(arr1)): max_sum[0] = max(max_sum[0], arr1[i] + arr2[i] + i) max_sum[1] = max(max_sum[1], arr1[i] - arr2[i] + i) max_sum[2] = max(max_sum[2], -arr1[i] + arr2[i] + i) max_sum[3] = max(max_sum[3], -arr1[i] - arr2[i] + i) for i in range(len(arr1)): result = max(result, max_sum[0] - arr1[i] - arr2[i] - i) result = max(result, max_sum[1] - arr1[i] + arr2[i] - i) result = max(result, max_sum[2] + arr1[i] - arr2[i] - i) result = max(result, max_sum[3] + arr1[i] + arr2[i] - i) return result"},{"prompt":"There are `n` people standing in a line labeled from `1` to `n`. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction. * For example, once the pillow reaches the `nth` person they pass it to the `n 1th` person, then to the `n 2th` person and so on. Given the two positive integers `n` and `time`, return _the index of the person holding the pillow after_ `time` _seconds_. **Example 1:** **Input:** n = 4, time = 5 **Output:** 2 **Explanation:** People pass the pillow in the following way: 1 > 2 > 3 > 4 > 3 > 2. Afer five seconds, the pillow is given to the 2nd person. **Example 2:** **Input:** n = 3, time = 2 **Output:** 3 **Explanation:** People pass the pillow in the following way: 1 > 2 > 3. Afer two seconds, the pillow is given to the 3rd person. **Constraints:** * `2 <= n <= 1000` * `1 <= time <= 1000`","completion":"def pillowHolder(n, time): time %= (2 * n - 2) if time <= n - 1: return time + 1 else: return 2 * n - time - 1"},{"prompt":"Given a string `s`, return _the string after replacing every uppercase letter with the same lowercase letter_. **Example 1:** **Input:** s = Hello **Output:** hello **Example 2:** **Input:** s = here **Output:** here **Example 3:** **Input:** s = LOVELY **Output:** lovely **Constraints:** * `1 <= s.length <= 100` * `s` consists of printable ASCII characters.","completion":"def toLowerCase(s: str) -> str: return s.lower()"},{"prompt":"You are given two strings `a` and `b` of the same length. Choose an index and split both strings **at the same index**, splitting `a` into two strings: `aprefix` and `asuffix` where `a = aprefix + asuffix`, and splitting `b` into two strings: `bprefix` and `bsuffix` where `b = bprefix + bsuffix`. Check if `aprefix + bsuffix` or `bprefix + asuffix` forms a palindrome. When you split a string `s` into `sprefix` and `ssuffix`, either `ssuffix` or `sprefix` is allowed to be empty. For example, if `s = abc `, then ` + abc `, `a + bc `, `ab + c ` , and `abc + ` are valid splits. Return `true` _if it is possible to form_ _a palindrome string, otherwise return_ `false`. **Notice** that `x + y` denotes the concatenation of strings `x` and `y`. **Example 1:** **Input:** a = x , b = y **Output:** true **Explaination:** If either a or b are palindromes the answer is true since you can split in the following way: aprefix = , asuffix = x bprefix = , bsuffix = y Then, aprefix + bsuffix = + y = y , which is a palindrome. **Example 2:** **Input:** a = xbdef , b = xecab **Output:** false **Example 3:** **Input:** a = ulacfd , b = jizalu **Output:** true **Explaination:** Split them at index 3: aprefix = ula , asuffix = cfd bprefix = jiz , bsuffix = alu Then, aprefix + bsuffix = ula + alu = ulaalu , which is a palindrome. **Constraints:** * `1 <= a.length, b.length <= 105` * `a.length == b.length` * `a` and `b` consist of lowercase English letters","completion":"def min_difference(nums): size = len(nums) if size < 5: return 0 nums.sort() return min(nums[-1] - nums[3], nums[-2] - nums[2], nums[-3] - nums[1], nums[-4] - nums[0])"},{"prompt":"You are given an `m x n` integer matrix `grid`. We define an **hourglass** as a part of the matrix with the following form: Return _the **maximum** sum of the elements of an hourglass_. **Note** that an hourglass cannot be rotated and must be entirely contained within the matrix. **Example 1:** **Input:** grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]] **Output:** 30 **Explanation:** The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30. **Example 2:** **Input:** grid = [[1,2,3],[4,5,6],[7,8,9]] **Output:** 35 **Explanation:** There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `3 <= m, n <= 150` * `0 <= grid[i][j] <= 106`","completion":"def max_hourglass_sum(grid): m, n = len(grid), len(grid[0]) max_sum = float(\'-inf\') for i in range(1, m - 1): for j in range(1, n - 1): sum = grid[i-1][j-1] + grid[i-1][j] + grid[i-1][j+1] + grid[i][j] + grid[i+1][j-1] + grid[i+1][j] + grid[i+1][j+1] max_sum = max(max_sum, sum) return max_sum"},{"prompt":"Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n 1`, find all possible paths from node `0` to node `n 1` and return them in **any order**. The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`). **Example 1:** **Input:** graph = [[1,2],[3],[3],[]] **Output:** [[0,1,3],[0,2,3]] **Explanation:** There are two paths: 0 > 1 > 3 and 0 > 2 > 3. **Example 2:** **Input:** graph = [[4,3,1],[3,2,4],[3],[4],[]] **Output:** [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] **Constraints:** * `n == graph.length` * `2 <= n <= 15` * `0 <= graph[i][j] < n` * `graph[i][j] != i` (i.e., there will be no selfloops). * All the elements of `graph[i]` are **unique**. * The input graph is **guaranteed** to be a **DAG**.","completion":"from collections import defaultdict def numRabbits(answers): count = defaultdict(int) res = 0 for a in answers: count[a] += 1 if count[a] == 1: res += (a + 1) elif count[a] > a + 1: count[a] = 1 res += (a + 1) return res"},{"prompt":"You have some apples and a basket that can carry up to `5000` units of weight. Given an integer array `weight` where `weight[i]` is the weight of the `ith` apple, return _the maximum number of apples you can put in the basket_. **Example 1:** **Input:** weight = [100,200,150,1000] **Output:** 4 **Explanation:** All 4 apples can be carried by the basket since their sum of weights is 1450. **Example 2:** **Input:** weight = [900,950,800,1000,700,800] **Output:** 5 **Explanation:** The sum of weights of the 6 apples exceeds 5000 so we choose any 5 of them. **Constraints:** * `1 <= weight.length <= 103` * `1 <= weight[i] <= 103`","completion":"def minHeightShelves(books, shelfWidth): n = len(books) dp = [1000000] * (n + 1) dp[0] = 0 for i in range(1, n + 1): width = 0 height = 0 j = i while j >= 1: width += books[j - 1][0] height = max(height, books[j - 1][1]) if width <= shelfWidth: dp[i] = min(dp[i], dp[j - 1] + height) j -= 1 return dp[n]"},{"prompt":"You are given an integer array `cards` where `cards[i]` represents the **value** of the `ith` card. A pair of cards are **matching** if the cards have the **same** value. Return _the **minimum** number of **consecutive** cards you have to pick up to have a pair of **matching** cards among the picked cards._ If it is impossible to have matching cards, return `1`. **Example 1:** **Input:** cards = [3,4,2,3,4,7] **Output:** 4 **Explanation:** We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal. **Example 2:** **Input:** cards = [1,0,5,3] **Output:** 1 **Explanation:** There is no way to pick up a set of consecutive cards that contain a pair of matching cards. **Constraints:** * `1 <= cards.length <= 105` * `0 <= cards[i] <= 106`","completion":"def partition_string(s, k, fill): partitions = [] current_partition = \'\' for c in s: current_partition += c if len(current_partition) == k: partitions.append(current_partition) current_partition = \'\' if current_partition: current_partition += fill * (k - len(current_partition)) partitions.append(current_partition) return partitions"},{"prompt":"You are given a 2D `matrix` of size `m x n`, consisting of nonnegative integers. You are also given an integer `k`. The **value** of coordinate `(a, b)` of the matrix is the XOR of all `matrix[i][j]` where `0 <= i <= a < m` and `0 <= j <= b < n` **(0indexed)**. Find the `kth` largest value **(1indexed)** of all the coordinates of `matrix`. **Example 1:** **Input:** matrix = [[5,2],[1,6]], k = 1 **Output:** 7 **Explanation:** The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value. **Example 2:** **Input:** matrix = [[5,2],[1,6]], k = 2 **Output:** 5 **Explanation:** The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value. **Example 3:** **Input:** matrix = [[5,2],[1,6]], k = 3 **Output:** 4 **Explanation:** The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value. **Constraints:** * `m == matrix.length` * `n == matrix[i].length` * `1 <= m, n <= 1000` * `0 <= matrix[i][j] <= 106` * `1 <= k <= m * n`","completion":"def maximalNetworkRank(n, roads): degree = [0] * n s = set() for road in roads: degree[road[0]] += 1 degree[road[1]] += 1 s.add(tuple(sorted(road))) ans = 0 for i in range(n): for j in range(i + 1, n): ans = max(ans, degree[i] + degree[j] - (1 if (i, j) in s else 0)) return ans"},{"prompt":"**NoZero integer** is a positive integer that **does not contain any `0`** in its decimal representation. Given an integer `n`, return _a list of two integers_ `[a, b]` _where_: * `a` and `b` are **NoZero integers**. * `a + b = n` The test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them. **Example 1:** **Input:** n = 2 **Output:** [1,1] **Explanation:** Let a = 1 and b = 1. Both a and b are nozero integers, and a + b = 2 = n. **Example 2:** **Input:** n = 11 **Output:** [2,9] **Explanation:** Let a = 2 and b = 9. Both a and b are nozero integers, and a + b = 9 = n. Note that there are other valid answers as [8, 3] that can be accepted. **Constraints:** * `2 <= n <= 104`","completion":"def no_zero_integers(n: int): for a in range(1, n): if \'0\' not in str(a) and \'0\' not in str(n - a): return [a, n - a] return [0, 0] # never gets here"},{"prompt":"You are given an alphanumeric string `s`. (**Alphanumeric string** is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return _the reformatted string_ or return **an empty string** if it is impossible to reformat the string. **Example 1:** **Input:** s = a0b1c2 **Output:** 0a1b2c **Explanation:** No two adjacent characters have the same type in 0a1b2c . a0b1c2 , 0a1b2c , 0c2a1b are also valid permutations. **Example 2:** **Input:** s = leetcode **Output:** **Explanation:** leetcode has only characters so we cannot separate them by digits. **Example 3:** **Input:** s = 1229857369 **Output:** **Explanation:** 1229857369 has only digits so we cannot separate them by characters. **Constraints:** * `1 <= s.length <= 500` * `s` consists of only lowercase English letters and/or digits.","completion":"from collections import deque def reformat(s: str) -> str: letters, digits = deque(), deque() for c in s: if c.isalpha(): letters.append(c) else: digits.append(c) if abs(len(letters) - len(digits)) > 1: return \\"\\" result = [] use_letter = len(letters) > len(digits) while letters or digits: if use_letter: result.append(letters.popleft()) else: result.append(digits.popleft()) use_letter = not use_letter return \'\'.join(result)"},{"prompt":"You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n 1` and exactly `n 1` `edges`. The **root** of the tree is the node `0`, and each node of the tree has **a label** which is a lowercase character given in the string `labels` (i.e. The node with the number `i` has the label `labels[i]`). The `edges` array is given on the form `edges[i] = [ai, bi]`, which means there is an edge between nodes `ai` and `bi` in the tree. Return _an array of size `n`_ where `ans[i]` is the number of nodes in the subtree of the `ith` node which have the same label as node `i`. A subtree of a tree `T` is the tree consisting of a node in `T` and all of its descendant nodes. **Example 1:** **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = abaedcd **Output:** [2,1,1,1,1,1,1] **Explanation:** Node 0 has label \'a\' and its subtree has node 2 with label \'a\' as well, thus the answer is 2. Notice that any node is part of its subtree. Node 1 has a label \'b\'. The subtree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself). **Example 2:** **Input:** n = 4, edges = [[0,1],[1,2],[0,3]], labels = bbbb **Output:** [4,2,1,1] **Explanation:** The subtree of node 2 contains only node 2, so the answer is 1. The subtree of node 3 contains only node 3, so the answer is 1. The subtree of node 1 contains nodes 1 and 2, both have label \'b\', thus the answer is 2. The subtree of node 0 contains nodes 0, 1, 2 and 3, all with label \'b\', thus the answer is 4. **Example 3:** **Input:** n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = aabab **Output:** [3,2,1,1,1] **Constraints:** * `1 <= n <= 105` * `edges.length == n 1` * `edges[i].length == 2` * `0 <= ai, bi < n` * `ai != bi` * `labels.length == n` * `labels` is consisting of only of lowercase English letters.","completion":"def min_subsequence(nums): nums.sort(reverse=True) total_sum, current_sum = sum(nums), 0 result = [] for num in nums: current_sum += num result.append(num) if current_sum > total_sum - current_sum: break return result"},{"prompt":"With respect to a given `puzzle` string, a `word` is _valid_ if both the following conditions are satisfied: * `word` contains the first letter of `puzzle`. * For each letter in `word`, that letter is in `puzzle`. * For example, if the puzzle is `abcdefg `, then valid words are `faced `, `cabbage `, and `baggage `, while * invalid words are `beefed ` (does not include `\'a\'`) and `based ` (includes `\'s\'` which is not in the puzzle). Return _an array_ `answer`_, where_ `answer[i]` _is the number of words in the given word list_ `words` _that is valid with respect to the puzzle_ `puzzles[i]`. **Example 1:** **Input:** words = [ aaaa , asas , able , ability , actt , actor , access ], puzzles = [ aboveyz , abrodyz , abslute , absoryz , actresz , gaswxyz ] **Output:** [1,1,3,2,4,0] **Explanation:** 1 valid word for aboveyz : aaaa 1 valid word for abrodyz : aaaa 3 valid words for abslute : aaaa , asas , able 2 valid words for absoryz : aaaa , asas 4 valid words for actresz : aaaa , asas , actt , access There are no valid words for gaswxyz cause none of the words in the list contains letter \'g\'. **Example 2:** **Input:** words = [ apple , pleas , please ], puzzles = [ aelwxyz , aelpxyz , aelpsxy , saelpxy , xaelpsy ] **Output:** [0,1,3,2,0] **Constraints:** * `1 <= words.length <= 105` * `4 <= words[i].length <= 50` * `1 <= puzzles.length <= 104` * `puzzles[i].length == 7` * `words[i]` and `puzzles[i]` consist of lowercase English letters. * Each `puzzles[i]` does not contain repeated characters.","completion":"def find_num_of_valid_words(words, puzzles): result = [] for puzzle in puzzles: count = 0 puzzle_set = set(puzzle) for word in words: if puzzle[0] in word: if all(c in puzzle_set for c in word): count += 1 result.append(count) return result"},{"prompt":"You are given an integer `n`, the number of teams in a tournament that has strange rules: * If the current number of teams is **even**, each team gets paired with another team. A total of `n / 2` matches are played, and `n / 2` teams advance to the next round. * If the current number of teams is **odd**, one team randomly advances in the tournament, and the rest gets paired. A total of `(n 1) / 2` matches are played, and `(n 1) / 2 + 1` teams advance to the next round. Return _the number of matches played in the tournament until a winner is decided._ **Example 1:** **Input:** n = 7 **Output:** 6 **Explanation:** Details of the tournament: 1st Round: Teams = 7, Matches = 3, and 4 teams advance. 2nd Round: Teams = 4, Matches = 2, and 2 teams advance. 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 3 + 2 + 1 = 6. **Example 2:** **Input:** n = 14 **Output:** 13 **Explanation:** Details of the tournament: 1st Round: Teams = 14, Matches = 7, and 7 teams advance. 2nd Round: Teams = 7, Matches = 3, and 4 teams advance. 3rd Round: Teams = 4, Matches = 2, and 2 teams advance. 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 7 + 3 + 2 + 1 = 13. **Constraints:** * `1 <= n <= 200`","completion":"def numberOfMatches(n: int) -> int: matches = 0 while n > 1: matches += n // 2 n = (n + 1) // 2 return matches"},{"prompt":"You are given a **0indexed** integer array `mapping` which represents the mapping rule of a shuffled decimal system. `mapping[i] = j` means digit `i` should be mapped to digit `j` in this system. The **mapped value** of an integer is the new integer obtained by replacing each occurrence of digit `i` in the integer with `mapping[i]` for all `0 <= i <= 9`. You are also given another integer array `nums`. Return _the array_ `nums` _sorted in **nondecreasing** order based on the **mapped values** of its elements._ **Notes:** * Elements with the same mapped values should appear in the **same relative order** as in the input. * The elements of `nums` should only be sorted based on their mapped values and **not be replaced** by them. **Example 1:** **Input:** mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38] **Output:** [338,38,991] **Explanation:** Map the number 991 as follows: 1. mapping[9] = 6, so all occurrences of the digit 9 will become 6. 2. mapping[1] = 9, so all occurrences of the digit 1 will become 9. Therefore, the mapped value of 991 is 669. 338 maps to 007, or 7 after removing the leading zeros. 38 maps to 07, which is also 7 after removing leading zeros. Since 338 and 38 share the same mapped value, they should remain in the same relative order, so 338 comes before 38. Thus, the sorted array is [338,38,991]. **Example 2:** **Input:** mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123] **Output:** [123,456,789] **Explanation:** 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus, the sorted array is [123,456,789]. **Constraints:** * `mapping.length == 10` * `0 <= mapping[i] <= 9` * All the values of `mapping[i]` are **unique**. * `1 <= nums.length <= 3 * 104` * `0 <= nums[i] < 109`","completion":"def min_buckets(street): buckets = 0 i = 0 n = len(street) while i < n: if street[i] == \'H\': if i + 1 < n and street[i + 1] == \'.\': buckets += 1 i += 2 elif i + 2 < n and street[i + 2] == \'.\': buckets += 1 i += 3 else: return -1 else: i += 1 return buckets"},{"prompt":"You are given an integer `n` representing the number of playing cards you have. A **house of cards** meets the following conditions: * A **house of cards** consists of one or more rows of **triangles** and horizontal cards. * **Triangles** are created by leaning two cards against each other. * One card must be placed horizontally between **all adjacent** triangles in a row. * Any triangle on a row higher than the first must be placed on a horizontal card from the previous row. * Each triangle is placed in the **leftmost** available spot in the row. Return _the number of **distinct** **house of cards** you can build using **all**_ `n` _cards._ Two houses of cards are considered distinct if there exists a row where the two houses contain a different number of cards. **Example 1:** **Input:** n = 16 **Output:** 2 **Explanation:** The two valid houses of cards are shown. The third house of cards in the diagram is not valid because the rightmost triangle on the top row is not placed on top of a horizontal card. **Example 2:** **Input:** n = 2 **Output:** 1 **Explanation:** The one valid house of cards is shown. **Example 3:** **Input:** n = 4 **Output:** 0 **Explanation:** The three houses of cards in the diagram are not valid. The first house of cards needs a horizontal card placed between the two triangles. The second house of cards uses 5 cards. The third house of cards uses 2 cards. **Constraints:** * `1 <= n <= 500`","completion":"from collections import defaultdict def maxQualityRec(adjDict, values, node, timeLeft, visited): if timeLeft < 0: return float(\'-inf\') maxQuality = 0 visited.add(node) for neighbor, time in adjDict[node]: adjDict[neighbor].remove((node, time)) maxQuality = max(maxQuality, maxQualityRec(adjDict, values, neighbor, timeLeft - time, visited)) adjDict[neighbor].append((node, time)) visited.remove(node) return maxQuality + (values[node] if node not in visited else 0) def maxQuality(n, values, edges, maxTime): adjDict = defaultdict(list) for u, v, time in edges: adjDict[u].append((v, time)) adjDict[v].append((u, time)) visited = set() return maxQualityRec(adjDict, values, 0, maxTime, visited)"},{"prompt":"You are given two strings `s` and `t`. In one step, you can append **any character** to either `s` or `t`. Return _the minimum number of steps to make_ `s` _and_ `t` _**anagrams** of each other._ An **anagram** of a string is a string that contains the same characters with a different (or the same) ordering. **Example 1:** **Input:** s = **lee**tco**de** , t = co**a**t**s** **Output:** 7 **Explanation:** In 2 steps, we can append the letters in as onto s = leetcode , forming s = leetcode**as** . In 5 steps, we can append the letters in leede onto t = coats , forming t = coats**leede** . leetcodeas and coatsleede are now anagrams of each other. We used a total of 2 + 5 = 7 steps. It can be shown that there is no way to make them anagrams of each other with less than 7 steps. **Example 2:** **Input:** s = night , t = thing **Output:** 0 **Explanation:** The given strings are already anagrams of each other. Thus, we do not need any further steps. **Constraints:** * `1 <= s.length, t.length <= 2 * 105` * `s` and `t` consist of lowercase English letters.","completion":"def count_vowel_substrings(word: str) -> int: count = 0 n = len(word) vowels = set() for i in range(n): if word[i] in \\"aeiou\\": vowels.clear() for j in range(i, n): if word[j] in \\"aeiou\\": vowels.add(word[j]) if len(vowels) == 5: count += 1 return count"},{"prompt":"You are given a **0indexed** integer array `forts` of length `n` representing the positions of several forts. `forts[i]` can be `1`, `0`, or `1` where: * `1` represents there is **no fort** at the `ith` position. * `0` indicates there is an **enemy** fort at the `ith` position. * `1` indicates the fort at the `ith` the position is under your command. Now you have decided to move your army from one of your forts at position `i` to an empty position `j` such that: * `0 <= i, j <= n 1` * The army travels over enemy forts **only**. Formally, for all `k` where `min(i,j) < k < max(i,j)`, `forts[k] == 0.` While moving the army, all the enemy forts that come in the way are **captured**. Return _the **maximum** number of enemy forts that can be captured_. In case it is **impossible** to move your army, or you do not have any fort under your command, return `0`_._ **Example 1:** **Input:** forts = [1,0,0,1,0,0,0,0,1] **Output:** 4 **Explanation:** Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2. Moving the army from position 8 to position 3 captures 4 enemy forts. Since 4 is the maximum number of enemy forts that can be captured, we return 4. **Example 2:** **Input:** forts = [0,0,1,1] **Output:** 0 **Explanation:** Since no enemy fort can be captured, 0 is returned. **Constraints:** * `1 <= forts.length <= 1000` * `1 <= forts[i] <= 1`","completion":"def max_captured_forts(forts): n = len(forts) max_capture = 0 for i in range(n): if forts[i] == 1: for j in range(i+1, n): if forts[j] != -1: capture = sum(1 for k in range(i+1, j) if forts[k] == 0) if forts[j] == 1: max_capture = max(max_capture, capture) return max_capture"},{"prompt":"You are given an array of `n` strings `strs`, all of the same length. The strings can be arranged such that there is one on each line, making a grid. * For example, `strs = [ abc , bce , cae ]` can be arranged as follows: abc bce cae You want to **delete** the columns that are **not sorted lexicographically**. In the above example (**0indexed**), columns 0 (`\'a\'`, `\'b\'`, `\'c\'`) and 2 (`\'c\'`, `\'e\'`, `\'e\'`) are sorted, while column 1 (`\'b\'`, `\'c\'`, `\'a\'`) is not, so you would delete column 1. Return _the number of columns that you will delete_. **Example 1:** **Input:** strs = [ cba , daf , ghi ] **Output:** 1 **Explanation:** The grid looks as follows: cba daf ghi Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column. **Example 2:** **Input:** strs = [ a , b ] **Output:** 0 **Explanation:** The grid looks as follows: a b Column 0 is the only column and is sorted, so you will not delete any columns. **Example 3:** **Input:** strs = [ zyx , wvu , tsr ] **Output:** 3 **Explanation:** The grid looks as follows: zyx wvu tsr All 3 columns are not sorted, so you will delete all 3. **Constraints:** * `n == strs.length` * `1 <= n <= 100` * `1 <= strs[i].length <= 1000` * `strs[i]` consists of lowercase English letters.","completion":"def minDifference(nums, k): if len(nums) <= 1: return 0 nums.sort() min_diff = nums[-1] - nums[0] for i in range(1, len(nums)): high = max(nums[i-1] + k, nums[-1] - k) low = min(nums[i] - k, nums[0] + k) min_diff = min(min_diff, high - low) return min_diff"},{"prompt":"You are given a **0indexed** binary string `s` which represents a sequence of train cars. `s[i] = \'0\'` denotes that the `ith` car does **not** contain illegal goods and `s[i] = \'1\'` denotes that the `ith` car does contain illegal goods. As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations **any** number of times: 1. Remove a train car from the **left** end (i.e., remove `s[0]`) which takes 1 unit of time. 2. Remove a train car from the **right** end (i.e., remove `s[s.length 1]`) which takes 1 unit of time. 3. Remove a train car from **anywhere** in the sequence which takes 2 units of time. Return _the **minimum** time to remove all the cars containing illegal goods_. Note that an empty sequence of cars is considered to have no cars containing illegal goods. **Example 1:** **Input:** s = **11**00**1**0**1** **Output:** 5 **Explanation:** One way to remove all the cars containing illegal goods from the sequence is to remove a car from the left end 2 times. Time taken is 2 * 1 = 2. remove a car from the right end. Time taken is 1. remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2 + 1 + 2 = 5. An alternative way is to remove a car from the left end 2 times. Time taken is 2 * 1 = 2. remove a car from the right end 3 times. Time taken is 3 * 1 = 3. This also obtains a total time of 2 + 3 = 5. 5 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. **Example 2:** **Input:** s = 00**1**0 **Output:** 2 **Explanation:** One way to remove all the cars containing illegal goods from the sequence is to remove a car from the left end 3 times. Time taken is 3 * 1 = 3. This obtains a total time of 3. Another way to remove all the cars containing illegal goods from the sequence is to remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2. Another way to remove all the cars containing illegal goods from the sequence is to remove a car from the right end 2 times. Time taken is 2 * 1 = 2. This obtains a total time of 2. 2 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. **Constraints:** * `1 <= s.length <= 2 * 105` * `s[i]` is either `\'0\'` or `\'1\'`.","completion":"def min_time_to_remove_illegal_goods(s: str) -> int: ones = twos = 0 for c in s: if c == \'1\': twos += ones ones += 1 return ones + min(ones, twos)"},{"prompt":"Given a string `paragraph` and a string array of the banned words `banned`, return _the most frequent word that is not banned_. It is **guaranteed** there is **at least one word** that is not banned, and that the answer is **unique**. The words in `paragraph` are **caseinsensitive** and the answer should be returned in **lowercase**. **Example 1:** **Input:** paragraph = Bob hit a ball, the hit BALL flew far after it was hit. , banned = [ hit ] **Output:** ball **Explanation:** hit occurs 3 times, but it is a banned word. ball occurs twice (and no other word does), so it is the most frequent nonbanned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as ball, ), and that hit isn\'t the answer even though it occurs more because it is banned. **Example 2:** **Input:** paragraph = a. , banned = [] **Output:** a **Constraints:** * `1 <= paragraph.length <= 1000` * paragraph consists of English letters, space `\' \'`, or one of the symbols: `!?\',;. `. * `0 <= banned.length <= 100` * `1 <= banned[i].length <= 10` * `banned[i]` consists of only lowercase English letters.","completion":"def minSwaps(nums1, nums2): n = len(nums1) noSwap = [float(\'inf\')] * n doSwap = [float(\'inf\')] * n noSwap[0] = 0 doSwap[0] = 1 for i in range(1, n): if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]: noSwap[i] = noSwap[i - 1] doSwap[i] = doSwap[i - 1] + 1 if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]: noSwap[i] = min(noSwap[i], doSwap[i - 1]) doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1) return min(noSwap[n - 1], doSwap[n - 1])"},{"prompt":"A sequence of numbers is called **arithmetic** if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence `s` is arithmetic if and only if `s[i+1] s[i] == s[1] s[0]` for all valid `i`. For example, these are **arithmetic** sequences: 1, 3, 5, 7, 9 7, 7, 7, 7 3, 1, 5, 9 The following sequence is not **arithmetic**: 1, 1, 2, 5, 7 You are given an array of `n` integers, `nums`, and two arrays of `m` integers each, `l` and `r`, representing the `m` range queries, where the `ith` query is the range `[l[i], r[i]]`. All the arrays are **0indexed**. Return _a list of_ `boolean` _elements_ `answer`_, where_ `answer[i]` _is_ `true` _if the subarray_ `nums[l[i]], nums[l[i]+1], ... , nums[r[i]]` _can be **rearranged** to form an **arithmetic** sequence, and_ `false` _otherwise._ **Example 1:** **Input:** nums = `[4,6,5,9,3,7]`, l = `[0,0,2]`, r = `[2,3,5]` **Output:** `[true,false,true]` **Explanation:** In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence. In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence. In the 2nd query, the subarray is `[5,9,3,7]. This` can be rearranged as `[3,5,7,9]`, which is an arithmetic sequence. **Example 2:** **Input:** nums = [12,9,3,12,6,15,20,25,20,15,10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10] **Output:** [false,true,false,false,true,true] **Constraints:** * `n == nums.length` * `m == l.length` * `m == r.length` * `2 <= n <= 500` * `1 <= m <= 500` * `0 <= l[i] < r[i] < n` * `105 <= nums[i] <= 105`","completion":"def count_odds(low, high): return (high + 1) // 2 - low // 2"},{"prompt":"You are given a **0indexed** 2D integer array `tires` where `tires[i] = [fi, ri]` indicates that the `ith` tire can finish its `xth` successive lap in `fi * ri(x1)` seconds. * For example, if `fi = 3` and `ri = 2`, then the tire would finish its `1st` lap in `3` seconds, its `2nd` lap in `3 * 2 = 6` seconds, its `3rd` lap in `3 * 22 = 12` seconds, etc. You are also given an integer `changeTime` and an integer `numLaps`. The race consists of `numLaps` laps and you may start the race with **any** tire. You have an **unlimited** supply of each tire and after every lap, you may **change** to any given tire (including the current tire type) if you wait `changeTime` seconds. Return _the **minimum** time to finish the race._ **Example 1:** **Input:** tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4 **Output:** 21 **Explanation:** Lap 1: Start with tire 0 and finish the lap in 2 seconds. Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Lap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds. The minimum time to complete the race is 21 seconds. **Example 2:** **Input:** tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5 **Output:** 25 **Explanation:** Lap 1: Start with tire 1 and finish the lap in 2 seconds. Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second. Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds. The minimum time to complete the race is 25 seconds. **Constraints:** * `1 <= tires.length <= 105` * `tires[i].length == 2` * `1 <= fi, changeTime <= 105` * `2 <= ri <= 105` * `1 <= numLaps <= 1000`","completion":"def min_x(n, quantities): total_products = sum(quantities) return (total_products + n - 1) // n"},{"prompt":"You are given two arrays of strings that represent two inclusive events that happened **on the same day**, `event1` and `event2`, where: * `event1 = [startTime1, endTime1]` and * `event2 = [startTime2, endTime2]`. Event times are valid 24 hours format in the form of `HH:MM`. A **conflict** happens when two events have some nonempty intersection (i.e., some moment is common to both events). Return `true` _if there is a conflict between two events. Otherwise, return_ `false`. **Example 1:** **Input:** event1 = [ 01:15 , 02:00 ], event2 = [ 02:00 , 03:00 ] **Output:** true **Explanation:** The two events intersect at time 2:00. **Example 2:** **Input:** event1 = [ 01:00 , 02:00 ], event2 = [ 01:20 , 03:00 ] **Output:** true **Explanation:** The two events intersect starting from 01:20 to 02:00. **Example 3:** **Input:** event1 = [ 10:00 , 11:00 ], event2 = [ 14:00 , 15:00 ] **Output:** false **Explanation:** The two events do not intersect. **Constraints:** * `evnet1.length == event2.length == 2.` * `event1[i].length == event2[i].length == 5` * `startTime1 <= endTime1` * `startTime2 <= endTime2` * All the event times follow the `HH:MM` format.","completion":"def has_event_conflict(start1: str, end1: str, start2: str, end2: str) -> bool: start_hour1, start_min1 = map(int, start1.split(\\":\\")) start_hour2, start_min2 = map(int, start2.split(\\":\\")) end_hour1, end_min1 = map(int, end1.split(\\":\\")) end_hour2, end_min2 = map(int, end2.split(\\":\\")) total_min1_start = start_hour1 * 60 + start_min1 total_min1_end = end_hour1 * 60 + end_min1 total_min2_start = start_hour2 * 60 + start_min2 total_min2_end = end_hour2 * 60 + end_min2 return not (total_min1_end <= total_min2_start or total_min1_start >= total_min2_end)"},{"prompt":"There are `3n` piles of coins of varying size, you and your friends will take piles of coins as follows: * In each step, you will choose **any** `3` piles of coins (not necessarily consecutive). * Of your choice, Alice will pick the pile with the maximum number of coins. * You will pick the next pile with the maximum number of coins. * Your friend Bob will pick the last pile. * Repeat until there are no more piles of coins. Given an array of integers `piles` where `piles[i]` is the number of coins in the `ith` pile. Return the maximum number of coins that you can have. **Example 1:** **Input:** piles = [2,4,1,2,7,8] **Output:** 9 **Explanation:** Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with **7** coins and Bob the last one. Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with **2** coins and Bob the last one. The maximum number of coins which you can have are: 7 + 2 = 9. On the other hand if we choose this arrangement (1, **2**, 8), (2, **4**, 7) you only get 2 + 4 = 6 coins which is not optimal. **Example 2:** **Input:** piles = [2,4,5] **Output:** 4 **Example 3:** **Input:** piles = [9,8,7,6,5,1,2,3,4] **Output:** 18 **Constraints:** * `3 <= piles.length <= 105` * `piles.length % 3 == 0` * `1 <= piles[i] <= 104`","completion":"def arrangeWords(text: str) -> str: words = text.split() words[0] = words[0].lower() words.sort(key=len) words[0] = words[0].capitalize() return \' \'.join(words)"},{"prompt":"You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `ith` job, you have to finish all the jobs `j` where `0 <= j < i`). You have to finish **at least** one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done on that day. You are given an integer array `jobDifficulty` and an integer `d`. The difficulty of the `ith` job is `jobDifficulty[i]`. Return _the minimum difficulty of a job schedule_. If you cannot find a schedule for the jobs return `1`. **Example 1:** **Input:** jobDifficulty = [6,5,4,3,2,1], d = 2 **Output:** 7 **Explanation:** First day you can finish the first 5 jobs, total difficulty = 6. Second day you can finish the last job, total difficulty = 1. The difficulty of the schedule = 6 + 1 = 7 **Example 2:** **Input:** jobDifficulty = [9,9,9], d = 4 **Output:** 1 **Explanation:** If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs. **Example 3:** **Input:** jobDifficulty = [1,1,1], d = 3 **Output:** 3 **Explanation:** The schedule is one job per day. total difficulty will be 3. **Constraints:** * `1 <= jobDifficulty.length <= 300` * `0 <= jobDifficulty[i] <= 1000` * `1 <= d <= 10`","completion":"def max_candies(candies, k): left, right = 1, max(candies) while left <= right: mid = left + (right - left) // 2 count = sum(candy // mid for candy in candies) if count >= k: left = mid + 1 else: right = mid - 1 return right"},{"prompt":"You are given two strings `current` and `correct` representing two **24hour times**. 24hour times are formatted as `HH:MM `, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24hour time is `00:00`, and the latest is `23:59`. In one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation **any** number of times. Return _the **minimum number of operations** needed to convert_ `current` _to_ `correct`. **Example 1:** **Input:** current = 02:30 , correct = 04:35 **Output:** 3 **Explanation:** We can convert current to correct in 3 operations as follows: Add 60 minutes to current. current becomes 03:30 . Add 60 minutes to current. current becomes 04:30 . Add 5 minutes to current. current becomes 04:35 . It can be proven that it is not possible to convert current to correct in fewer than 3 operations. **Example 2:** **Input:** current = 11:00 , correct = 11:01 **Output:** 1 **Explanation:** We only have to add one minute to current, so the minimum number of operations needed is 1. **Constraints:** * `current` and `correct` are in the format `HH:MM ` * `current <= correct`","completion":"def minimum_operations(current: str, correct: str) -> int: ch, cm = map(int, current.split(\':\')) th, tm = map(int, correct.split(\':\')) ct = ch * 60 + cm tt = th * 60 + tm operations = 0 while ct < tt: if tt - ct >= 60: ct += 60 elif tt - ct >= 15: ct += 15 elif tt - ct >= 5: ct += 5 else: ct += 1 operations += 1 return operations"},{"prompt":"You are given two **0indexed** arrays, `nums1` and `nums2`, consisting of nonnegative integers. There exists another array, `nums3`, which contains the bitwise XOR of **all pairings** of integers between `nums1` and `nums2` (every integer in `nums1` is paired with every integer in `nums2` **exactly once**). Return _the **bitwise XOR** of all integers in_ `nums3`. **Example 1:** **Input:** nums1 = [2,1,3], nums2 = [10,2,5,0] **Output:** 13 **Explanation:** A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3]. The bitwise XOR of all these numbers is 13, so we return 13. **Example 2:** **Input:** nums1 = [1,2], nums2 = [3,4] **Output:** 0 **Explanation:** All possible pairs of bitwise XORs are nums1[0] ^ nums2[0], nums1[0] ^ nums2[1], nums1[1] ^ nums2[0], and nums1[1] ^ nums2[1]. Thus, one possible nums3 array is [2,5,1,6]. 2 ^ 5 ^ 1 ^ 6 = 0, so we return 0. **Constraints:** * `1 <= nums1.length, nums2.length <= 105` * `0 <= nums1[i], nums2[j] <= 109`","completion":"def get_xor(nums1, nums2): xor_result = 0 for num1 in nums1: for num2 in nums2: xor_result ^= (num1 ^ num2) return xor_result"},{"prompt":"Alice and Bob take turns playing a game, with **Alice** **starting first**. You are given a string `num` of **even length** consisting of digits and `\'?\'` characters. On each turn, a player will do the following if there is still at least one `\'?\'` in `num`: 1. Choose an index `i` where `num[i] == \'?\'`. 2. Replace `num[i]` with any digit between `\'0\'` and `\'9\'`. The game ends when there are no more `\'?\'` characters in `num`. For Bob to win, the sum of the digits in the first half of `num` must be **equal** to the sum of the digits in the second half. For Alice to win, the sums must **not be equal**. * For example, if the game ended with `num = 243801 `, then Bob wins because `2+4+3 = 8+0+1`. If the game ended with `num = 243803 `, then Alice wins because `2+4+3 != 8+0+3`. Assuming Alice and Bob play **optimally**, return `true` _if Alice will win and_ `false` _if Bob will win_. **Example 1:** **Input:** num = 5023 **Output:** false **Explanation:** There are no moves to be made. The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3. **Example 2:** **Input:** num = 25?? **Output:** true **Explanation:** Alice can replace one of the \'?\'s with \'9\' and it will be impossible for Bob to make the sums equal. **Example 3:** **Input:** num = ?3295??? **Output:** false **Explanation:** It can be proven that Bob will always win. One possible outcome is: Alice replaces the first \'?\' with \'9\'. num = 93295??? . Bob replaces one of the \'?\' in the right half with \'9\'. num = 932959?? . Alice replaces one of the \'?\' in the right half with \'2\'. num = 9329592? . Bob replaces the last \'?\' in the right half with \'7\'. num = 93295927 . Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7. **Constraints:** * `2 <= num.length <= 105` * `num.length` is **even**. * `num` consists of only digits and `\'?\'`.","completion":"def max_ascending_sum(nums): max_sum = current_sum = nums[0] for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_sum += nums[i] else: max_sum = max(max_sum, current_sum) current_sum = nums[i] return max(max_sum, current_sum)"},{"prompt":"You are given integers `height` and `width` which specify the dimensions of a brick wall you are building. You are also given a **0indexed** array of **unique** integers `bricks`, where the `ith` brick has a height of `1` and a width of `bricks[i]`. You have an **infinite** supply of each type of brick and bricks may **not** be rotated. Each row in the wall must be exactly `width` units long. For the wall to be **sturdy**, adjacent rows in the wall should **not** join bricks at the same location, except at the ends of the wall. Return _the number of ways to build a **sturdy** wall._ Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** height = 2, width = 3, bricks = [1,2] **Output:** 2 **Explanation:** The first two walls in the diagram show the only two ways to build a sturdy brick wall. Note that the third wall in the diagram is not sturdy because adjacent rows join bricks 2 units from the left. **Example 2:** **Input:** height = 1, width = 1, bricks = [5] **Output:** 0 **Explanation:** There are no ways to build a sturdy wall because the only type of brick we have is longer than the width of the wall. **Constraints:** * `1 <= height <= 100` * `1 <= width <= 10` * `1 <= bricks.length <= 10` * `1 <= bricks[i] <= 10` * All the values of `bricks` are **unique**.","completion":"def are_encoded_strings_equal(s1: str, s2: str) -> bool: decoded1, decoded2 = \\"\\", \\"\\" for i, c in enumerate(s1): if c.isdigit(): count = int(c) decoded1 += s1[i - 1] * count else: decoded1 += c for i, c in enumerate(s2): if c.isdigit(): count = int(c) decoded2 += s2[i - 1] * count else: decoded2 += c return decoded1 == decoded2"},{"prompt":"You are given the logs for users\' actions on LeetCode, and an integer `k`. The logs are represented by a 2D integer array `logs` where each `logs[i] = [IDi, timei]` indicates that the user with `IDi` performed an action at the minute `timei`. **Multiple users** can perform actions simultaneously, and a single user can perform **multiple actions** in the same minute. The **user active minutes (UAM)** for a given user is defined as the **number of unique minutes** in which the user performed an action on LeetCode. A minute can only be counted once, even if multiple actions occur during it. You are to calculate a **1indexed** array `answer` of size `k` such that, for each `j` (`1 <= j <= k`), `answer[j]` is the **number of users** whose **UAM** equals `j`. Return _the array_ `answer` _as described above_. **Example 1:** **Input:** logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5 **Output:** [0,2,0,0,0] **Explanation:** The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once). The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2. Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0. **Example 2:** **Input:** logs = [[1,1],[2,2],[2,3]], k = 4 **Output:** [1,1,0,0] **Explanation:** The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1. The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2. There is one user with a UAM of 1 and one with a UAM of 2. Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0. **Constraints:** * `1 <= logs.length <= 104` * `0 <= IDi <= 109` * `1 <= timei <= 105` * `k` is in the range `[The maximum **UAM** for a user, 105]`.","completion":"def total_money(n): weeks = n // 7 days_remaining = n % 7 return 28 * weeks + 7 * weeks * (weeks - 1) // 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) // 2"},{"prompt":"You are given an integer array `target` and an integer `n`. You have an empty stack with the two following operations: * **`Push `**: pushes an integer to the top of the stack. * **`Pop `**: removes the integer on the top of the stack. You also have a stream of the integers in the range `[1, n]`. Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to `target`. You should follow the following rules: * If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack. * If the stack is not empty, pop the integer at the top of the stack. * If, at any moment, the elements in the stack (from the bottom to the top) are equal to `target`, do not read new integers from the stream and do not do more operations on the stack. Return _the stack operations needed to build_ `target` following the mentioned rules. If there are multiple valid answers, return **any of them**. **Example 1:** **Input:** target = [1,3], n = 3 **Output:** [ Push , Push , Pop , Push ] **Explanation:** Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Pop the integer on the top of the stack. s = [1]. Read 3 from the stream and push it to the stack. s = [1,3]. **Example 2:** **Input:** target = [1,2,3], n = 3 **Output:** [ Push , Push , Push ] **Explanation:** Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Read 3 from the stream and push it to the stack. s = [1,2,3]. **Example 3:** **Input:** target = [1,2], n = 4 **Output:** [ Push , Push ] **Explanation:** Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Since the stack (from the bottom to the top) is equal to target, we stop the stack operations. The answers that read integer 3 from the stream are not accepted. **Constraints:** * `1 <= target.length <= 100` * `1 <= n <= 100` * `1 <= target[i] <= n` * `target` is strictly increasing.","completion":"def build_array(target, n): result = [] current = 1 for num in target: while current < num: result.append(\\"Push \\") result.append(\\"Pop \\") current += 1 result.append(\\"Push \\") current += 1 return result"},{"prompt":"Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **XY** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`. The distance between two points on the **XY** plane is the Euclidean distance (i.e., `√(x1 x2)2 + (y1 y2)2`). You may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in). **Example 1:** **Input:** points = [[1,3],[2,2]], k = 1 **Output:** [[2,2]] **Explanation:** The distance between (1, 3) and the origin is sqrt(10). The distance between (2, 2) and the origin is sqrt(8). Since sqrt(8) < sqrt(10), (2, 2) is closer to the origin. We only want the closest k = 1 points from the origin, so the answer is just [[2,2]]. **Example 2:** **Input:** points = [[3,3],[5,1],[2,4]], k = 2 **Output:** [[3,3],[2,4]] **Explanation:** The answer [[2,4],[3,3]] would also be accepted. **Constraints:** * `1 <= k <= points.length <= 104` * `104 < xi, yi < 104`","completion":"def moves_to_stamp(stamp: str, target: str) -> list: result = [] is_stamped = [False] * len(target) stamp_count = 0 target = list(target) while stamp_count < 10 * len(target): found_stamp = False for i in range(len(target) - len(stamp) + 1): if is_stamped[i]: continue j = 0 overlap = 0 while j < len(stamp) and (target[i + j] == \'?\' or target[i + j] == stamp[j]): if target[i + j] == stamp[j]: overlap += 1 j += 1 if j == len(stamp) and overlap > 0: for j in range(len(stamp)): target[i + j] = \'?\' result.append(i) is_stamped[i] = True found_stamp = True if not found_stamp: break stamp_count += 1 for c in target: if c != \'?\': return [] return result[::-1]"},{"prompt":"Given three integer arrays `arr1`, `arr2` and `arr3` **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays. **Example 1:** **Input:** arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8] **Output:** [1,5] **Explanation:** Only 1 and 5 appeared in the three arrays. **Example 2:** **Input:** arr1 = [197,418,523,876,1356], arr2 = [501,880,1593,1710,1870], arr3 = [521,682,1337,1395,1764] **Output:** [] **Constraints:** * `1 <= arr1.length, arr2.length, arr3.length <= 1000` * `1 <= arr1[i], arr2[i], arr3[i] <= 2000`","completion":"def arraysIntersection(arr1, arr2, arr3): i, j, k = 0, 0, 0 result = [] while i < len(arr1) and j < len(arr2) and k < len(arr3): if arr1[i] == arr2[j] and arr2[j] == arr3[k]: result.append(arr1[i]) i, j, k = i + 1, j + 1, k + 1 else: if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]: i += 1 elif arr2[j] <= arr3[k]: j += 1 else: k += 1 return result"},{"prompt":"Strings `s1` and `s2` are `k`**similar** (for some nonnegative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`. Given two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`**similar**. **Example 1:** **Input:** s1 = ab , s2 = ba **Output:** 1 **Explanation:** The two string are 1similar because we can use one swap to change s1 to s2: ab > ba . **Example 2:** **Input:** s1 = abc , s2 = bca **Output:** 2 **Explanation:** The two strings are 2similar because we can use two swaps to change s1 to s2: abc > bac > bca . **Constraints:** * `1 <= s1.length <= 20` * `s2.length == s1.length` * `s1` and `s2` contain only lowercase letters from the set `{\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'}`. * `s2` is an anagram of `s1`.","completion":"def kSimilarity(s1: str, s2: str) -> int: k = 0 temp = list(s1) for i in range(len(temp)): if temp[i] != s2[i]: j = i + 1 while temp[j] != s2[i] or s2[j] == temp[j]: j += 1 temp[i], temp[j] = temp[j], temp[i] k += 1 return k"},{"prompt":"You are an ant tasked with adding `n` new rooms numbered `0` to `n1` to your colony. You are given the expansion plan as a **0indexed** integer array of length `n`, `prevRoom`, where `prevRoom[i]` indicates that you must build room `prevRoom[i]` before building room `i`, and these two rooms must be connected **directly**. Room `0` is already built, so `prevRoom[0] = 1`. The expansion plan is given such that once all the rooms are built, every room will be reachable from room `0`. You can only build **one room** at a time, and you can travel freely between rooms you have **already built** only if they are **connected**. You can choose to build **any room** as long as its **previous room** is already built. Return _the **number of different orders** you can build all the rooms in_. Since the answer may be large, return it **modulo** `109 + 7`. **Example 1:** **Input:** prevRoom = [1,0,1] **Output:** 1 **Explanation:** There is only one way to build the additional rooms: 0 > 1 > 2 **Example 2:** **Input:** prevRoom = [1,0,0,1,2] **Output:** 6 **Explanation:** The 6 ways are: 0 > 1 > 3 > 2 > 4 0 > 2 > 4 > 1 > 3 0 > 1 > 2 > 3 > 4 0 > 1 > 2 > 4 > 3 0 > 2 > 1 > 3 > 4 0 > 2 > 1 > 4 > 3 **Constraints:** * `n == prevRoom.length` * `2 <= n <= 105` * `prevRoom[0] == 1` * `0 <= prevRoom[i] < n` for all `1 <= i < n` * Every room is reachable from room `0` once all the rooms are built.","completion":"def findCenter(edges): if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]: return edges[0][0] return edges[0][1]"},{"prompt":"You are given an integer array `nums` of length `n`, and an integer array `queries` of length `m`. Return _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the **maximum** size of a **subsequence** that you can take from_ `nums` _such that the **sum** of its elements is less than or equal to_ `queries[i]`. A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. **Example 1:** **Input:** nums = [4,5,2,1], queries = [3,10,21] **Output:** [2,3,4] **Explanation:** We answer the queries as follows: The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2. The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3. The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4. **Example 2:** **Input:** nums = [2,3,4,5], queries = [1] **Output:** [0] **Explanation:** The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0. **Constraints:** * `n == nums.length` * `m == queries.length` * `1 <= n, m <= 1000` * `1 <= nums[i], queries[i] <= 106`","completion":"from bisect import bisect def maxSizeSubsequenceSumQueries(nums, queries): nums.sort() prefixSums = [0] * (len(nums) + 1) for i, x in enumerate(nums): prefixSums[i + 1] = prefixSums[i] + x answer = [] for q in queries: idx = bisect(prefixSums, q) answer.append(idx - 1) return answer"},{"prompt":"Given an `m x n` integer matrix `grid` where each entry is only `0` or `1`, return _the number of **corner rectangles**_. A **corner rectangle** is four distinct `1`\'s on the grid that forms an axisaligned rectangle. Note that only the corners need to have the value `1`. Also, all four `1`\'s used must be distinct. **Example 1:** **Input:** grid = [[1,0,0,1,0],[0,0,1,0,1],[0,0,0,1,0],[1,0,1,0,1]] **Output:** 1 **Explanation:** There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4]. **Example 2:** **Input:** grid = [[1,1,1],[1,1,1],[1,1,1]] **Output:** 9 **Explanation:** There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle. **Example 3:** **Input:** grid = [[1,1,1,1]] **Output:** 0 **Explanation:** Rectangles must have four distinct corners. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 200` * `grid[i][j]` is either `0` or `1`. * The number of `1`\'s in the grid is in the range `[1, 6000]`.","completion":"def countCornerRectangles(grid): count = 0 m = len(grid) n = len(grid[0]) for i in range(m - 1): for j in range(n - 1): if grid[i][j] == 1: for k in range(i + 1, m): for l in range(j + 1, n): if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1: count += 1 return count"},{"prompt":"Given an integer array `nums`, return `0` _if the sum of the digits of the minimum integer in_ `nums` _is odd, or_ `1` _otherwise_. **Example 1:** **Input:** nums = [34,23,1,24,75,33,54,8] **Output:** 0 **Explanation:** The minimal element is 1, and the sum of those digits is 1 which is odd, so the answer is 0. **Example 2:** **Input:** nums = [99,77,33,66,55] **Output:** 1 **Explanation:** The minimal element is 33, and the sum of those digits is 3 + 3 = 6 which is even, so the answer is 1. **Constraints:** * `1 <= nums.length <= 100` * `1 <= nums[i] <= 100`","completion":"def sum_of_digits(nums): min_val = min(nums) digit_sum = sum(int(digit) for digit in str(min_val)) return 1 if digit_sum % 2 == 0 else 0"},{"prompt":"There is a car with `capacity` empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west). You are given the integer `capacity` and an array `trips` where `trips[i] = [numPassengersi, fromi, toi]` indicates that the `ith` trip has `numPassengersi` passengers and the locations to pick them up and drop them off are `fromi` and `toi` respectively. The locations are given as the number of kilometers due east from the car\'s initial location. Return `true` _if it is possible to pick up and drop off all passengers for all the given trips, or_ `false` _otherwise_. **Example 1:** **Input:** trips = [[2,1,5],[3,3,7]], capacity = 4 **Output:** false **Example 2:** **Input:** trips = [[2,1,5],[3,3,7]], capacity = 5 **Output:** true **Constraints:** * `1 <= trips.length <= 1000` * `trips[i].length == 3` * `1 <= numPassengersi <= 100` * `0 <= fromi < toi <= 1000` * `1 <= capacity <= 105`","completion":"def allCellsDistOrder(rows, cols, rCenter, cCenter): coordinates = [[i, j] for i in range(rows) for j in range(cols)] coordinates.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter)) return coordinates"},{"prompt":"There is a survey that consists of `n` questions where each question\'s answer is either `0` (no) or `1` (yes). The survey was given to `m` students numbered from `0` to `m 1` and `m` mentors numbered from `0` to `m 1`. The answers of the students are represented by a 2D integer array `students` where `students[i]` is an integer array that contains the answers of the `ith` student (**0indexed**). The answers of the mentors are represented by a 2D integer array `mentors` where `mentors[j]` is an integer array that contains the answers of the `jth` mentor (**0indexed**). Each student will be assigned to **one** mentor, and each mentor will have **one** student assigned to them. The **compatibility score** of a studentmentor pair is the number of answers that are the same for both the student and the mentor. * For example, if the student\'s answers were `[1, 0, 1]` and the mentor\'s answers were `[0, 0, 1]`, then their compatibility score is 2 because only the second and the third answers are the same. You are tasked with finding the optimal studentmentor pairings to **maximize** the **sum of the compatibility scores**. Given `students` and `mentors`, return _the **maximum compatibility score sum** that can be achieved._ **Example 1:** **Input:** students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]] **Output:** 8 **Explanation:** We assign students to mentors in the following way: student 0 to mentor 2 with a compatibility score of 3. student 1 to mentor 0 with a compatibility score of 2. student 2 to mentor 1 with a compatibility score of 3. The compatibility score sum is 3 + 2 + 3 = 8. **Example 2:** **Input:** students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]] **Output:** 0 **Explanation:** The compatibility score of any studentmentor pair is 0. **Constraints:** * `m == students.length == mentors.length` * `n == students[i].length == mentors[j].length` * `1 <= m, n <= 8` * `students[i][k]` is either `0` or `1`. * `mentors[j][k]` is either `0` or `1`.","completion":"def count_different_subsequence_GCDs(nums): maximum = max(nums) gcd_count = [0] * (maximum + 1) for num in nums: for i in range(1, int(num**0.5) + 1): if num % i == 0: gcd_count[i] += 1 if i * i != num: gcd_count[num // i] += 1 different_GCDs = sum(1 for count in gcd_count if count > 0) return different_GCDs"},{"prompt":"There is an undirected graph consisting of `n` nodes numbered from `0` to `n 1`. You are given a **0indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi.` A **star graph** is a subgraph of the given graph having a center node containing `0` or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges. The image below shows star graphs with `3` and `4` neighbors respectively, centered at the blue node. The **star sum** is the sum of the values of all the nodes present in the star graph. Given an integer `k`, return _the **maximum star sum** of a star graph containing **at most**_ `k` _edges._ **Example 1:** **Input:** vals = [1,2,3,4,10,10,20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2 **Output:** 16 **Explanation:** The above diagram represents the input graph. The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4. It can be shown it is not possible to get a star graph with a sum greater than 16. **Example 2:** **Input:** vals = [5], edges = [], k = 0 **Output:** 5 **Explanation:** There is only one possible star graph, which is node 0 itself. Hence, we return 5. **Constraints:** * `n == vals.length` * `1 <= n <= 105` * `104 <= vals[i] <= 104` * `0 <= edges.length <= min(n * (n 1) / 2``, 105)` * `edges[i].length == 2` * `0 <= ai, bi <= n 1` * `ai != bi` * `0 <= k <= n 1`","completion":"def max_star_sum(vals, edges, k): adj = [[] for _ in range(len(vals))] for edge in edges: adj[edge[0]].append(vals[edge[1]]) adj[edge[1]].append(vals[edge[0]]) ans = float(\\"-inf\\") for i in range(len(vals)): adj[i].sort(reverse=True) ans = max(ans, vals[i] + sum(adj[i][:k])) return ans"},{"prompt":"Given a nonempty array of nonnegative integers `nums`, the **degree** of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`. **Example 1:** **Input:** nums = [1,2,2,3,1] **Output:** 2 **Explanation:** The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. **Example 2:** **Input:** nums = [1,2,2,3,1,4,2] **Output:** 6 **Explanation:** The degree is 3 because the element 2 is repeated 3 times. So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6. **Constraints:** * `nums.length` will be between 1 and 50,000. * `nums[i]` will be an integer between 0 and 49,999.","completion":"def findShortestSubArray(nums): freq_map, start_map = {}, {} max_freq, min_length = 0, len(nums) for i, num in enumerate(nums): if num not in start_map: start_map[num] = i freq_map[num] = freq_map.get(num, 0) + 1 freq = freq_map[num] if freq > max_freq: max_freq = freq min_length = i - start_map[num] + 1 elif freq == max_freq: min_length = min(min_length, i - start_map[num] + 1) return min_length"},{"prompt":"Given an integer `n`, you must transform it into `0` using the following operations any number of times: * Change the rightmost (`0th`) bit in the binary representation of `n`. * Change the `ith` bit in the binary representation of `n` if the `(i1)th` bit is set to `1` and the `(i2)th` through `0th` bits are set to `0`. Return _the minimum number of operations to transform_ `n` _into_ `0`_._ **Example 1:** **Input:** n = 3 **Output:** 2 **Explanation:** The binary representation of 3 is 11 . 11 > 01 with the 2nd operation since the 0th bit is 1. 01 > 00 with the 1st operation. **Example 2:** **Input:** n = 6 **Output:** 4 **Explanation:** The binary representation of 6 is 110 . 110 > 010 with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0. 010 > 011 with the 1st operation. 011 > 001 with the 2nd operation since the 0th bit is 1. 001 > 000 with the 1st operation. **Constraints:** * `0 <= n <= 109`","completion":"def get_folder_names(names): name_count = {} ans = [] for name in names: if name not in name_count: ans.append(name) name_count[name] = 1 else: k = name_count[name] new_name = f\\"{name}({k})\\" while new_name in name_count: k += 1 new_name = f\\"{name}({k})\\" ans.append(new_name) name_count[new_name] = 1 name_count[name] = k + 1 return ans"},{"prompt":"You are given a **positive** integer `n`. We call an integer `k` fair if the number of **even** digits in `k` is equal to the number of **odd** digits in it. Return _the **smallest** fair integer that is **greater than or equal** to_ `n`. **Example 1:** **Input:** n = 2 **Output:** 10 **Explanation:** The smallest fair integer that is greater than or equal to 2 is 10. 10 is fair because it has an equal number of even and odd digits (one odd digit and one even digit). **Example 2:** **Input:** n = 403 **Output:** 1001 **Explanation:** The smallest fair integer that is greater than or equal to 403 is 1001. 1001 is fair because it has an equal number of even and odd digits (two odd digits and two even digits). **Constraints:** * `1 <= n <= 109`","completion":"def smallest_fair_number(n): while True: k = n even = 0 odd = 0 while k > 0: if k % 2 == 0: even += 1 else: odd += 1 k //= 10 if even == odd: return n n += 1"},{"prompt":"You are given a binary string `s`, and two integers `num1` and `num2`. `num1` and `num2` are coprime numbers. A **ratio substring** is a substring of s where the ratio between the number of `0`\'s and the number of `1`\'s in the substring is exactly `num1 : num2`. * For example, if `num1 = 2` and `num2 = 3`, then `01011 ` and `1110000111 ` are ratio substrings, while `11000 ` is not. Return _the number of **nonempty** ratio substrings of_ `s`. **Note** that: * A **substring** is a contiguous sequence of characters within a string. * Two values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the greatest common divisor of `x` and `y`. **Example 1:** **Input:** s = 0110011 , num1 = 1, num2 = 2 **Output:** 4 **Explanation:** There exist 4 nonempty ratio substrings. The substring s[0..2]: 0110011 . It contains one 0 and two 1\'s. The ratio is 1 : 2. The substring s[1..4]: 0110011 . It contains one 0 and two 1\'s. The ratio is 1 : 2. The substring s[4..6]: 0110011 . It contains one 0 and two 1\'s. The ratio is 1 : 2. The substring s[1..6]: 0110011 . It contains two 0\'s and four 1\'s. The ratio is 2 : 4 == 1 : 2. It can be shown that there are no more ratio substrings. **Example 2:** **Input:** s = 10101 , num1 = 3, num2 = 1 **Output:** 0 **Explanation:** There is no ratio substrings of s. We return 0. **Constraints:** * `1 <= s.length <= 105` * `1 <= num1, num2 <= s.length` * `num1` and `num2` are coprime integers.","completion":"def ratio_substring_count(s: str, num1: int, num2: int) -> int: count0, count1 = 0, 0 frequency = {0: 1} result = 0 for c in s: if c == \'0\': count0 += 1 else: count1 += 1 curr_diff = count0 * num2 - count1 * num1 result += frequency.get(curr_diff, 0) frequency[curr_diff] = frequency.get(curr_diff, 0) + 1 return result"},{"prompt":"You are given a **0indexed** `m x n` binary matrix `land` where a `0` represents a hectare of forested land and a `1` represents a hectare of farmland. To keep the land organized, there are designated rectangular areas of hectares that consist **entirely** of farmland. These rectangular areas are called **groups**. No two groups are adjacent, meaning farmland in one group is **not** fourdirectionally adjacent to another farmland in a different group. `land` can be represented by a coordinate system where the top left corner of `land` is `(0, 0)` and the bottom right corner of `land` is `(m1, n1)`. Find the coordinates of the top left and bottom right corner of each **group** of farmland. A **group** of farmland with a top left corner at `(r1, c1)` and a bottom right corner at `(r2, c2)` is represented by the 4length array `[r1, c1, r2, c2].` Return _a 2D array containing the 4length arrays described above for each **group** of farmland in_ `land`_. If there are no groups of farmland, return an empty array. You may return the answer in **any order**_. **Example 1:** **Input:** land = [[1,0,0],[0,1,1],[0,1,1]] **Output:** [[0,0,0,0],[1,1,2,2]] **Explanation:** The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0]. The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]. **Example 2:** **Input:** land = [[1,1],[1,1]] **Output:** [[0,0,1,1]] **Explanation:** The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]. **Example 3:** **Input:** land = [[0]] **Output:** [] **Explanation:** There are no groups of farmland. **Constraints:** * `m == land.length` * `n == land[i].length` * `1 <= m, n <= 300` * `land` consists of only `0`\'s and `1`\'s. * Groups of farmland are **rectangular** in shape.","completion":"def findFarmland(land): m, n = len(land), len(land[0]) groups = [] for i in range(m): for j in range(n): if land[i][j] == 1: r1, c1 = i, j while j + 1 < n and land[i][j + 1] == 1: j += 1 r2, c2 = i, j while r2 + 1 < m and land[r2 + 1][j] == 1: r2 += 1 for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): land[r][c] = 0 groups.append([r1, c1, r2, c2]) return groups"},{"prompt":"You are given an integer array `nums`. The unique elements of an array are the elements that appear **exactly once** in the array. Return _the **sum** of all the unique elements of_ `nums`. **Example 1:** **Input:** nums = [1,2,3,2] **Output:** 4 **Explanation:** The unique elements are [1,3], and the sum is 4. **Example 2:** **Input:** nums = [1,1,1,1,1] **Output:** 0 **Explanation:** There are no unique elements, and the sum is 0. **Example 3:** **Input:** nums = [1,2,3,4,5] **Output:** 15 **Explanation:** The unique elements are [1,2,3,4,5], and the sum is 15. **Constraints:** * `1 <= nums.length <= 100` * `1 <= nums[i] <= 100`","completion":"def bestTeamScore(scores, ages): players = sorted(zip(ages, scores)) n = len(players) dp = [0] * n best_score = 0 for i in range(n): dp[i] = players[i][1] for j in range(i): if players[i][1] >= players[j][1]: dp[i] = max(dp[i], dp[j] + players[i][1]) best_score = max(best_score, dp[i]) return best_score"},{"prompt":"Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`. Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`. Elements that do not appear in `arr2` should be placed at the end of `arr1` in **ascending** order. **Example 1:** **Input:** arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] **Output:** [2,2,2,1,4,3,3,9,6,7,19] **Example 2:** **Input:** arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] **Output:** [22,28,8,6,17,44] **Constraints:** * `1 <= arr1.length, arr2.length <= 1000` * `0 <= arr1[i], arr2[i] <= 1000` * All the elements of `arr2` are **distinct**. * Each `arr2[i]` is in `arr1`.","completion":"def longest_dup_substring(s): n = len(s) longest_duplicate = \\"\\" for length in range(n - 1, 0, -1): for i in range(n - length + 1): substring = s[i:i + length] if s.find(substring, i + 1) != -1: longest_duplicate = substring return longest_duplicate return longest_duplicate"},{"prompt":"Write a program to count the number of days between two dates. The two dates are given as strings, their format is `YYYYMMDD` as shown in the examples. **Example 1:** **Input:** date1 = 20190629, date2 = 20190630 **Output:** 1 **Example 2:** **Input:** date1 = 20200115, date2 = 20191231 **Output:** 15 **Constraints:** * The given dates are valid dates between the years `1971` and `2100`.","completion":"def maxLength(arr): dp = [\'\'] maxLen = 0 for s in arr: if len(set(s)) < len(s): continue for i in range(len(dp) - 1, -1, -1): tmp = dp[i] + s if len(set(tmp)) == len(tmp): dp.append(tmp) maxLen = max(maxLen, len(tmp)) return maxLen"},{"prompt":"Given a **0indexed** integer array `nums`, return _the number of subarrays of_ `nums` _having an even product_. **Example 1:** **Input:** nums = [9,6,7,13] **Output:** 6 **Explanation:** There are 6 subarrays with an even product: nums[0..1] = 9 * 6 = 54. nums[0..2] = 9 * 6 * 7 = 378. nums[0..3] = 9 * 6 * 7 * 13 = 4914. nums[1..1] = 6. nums[1..2] = 6 * 7 = 42. nums[1..3] = 6 * 7 * 13 = 546. **Example 2:** **Input:** nums = [7,3,5] **Output:** 0 **Explanation:** There are no subarrays with an even product. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 105`","completion":"def numberOfEvenSubarrays(nums): n = len(nums) evenCount, oddCount, result = 0, 0, 0 for num in nums: if num % 2 == 0: evenCount += 1 result += evenCount else: evenCount, oddCount = oddCount, evenCount oddCount += 1 result += oddCount return result"},{"prompt":"There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break. You should finish the given tasks in a way that satisfies the following conditions: * If you start a task in a work session, you must complete it in the **same** work session. * You can start a new task **immediately** after finishing the previous one. * You may complete the tasks in **any order**. Given `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._ The tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`. **Example 1:** **Input:** tasks = [1,2,3], sessionTime = 3 **Output:** 2 **Explanation:** You can finish the tasks in two work sessions. First work session: finish the first and the second tasks in 1 + 2 = 3 hours. Second work session: finish the third task in 3 hours. **Example 2:** **Input:** tasks = [3,1,3,1,1], sessionTime = 8 **Output:** 2 **Explanation:** You can finish the tasks in two work sessions. First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours. Second work session: finish the last task in 1 hour. **Example 3:** **Input:** tasks = [1,2,3,4,5], sessionTime = 15 **Output:** 1 **Explanation:** You can finish all the tasks in one work session. **Constraints:** * `n == tasks.length` * `1 <= n <= 14` * `1 <= tasks[i] <= 10` * `max(tasks[i]) <= sessionTime <= 15`","completion":"from collections import defaultdict def largestPathValue(colors, edges): def dfs(node): if not cache[node][ord(colors[node]) - ord(\'a\')]: cache[node][ord(colors[node]) - ord(\'a\')] = 1 for neighbor in graph[node]: cache[node][ord(colors[node]) - ord(\'a\')] = max(cache[node][ord(colors[node]) - ord(\'a\')], 1 + dfs(neighbor)) return cache[node][ord(colors[node]) - ord(\'a\')] n = len(colors) graph = [set() for _ in range(n)] for a, b in edges: graph[a].add(b) cache = [[0] * 26 for _ in range(n)] in_degree = [0] * n for a, b in edges: in_degree[b] += 1 res = -1 for i in range(n): if in_degree[i] == 0: res = max(res, dfs(i)) return res"},{"prompt":"You have `n` processes forming a rooted tree structure. You are given two integer arrays `pid` and `ppid`, where `pid[i]` is the ID of the `ith` process and `ppid[i]` is the ID of the `ith` process\'s parent process. Each process has only **one parent process** but may have multiple children processes. Only one process has `ppid[i] = 0`, which means this process has **no parent process** (the root of the tree). When a process is **killed**, all of its children processes will also be killed. Given an integer `kill` representing the ID of a process you want to kill, return _a list of the IDs of the processes that will be killed. You may return the answer in **any order**._ **Example 1:** **Input:** pid = [1,3,10,5], ppid = [3,0,5,3], kill = 5 **Output:** [5,10] **Explanation:** The processes colored in red are the processes that should be killed. **Example 2:** **Input:** pid = [1], ppid = [0], kill = 1 **Output:** [1] **Constraints:** * `n == pid.length` * `n == ppid.length` * `1 <= n <= 5 * 104` * `1 <= pid[i] <= 5 * 104` * `0 <= ppid[i] <= 5 * 104` * Only one process has no parent. * All the values of `pid` are **unique**. * `kill` is **guaranteed** to be in `pid`.","completion":"from collections import defaultdict def killProcess(pid, ppid, kill): children = defaultdict(list) for i in range(len(pid)): children[ppid[i]].append(pid[i]) def dfs(id, killed): killed.append(id) for child in children[id]: dfs(child, killed) killed = [] dfs(kill, killed) return killed"},{"prompt":"There is a country of `n` cities numbered from `0` to `n 1` where **all the cities are connected** by bidirectional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself. Each time you pass through a city, you must pay a passing fee. This is represented as a **0indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`. In the beginning, you are at city `0` and want to reach city `n 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities). Given `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `1` _if you cannot complete it within_ `maxTime` _minutes_. **Example 1:** **Input:** maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] **Output:** 11 **Explanation:** The path to take is 0 > 1 > 2 > 5, which takes 30 minutes and has 11 worth of passing fees. **Example 2:** **Input:** maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] **Output:** 48 **Explanation:** The path to take is 0 > 3 > 4 > 5, which takes 26 minutes and has 48 worth of passing fees. You cannot take path 0 > 1 > 2 > 5 since it would take too long. **Example 3:** **Input:** maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] **Output:** 1 **Explanation:** There is no way to reach city 5 from city 0 within 25 minutes. **Constraints:** * `1 <= maxTime <= 1000` * `n == passingFees.length` * `2 <= n <= 1000` * `n 1 <= edges.length <= 1000` * `0 <= xi, yi <= n 1` * `1 <= timei <= 1000` * `1 <= passingFees[j] <= 1000` * The graph may contain multiple edges between two nodes. * The graph does not contain self loops.","completion":"from heapq import heappush, heappop def getNumberOfBacklogOrders(orders): buy, sell = [], [] for price, amount, orderType in orders: if orderType == 0: while amount > 0 and sell and -sell[0][0] <= price: executedAmount = min(amount, sell[0][1]) amount -= executedAmount sell[0] = [-sell[0][0], sell[0][1] - executedAmount] if sell[0][1] == 0: heappop(sell) if amount: heappush(buy, [-price, amount]) else: while amount > 0 and buy and buy[0][0] >= price: executedAmount = min(amount, buy[0][1]) amount -= executedAmount buy[0] = [buy[0][0], buy[0][1] - executedAmount] if buy[0][1] == 0: heappop(buy) if amount: heappush(sell, [-price, amount]) res = sum(item[1] for item in buy) + sum(item[1] for item in sell) return res % 1000000007"},{"prompt":"You are given an `m x n` `grid`. Each cell of `grid` represents a street. The street of `grid[i][j]` can be: * `1` which means a street connecting the left cell and the right cell. * `2` which means a street connecting the upper cell and the lower cell. * `3` which means a street connecting the left cell and the lower cell. * `4` which means a street connecting the right cell and the lower cell. * `5` which means a street connecting the left cell and the upper cell. * `6` which means a street connecting the right cell and the upper cell. You will initially start at the street of the upperleft cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottomright cell `(m 1, n 1)`. **The path should only follow the streets**. **Notice** that you are **not allowed** to change any street. Return `true` _if there is a valid path in the grid or_ `false` _otherwise_. **Example 1:** **Input:** grid = [[2,4,3],[6,5,2]] **Output:** true **Explanation:** As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m 1, n 1). **Example 2:** **Input:** grid = [[1,2,1],[1,2,1]] **Output:** false **Explanation:** As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0) **Example 3:** **Input:** grid = [[1,1,2]] **Output:** false **Explanation:** You will get stuck at cell (0, 1) and you cannot reach cell (0, 2). **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 300` * `1 <= grid[i][j] <= 6`","completion":"def hasValidPath(grid): m, n = len(grid), len(grid[0]) directions = [(0, -1), (-1, 0), (0, 1), (1, 0)] allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]] visited = [[False] * n for _ in range(m)] def dfs(i, j): if i == m - 1 and j == n - 1: return True visited[i][j] = True for dir in allowed[grid[i][j]]: x, y = i + directions[dir][0], j + directions[dir][1] if 0 <= x < m and 0 <= y < n and not visited[x][y] and (dir + 2) % 4 in allowed[grid[x][y]]: if dfs(x, y): return True return False return dfs(0, 0)"},{"prompt":"You are given an `n x n` `grid` where you have placed some `1 x 1 x 1` cubes. Each value `v = grid[i][j]` represents a tower of `v` cubes placed on top of cell `(i, j)`. After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes. Return _the total surface area of the resulting shapes_. **Note:** The bottom face of each shape counts toward its surface area. **Example 1:** **Input:** grid = [[1,2],[3,4]] **Output:** 34 **Example 2:** **Input:** grid = [[1,1,1],[1,0,1],[1,1,1]] **Output:** 32 **Example 3:** **Input:** grid = [[2,2,2],[2,1,2],[2,2,2]] **Output:** 46 **Constraints:** * `n == grid.length == grid[i].length` * `1 <= n <= 50` * `0 <= grid[i][j] <= 50`","completion":"from collections import deque def shortest_subarray(nums, k): n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] res = n + 1 dq = deque() for i in range(n + 1): while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k: res = min(res, i - dq.popleft()) while dq and prefix_sum[i] <= prefix_sum[dq[-1]]: dq.pop() dq.append(i) return res if res <= n else -1"},{"prompt":"Given an integer array `arr`, return _the number of distinct bitwise ORs of all the nonempty subarrays of_ `arr`. The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer. A **subarray** is a contiguous nonempty sequence of elements within an array. **Example 1:** **Input:** arr = [0] **Output:** 1 **Explanation:** There is only one possible result: 0. **Example 2:** **Input:** arr = [1,1,2] **Output:** 3 **Explanation:** The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3. **Example 3:** **Input:** arr = [1,2,4] **Output:** 6 **Explanation:** The possible results are 1, 2, 3, 4, 6, and 7. **Constraints:** * `1 <= arr.length <= 5 * 104` * `0 <= arr[i] <= 109`","completion":"def transpose(matrix): rows = len(matrix) cols = len(matrix[0]) result = [[0] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): result[j][i] = matrix[i][j] return result"},{"prompt":"You are given a **0indexed** integer array `players`, where `players[i]` represents the **ability** of the `ith` player. You are also given a **0indexed** integer array `trainers`, where `trainers[j]` represents the **training capacity** of the `jth` trainer. The `ith` player can **match** with the `jth` trainer if the player\'s ability is **less than or equal to** the trainer\'s training capacity. Additionally, the `ith` player can be matched with at most one trainer, and the `jth` trainer can be matched with at most one player. Return _the **maximum** number of matchings between_ `players` _and_ `trainers` _that satisfy these conditions._ **Example 1:** **Input:** players = [4,7,9], trainers = [8,2,5,8] **Output:** 2 **Explanation:** One of the ways we can form two matchings is as follows: players[0] can be matched with trainers[0] since 4 <= 8. players[1] can be matched with trainers[3] since 7 <= 8. It can be proven that 2 is the maximum number of matchings that can be formed. **Example 2:** **Input:** players = [1,1,1], trainers = [10] **Output:** 1 **Explanation:** The trainer can be matched with any of the 3 players. Each player can only be matched with one trainer, so the maximum answer is 1. **Constraints:** * `1 <= players.length, trainers.length <= 105` * `1 <= players[i], trainers[j] <= 109`","completion":"def max_matchings(players, trainers): players.sort() trainers.sort() player_index, trainer_index, match_count = 0, 0, 0 while (player_index < len(players)) and (trainer_index < len(trainers)): if players[player_index] <= trainers[trainer_index]: match_count += 1 player_index += 1 trainer_index += 1 else: trainer_index += 1 return match_count"},{"prompt":"There is an **undirected** connected tree with `n` nodes labeled from `1` to `n` and `n 1` edges. You are given the integer `n`. The parent node of a node with a label `v` is the node with the label `floor (v / 2)`. The root of the tree is the node with the label `1`. * For example, if `n = 7`, then the node with the label `3` has the node with the label `floor(3 / 2) = 1` as its parent, and the node with the label `7` has the node with the label `floor(7 / 2) = 3` as its parent. You are also given an integer array `queries`. Initially, every node has a value `0` on it. For each query `queries[i]`, you should flip all values in the subtree of the node with the label `queries[i]`. Return _the total number of nodes with the value_ `1` _**after processing all the queries**_. **Note** that: * Flipping the value of a node means that the node with the value `0` becomes `1` and vice versa. * `floor(x)` is equivalent to rounding `x` down to the nearest integer. **Example 1:** **Input:** n = 5 , queries = [1,2,5] **Output:** 3 **Explanation:** The diagram above shows the tree structure and its status after performing the queries. The blue node represents the value 0, and the red node represents the value 1. After processing the queries, there are three red nodes (nodes with value 1): 1, 3, and 5. **Example 2:** **Input:** n = 3, queries = [2,3,3] **Output:** 1 **Explanation:** The diagram above shows the tree structure and its status after performing the queries. The blue node represents the value 0, and the red node represents the value 1. After processing the queries, there are one red node (node with value 1): 2. **Constraints:** * `1 <= n <= 105` * `1 <= queries.length <= 105` * `1 <= queries[i] <= n`","completion":"def flip_trees(n, queries): flipped_nodes = {} for query in queries: flipped_nodes[query] = not flipped_nodes.get(query, False) while query > 1: query //= 2 flipped_nodes[query] = not flipped_nodes.get(query, False) count = 0 for value in flipped_nodes.values(): if value: count += 1 return count"},{"prompt":"You are given a string `s`, where every **two** consecutive vertical bars `\'|\'` are grouped into a **pair**. In other words, the 1st and 2nd `\'|\'` make a pair, the 3rd and 4th `\'|\'` make a pair, and so forth. Return _the number of_ `\'*\'` _in_ `s`_, **excluding** the_ `\'*\'` _between each pair of_ `\'|\'`. **Note** that each `\'|\'` will belong to **exactly** one pair. **Example 1:** **Input:** s = l|*e*et|c**o|*de| **Output:** 2 **Explanation:** The considered characters are underlined: l|*e*et|c**o|*de| . The characters between the first and second \'|\' are excluded from the answer. Also, the characters between the third and fourth \'|\' are excluded from the answer. There are 2 asterisks considered. Therefore, we return 2. **Example 2:** **Input:** s = iamprogrammer **Output:** 0 **Explanation:** In this example, there are no asterisks in s. Therefore, we return 0. **Example 3:** **Input:** s = yo|uar|e**|b|e***au|tifu|l **Output:** 5 **Explanation:** The considered characters are underlined: yo|uar|e**|b|e***au|tifu|l . There are 5 asterisks considered. Therefore, we return 5. **Constraints:** * `1 <= s.length <= 1000` * `s` consists of lowercase English letters, vertical bars `\'|\'`, and asterisks `\'*\'`. * `s` contains an **even** number of vertical bars `\'|\'`.","completion":"def count_stars_except_between_pair(s: str) -> int: count = 0 pipe_count = 0 for c in s: if c == \'|\': pipe_count += 1 elif c == \'*\' and pipe_count % 2 == 0: count += 1 return count"},{"prompt":"Given an integer `n`, return _a list of all **simplified** fractions between_ `0` _and_ `1` _(exclusive) such that the denominator is lessthanorequalto_ `n`. You can return the answer in **any order**. **Example 1:** **Input:** n = 2 **Output:** [ 1/2 ] **Explanation:** 1/2 is the only unique fraction with a denominator lessthanorequalto 2. **Example 2:** **Input:** n = 3 **Output:** [ 1/2 , 1/3 , 2/3 ] **Example 3:** **Input:** n = 4 **Output:** [ 1/2 , 1/3 , 1/4 , 2/3 , 3/4 ] **Explanation:** 2/4 is not a simplified fraction because it can be simplified to 1/2 . **Constraints:** * `1 <= n <= 100`","completion":"def minJumps(arr): n = len(arr) maxReach = arr[0] step = arr[0] jumps = 1 if n == 1: return 0 for i in range(1, n): if i == n - 1: return jumps maxReach = max(maxReach, i + arr[i]) step -= 1 if step == 0: jumps += 1 step = maxReach - i return -1"},{"prompt":"We have `n` buildings numbered from `0` to `n 1`. Each building has a number of employees. It\'s transfer season, and some employees want to change the building they reside in. You are given an array `requests` where `requests[i] = [fromi, toi]` represents an employee\'s request to transfer from building `fromi` to building `toi`. **All buildings are full**, so a list of requests is achievable only if for each building, the **net change in employee transfers is zero**. This means the number of employees **leaving** is **equal** to the number of employees **moving in**. For example if `n = 3` and two employees are leaving building `0`, one is leaving building `1`, and one is leaving building `2`, there should be two employees moving to building `0`, one employee moving to building `1`, and one employee moving to building `2`. Return _the maximum number of achievable requests_. **Example 1:** **Input:** n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]] **Output:** 5 **Explantion:** Let\'s see the requests: From building 0 we have employees x and y and both want to move to building 1. From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively. From building 2 we have employee z and they want to move to building 0. From building 3 we have employee c and they want to move to building 4. From building 4 we don\'t have any requests. We can achieve the requests of users x and b by swapping their places. We can achieve the requests of users y, a and z by swapping the places in the 3 buildings. **Example 2:** **Input:** n = 3, requests = [[0,0],[1,2],[2,1]] **Output:** 3 **Explantion:** Let\'s see the requests: From building 0 we have employee x and they want to stay in the same building 0. From building 1 we have employee y and they want to move to building 2. From building 2 we have employee z and they want to move to building 1. We can achieve all the requests. **Example 3:** **Input:** n = 4, requests = [[0,3],[3,1],[1,2],[2,0]] **Output:** 4 **Constraints:** * `1 <= n <= 20` * `1 <= requests.length <= 16` * `requests[i].length == 2` * `0 <= fromi, toi < n`","completion":"def maximumRequests(n, requests): req_size = len(requests) max_requests = 0 for i in range(1 << req_size): net_transfers = [0] * n count = 0 for j in range(req_size): if i & (1 << j): net_transfers[requests[j][0]] -= 1 net_transfers[requests[j][1]] += 1 count += 1 valid = all(val == 0 for val in net_transfers) if valid: max_requests = max(max_requests, count) return max_requests"},{"prompt":"Given a `m x n` matrix `grid` which is sorted in nonincreasing order both rowwise and columnwise, return _the number of **negative** numbers in_ `grid`. **Example 1:** **Input:** grid = [[4,3,2,1],[3,2,1,1],[1,1,1,2],[1,1,2,3]] **Output:** 8 **Explanation:** There are 8 negatives number in the matrix. **Example 2:** **Input:** grid = [[3,2],[1,0]] **Output:** 0 **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 100` * `100 <= grid[i][j] <= 100`","completion":"def balanced_string(s): n = len(s) freq_map = {} for c in s: freq_map[c] = freq_map.get(c, 0) + 1 i = 0 result = n for j in range(n): freq_map[s[j]] -= 1 while i < n and all(freq_map.get(c, 0) <= n // 4 for c in \\"QWER\\"): result = min(result, j - i + 1) freq_map[s[i]] += 1 i += 1 return result"},{"prompt":"There is a street with `n * 2` **plots**, where there are `n` plots on each side of the street. The plots on each side are numbered from `1` to `n`. On each plot, a house can be placed. Return _the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street_. Since the answer may be very large, return it **modulo** `109 + 7`. Note that if a house is placed on the `ith` plot on one side of the street, a house can also be placed on the `ith` plot on the other side of the street. **Example 1:** **Input:** n = 1 **Output:** 4 **Explanation:** Possible arrangements: 1. All plots are empty. 2. A house is placed on one side of the street. 3. A house is placed on the other side of the street. 4. Two houses are placed, one on each side of the street. **Example 2:** **Input:** n = 2 **Output:** 9 **Explanation:** The 9 possible arrangements are shown in the diagram above. **Constraints:** * `1 <= n <= 104`","completion":"def k_distant_indices(nums, key, k): result = [] for i in range(len(nums)): for j in range(max(0, i - k), min(i + k + 1, len(nums))): if nums[j] == key: result.append(i) break return result"},{"prompt":"Given an integer array `nums` sorted in nondecreasing order and an integer `target`, return `true` _if_ `target` _is a **majority** element, or_ `false` _otherwise_. A **majority** element in an array `nums` is an element that appears more than `nums.length / 2` times in the array. **Example 1:** **Input:** nums = [2,4,5,5,5,5,5,6,6], target = 5 **Output:** true **Explanation:** The value 5 appears 5 times and the length of the array is 9. Thus, 5 is a majority element because 5 > 9/2 is true. **Example 2:** **Input:** nums = [10,100,101,101], target = 101 **Output:** false **Explanation:** The value 101 appears 2 times and the length of the array is 4. Thus, 101 is not a majority element because 2 > 4/2 is false. **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i], target <= 109` * `nums` is sorted in nondecreasing order.","completion":"def is_majority_element(nums, target): count = 0 for num in nums: if num == target: count += 1 if count > len(nums) / 2: return True return False"},{"prompt":"Given a singledigit integer `d` and two integers `low` and `high`, return _the number of times that_ `d` _occurs as a digit in all integers in the inclusive range_ `[low, high]`. **Example 1:** **Input:** d = 1, low = 1, high = 13 **Output:** 6 **Explanation:** The digit d = 1 occurs 6 times in 1, 10, 11, 12, 13. Note that the digit d = 1 occurs twice in the number 11. **Example 2:** **Input:** d = 3, low = 100, high = 250 **Output:** 35 **Explanation:** The digit d = 3 occurs 35 times in 103,113,123,130,131,...,238,239,243. **Constraints:** * `0 <= d <= 9` * `1 <= low <= high <= 2 * 108`","completion":"def count_digit(d, low, high): count = 0 for i in range(low, high + 1): num = i while num > 0: if num % 10 == d: count += 1 num //= 10 return count"},{"prompt":"Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. **Example 1:** **Input:** s = Let\'s take LeetCode contest **Output:** s\'teL ekat edoCteeL tsetnoc **Example 2:** **Input:** s = God Ding **Output:** doG gniD **Constraints:** * `1 <= s.length <= 5 * 104` * `s` contains printable **ASCII** characters. * `s` does not contain any leading or trailing spaces. * There is **at least one** word in `s`. * All the words in `s` are separated by a single space.","completion":"def reverse_words_in_string(s: str) -> str: return \\" \\".join(word[::-1] for word in s.split(\\" \\"))"},{"prompt":"There are `numBottles` water bottles that are initially full of water. You can exchange `numExchange` empty water bottles from the market with one full water bottle. The operation of drinking a full water bottle turns it into an empty bottle. Given the two integers `numBottles` and `numExchange`, return _the **maximum** number of water bottles you can drink_. **Example 1:** **Input:** numBottles = 9, numExchange = 3 **Output:** 13 **Explanation:** You can exchange 3 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 9 + 3 + 1 = 13. **Example 2:** **Input:** numBottles = 15, numExchange = 4 **Output:** 19 **Explanation:** You can exchange 4 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 15 + 3 + 1 = 19. **Constraints:** * `1 <= numBottles <= 100` * `2 <= numExchange <= 100`","completion":"def numWaterBottles(numBottles: int, numExchange: int) -> int: totalBottles = numBottles while numBottles >= numExchange: newBottles = numBottles // numExchange totalBottles += newBottles numBottles = newBottles + numBottles % numExchange return totalBottles"},{"prompt":"Given a string `s`. In one step you can insert any character at any index of the string. Return _the minimum number of steps_ to make `s` palindrome. A **Palindrome String** is one that reads the same backward as well as forward. **Example 1:** **Input:** s = zzazz **Output:** 0 **Explanation:** The string zzazz is already palindrome we do not need any insertions. **Example 2:** **Input:** s = mbadm **Output:** 2 **Explanation:** String can be mbdadbm or mdbabdm . **Example 3:** **Input:** s = leetcode **Output:** 5 **Explanation:** Inserting 5 characters the string becomes leetcodocteel . **Constraints:** * `1 <= s.length <= 500` * `s` consists of lowercase English letters.","completion":"def extract_artifacts(n, artifacts, dig): artifact_cells = {} artifact_count = {} for i, (r1, c1, r2, c2) in enumerate(artifacts): for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): cell = r * n + c if cell not in artifact_cells: artifact_cells[cell] = set() artifact_cells[cell].add(i) artifact_count[i] = artifact_count.get(i, 0) + 1 ans = 0 for r, c in dig: cell = r * n + c if cell in artifact_cells: for artifact_id in artifact_cells[cell]: artifact_count[artifact_id] -= 1 if artifact_count[artifact_id] == 0: ans += 1 del artifact_cells[cell] return ans"},{"prompt":"On an infinite plane, a robot initially stands at `(0, 0)` and faces north. Note that: * The **north direction** is the positive direction of the yaxis. * The **south direction** is the negative direction of the yaxis. * The **east direction** is the positive direction of the xaxis. * The **west direction** is the negative direction of the xaxis. The robot can receive one of three instructions: * `G `: go straight 1 unit. * `L `: turn 90 degrees to the left (i.e., anticlockwise direction). * `R `: turn 90 degrees to the right (i.e., clockwise direction). The robot performs the `instructions` given in order, and repeats them forever. Return `true` if and only if there exists a circle in the plane such that the robot never leaves the circle. **Example 1:** **Input:** instructions = GGLLGG **Output:** true **Explanation:** The robot is initially at (0, 0) facing the north direction. G : move one step. Position: (0, 1). Direction: North. G : move one step. Position: (0, 2). Direction: North. L : turn 90 degrees anticlockwise. Position: (0, 2). Direction: West. L : turn 90 degrees anticlockwise. Position: (0, 2). Direction: South. G : move one step. Position: (0, 1). Direction: South. G : move one step. Position: (0, 0). Direction: South. Repeating the instructions, the robot goes into the cycle: (0, 0) > (0, 1) > (0, 2) > (0, 1) > (0, 0). Based on that, we return true. **Example 2:** **Input:** instructions = GG **Output:** false **Explanation:** The robot is initially at (0, 0) facing the north direction. G : move one step. Position: (0, 1). Direction: North. G : move one step. Position: (0, 2). Direction: North. Repeating the instructions, keeps advancing in the north direction and does not go into cycles. Based on that, we return false. **Example 3:** **Input:** instructions = GL **Output:** true **Explanation:** The robot is initially at (0, 0) facing the north direction. G : move one step. Position: (0, 1). Direction: North. L : turn 90 degrees anticlockwise. Position: (0, 1). Direction: West. G : move one step. Position: (1, 1). Direction: West. L : turn 90 degrees anticlockwise. Position: (1, 1). Direction: South. G : move one step. Position: (1, 0). Direction: South. L : turn 90 degrees anticlockwise. Position: (1, 0). Direction: East. G : move one step. Position: (0, 0). Direction: East. L : turn 90 degrees anticlockwise. Position: (0, 0). Direction: North. Repeating the instructions, the robot goes into the cycle: (0, 0) > (0, 1) > (1, 1) > (1, 0) > (0, 0). Based on that, we return true. **Constraints:** * `1 <= instructions.length <= 100` * `instructions[i]` is `\'G\'`, `\'L\'` or, `\'R\'`.","completion":"def numRookCaptures(board): x, y, captures = 0, 0, 0 for i in range(8): for j in range(8): if board[i][j] == \'R\': x, y = i, j break if board[x][y] == \'R\': break dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in dirs: nx, ny = x + dx, y + dy while 0 <= nx < 8 and 0 <= ny < 8: if board[nx][ny] == \'p\': captures += 1 break elif board[nx][ny] == \'B\': break nx += dx ny += dy return captures"},{"prompt":"You have `n` packages that you are trying to place in boxes, **one package in each box**. There are `m` suppliers that each produce boxes of **different sizes** (with infinite supply). A package can be placed in a box if the size of the package is **less than or equal to** the size of the box. The package sizes are given as an integer array `packages`, where `packages[i]` is the **size** of the `ith` package. The suppliers are given as a 2D integer array `boxes`, where `boxes[j]` is an array of **box sizes** that the `jth` supplier produces. You want to choose a **single supplier** and use boxes from them such that the **total wasted space** is **minimized**. For each package in a box, we define the space **wasted** to be `size of the box size of the package`. The **total wasted space** is the sum of the space wasted in **all** the boxes. * For example, if you have to fit packages with sizes `[2,3,5]` and the supplier offers boxes of sizes `[4,8]`, you can fit the packages of size`2` and size`3` into two boxes of size`4` and the package with size`5` into a box of size`8`. This would result in a waste of `(42) + (43) + (85) = 6`. Return _the **minimum total wasted space** by choosing the box supplier **optimally**, or_ `1` _if it is **impossible** to fit all the packages inside boxes._ Since the answer may be **large**, return it **modulo** `109 + 7`. **Example 1:** **Input:** packages = [2,3,5], boxes = [[4,8],[2,8]] **Output:** 6 **Explanation**: It is optimal to choose the first supplier, using two size4 boxes and one size8 box. The total waste is (42) + (43) + (85) = 6. **Example 2:** **Input:** packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]] **Output:** 1 **Explanation:** There is no box that the package of size 5 can fit in. **Example 3:** **Input:** packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]] **Output:** 9 **Explanation:** It is optimal to choose the third supplier, using two size5 boxes, two size10 boxes, and two size14 boxes. The total waste is (53) + (55) + (108) + (1010) + (1411) + (1412) = 9. **Constraints:** * `n == packages.length` * `m == boxes.length` * `1 <= n <= 105` * `1 <= m <= 105` * `1 <= packages[i] <= 105` * `1 <= boxes[j].length <= 105` * `1 <= boxes[j][k] <= 105` * `sum(boxes[j].length) <= 105` * The elements in `boxes[j]` are **distinct**.","completion":"def check_powers_of_three(n: int) -> bool: while n > 0: if n % 3 == 2: return False n //= 3 return True"},{"prompt":"a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has. Consider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person. * For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`. Return _any sufficient team of the smallest possible size, represented by the index of each person_. You may return the answer in **any order**. It is **guaranteed** an answer exists. **Example 1:** **Input:** req_skills = [java,nodejs,reactjs], people = [[java],[nodejs],[nodejs,reactjs]] **Output:** [0,2] **Example 2:** **Input:** req_skills = [algorithms,math,java,reactjs,csharp,aws], people = [[algorithms,math,java],[algorithms,math,reactjs],[java,csharp,aws],[reactjs,csharp],[csharp,math],[aws,java]] **Output:** [1,2] **Constraints:** * `1 <= req_skills.length <= 16` * `1 <= req_skills[i].length <= 16` * `req_skills[i]` consists of lowercase English letters. * All the strings of `req_skills` are **unique**. * `1 <= people.length <= 60` * `0 <= people[i].length <= 16` * `1 <= people[i][j].length <= 16` * `people[i][j]` consists of lowercase English letters. * All the strings of `people[i]` are **unique**. * Every skill in `people[i]` is a skill in `req_skills`. * It is guaranteed a sufficient team exists.","completion":"from collections import defaultdict from math import log2 def smallestSufficientTeam(req_skills, people): skill_to_id = {skill: idx for idx, skill in enumerate(req_skills)} n, m = len(people), len(req_skills) dp = [float(\\"inf\\")] * (1 << m) pre = [0] * (1 << m) skill_set = [0] * (1 << m) dp[0] = 0 for i, skills in enumerate(people): skill_mask = sum(1 << skill_to_id[skill] for skill in skills) for j in range((1 << m) - 1, -1, -1): if dp[j | skill_mask] > dp[j] + 1: dp[j | skill_mask] = dp[j] + 1 pre[j | skill_mask] = j skill_set[j | skill_mask] = i res = [] mask = (1 << m) - 1 while mask: res.append(skill_set[mask]) mask = pre[mask] return res"},{"prompt":"There is an exam room with `n` seats in a single row labeled from `0` to `n 1`. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number `0`. Design a class that simulates the mentioned exam room. Implement the `ExamRoom` class: * `ExamRoom(int n)` Initializes the object of the exam room with the number of the seats `n`. * `int seat()` Returns the label of the seat at which the next student will set. * `void leave(int p)` Indicates that the student sitting at seat `p` will leave the room. It is guaranteed that there will be a student sitting at seat `p`. **Example 1:** **Input** [ ExamRoom , seat , seat , seat , seat , leave , seat ] [[10], [], [], [], [], [4], []] **Output** [null, 0, 9, 4, 2, null, 5] **Explanation** ExamRoom examRoom = new ExamRoom(10); examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0. examRoom.seat(); // return 9, the student sits at the last seat number 9. examRoom.seat(); // return 4, the student sits at the last seat number 4. examRoom.seat(); // return 2, the student sits at the last seat number 2. examRoom.leave(4); examRoom.seat(); // return 5, the student sits at the last seat number 5. **Constraints:** * `1 <= n <= 109` * It is guaranteed that there is a student sitting at seat `p`. * At most `104` calls will be made to `seat` and `leave`.","completion":"def count_unique_chars(s): return len(set(s)) def sum_count_unique_chars(s): sum = 0 for i in range(len(s)): for j in range(i + 1, len(s) + 1): sum += count_unique_chars(s[i:j]) return sum"},{"prompt":"You are standing at position `0` on an infinite number line. There is a destination at position `target`. You can make some number of moves `numMoves` so that: * On each move, you can either go left or right. * During the `ith` move (starting from `i == 1` to `i == numMoves`), you take `i` steps in the chosen direction. Given the integer `target`, return _the **minimum** number of moves required (i.e., the minimum_ `numMoves`_) to reach the destination_. **Example 1:** **Input:** target = 2 **Output:** 3 **Explanation:** On the 1st move, we step from 0 to 1 (1 step). On the 2nd move, we step from 1 to 1 (2 steps). On the 3rd move, we step from 1 to 2 (3 steps). **Example 2:** **Input:** target = 3 **Output:** 2 **Explanation:** On the 1st move, we step from 0 to 1 (1 step). On the 2nd move, we step from 1 to 3 (2 steps). **Constraints:** * `109 <= target <= 109` * `target != 0`","completion":"def reachNumber(target: int) -> int: target = abs(target) step = 0 sum = 0 while sum < target: step += 1 sum += step while (sum - target) % 2 != 0: step += 1 sum += step return step"},{"prompt":"Given an integer array `instructions`, you are asked to create a sorted array from the elements in `instructions`. You start with an empty container `nums`. For each element from **left to right** in `instructions`, insert it into `nums`. The **cost** of each insertion is the **minimum** of the following: * The number of elements currently in `nums` that are **strictly less than** `instructions[i]`. * The number of elements currently in `nums` that are **strictly greater than** `instructions[i]`. For example, if inserting element `3` into `nums = [1,2,3,5]`, the **cost** of insertion is `min(2, 1)` (elements `1` and `2` are less than `3`, element `5` is greater than `3`) and `nums` will become `[1,2,3,3,5]`. Return _the **total cost** to insert all elements from_ `instructions` _into_ `nums`. Since the answer may be large, return it **modulo** `109 + 7` **Example 1:** **Input:** instructions = [1,5,6,2] **Output:** 1 **Explanation:** Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 5 with cost min(1, 0) = 0, now nums = [1,5]. Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6]. Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6]. The total cost is 0 + 0 + 0 + 1 = 1. **Example 2:** **Input:** instructions = [1,2,3,6,5,4] **Output:** 3 **Explanation:** Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 2 with cost min(1, 0) = 0, now nums = [1,2]. Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3]. Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6]. Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6]. Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6]. The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3. **Example 3:** **Input:** instructions = [1,3,3,3,2,4,2,1,2] **Output:** 4 **Explanation:** Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3]. Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3]. Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4]. ​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4]. ​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4]. ​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4]. The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4. **Constraints:** * `1 <= instructions.length <= 105` * `1 <= instructions[i] <= 105`","completion":"def maxNonOverlapping(nums, target): prefix_sum = {0: 1} sum_so_far = count = 0 for num in nums: sum_so_far += num if sum_so_far - target in prefix_sum: count += 1 prefix_sum.clear() prefix_sum[0] = 1 sum_so_far = 0 else: prefix_sum[sum_so_far] = prefix_sum.get(sum_so_far, 0) + 1 return count"},{"prompt":"Given three integer arrays `nums1`, `nums2`, and `nums3`, return _a **distinct** array containing all the values that are present in **at least two** out of the three arrays. You may return the values in **any** order_. **Example 1:** **Input:** nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3] **Output:** [3,2] **Explanation:** The values that are present in at least two arrays are: 3, in all three arrays. 2, in nums1 and nums2. **Example 2:** **Input:** nums1 = [3,1], nums2 = [2,3], nums3 = [1,2] **Output:** [2,3,1] **Explanation:** The values that are present in at least two arrays are: 2, in nums2 and nums3. 3, in nums1 and nums2. 1, in nums1 and nums3. **Example 3:** **Input:** nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5] **Output:** [] **Explanation:** No value is present in at least two arrays. **Constraints:** * `1 <= nums1.length, nums2.length, nums3.length <= 100` * `1 <= nums1[i], nums2[j], nums3[k] <= 100`","completion":"def largest_odd(num: str) -> str: for i in range(len(num)): if (int(num[i]) % 2) == 1: return num[:i + 1] return \\"\\""},{"prompt":"Given a string `s` consisting of lowercase English letters, return _the first letter to appear **twice**_. **Note**: * A letter `a` appears twice before another letter `b` if the **second** occurrence of `a` is before the **second** occurrence of `b`. * `s` will contain at least one letter that appears twice. **Example 1:** **Input:** s = abccbaacz **Output:** c **Explanation:** The letter \'a\' appears on the indexes 0, 5 and 6. The letter \'b\' appears on the indexes 1 and 4. The letter \'c\' appears on the indexes 2, 3 and 7. The letter \'z\' appears on the index 8. The letter \'c\' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest. **Example 2:** **Input:** s = abcdd **Output:** d **Explanation:** The only letter that appears twice is \'d\' so we return \'d\'. **Constraints:** * `2 <= s.length <= 100` * `s` consists of lowercase English letters. * `s` has at least one repeated letter.","completion":"def first_letter_to_appear_twice(s: str) -> str: occurrences = [0] * 26 for c in s: occurrences[ord(c) - ord(\'a\')] += 1 if occurrences[ord(c) - ord(\'a\')] == 2: return c return \'?\'"},{"prompt":"You are given the `root` of a binary tree where each node has a value `0` or `1`. Each roottoleaf path represents a binary number starting with the most significant bit. * For example, if the path is `0 > 1 > 1 > 0 > 1`, then this could represent `01101` in binary, which is `13`. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return _the sum of these numbers_. The test cases are generated so that the answer fits in a **32bits** integer. **Example 1:** **Input:** root = [1,0,1,0,1,0,1] **Output:** 22 **Explanation:** (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 **Example 2:** **Input:** root = [0] **Output:** 0 **Constraints:** * The number of nodes in the tree is in the range `[1, 1000]`. * `Node.val` is `0` or `1`.","completion":"def uniquePathsIII(grid): x, y, empty = 0, 0, 1 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: x, y = i, j elif grid[i][j] == 0: empty += 1 return dfs(grid, x, y, empty) def dfs(grid, x, y, empty): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1: return 0 if grid[x][y] == 2: return 1 if empty == -1 else 0 grid[x][y] = -1 paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1) grid[x][y] = 0 return paths"},{"prompt":"You are given the `root` of a binary tree. A ZigZag path for a binary tree is defined as follow: * Choose **any** node in the binary tree and a direction (right or left). * If the current direction is right, move to the right child of the current node; otherwise, move to the left child. * Change the direction from right to left or from left to right. * Repeat the second and third steps until you can\'t move in the tree. Zigzag length is defined as the number of nodes visited 1. (A single node has a length of 0). Return _the longest **ZigZag** path contained in that tree_. **Example 1:** **Input:** root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1] **Output:** 3 **Explanation:** Longest ZigZag path in blue nodes (right > left > right). **Example 2:** **Input:** root = [1,1,1,null,1,null,null,1,1,null,1] **Output:** 4 **Explanation:** Longest ZigZag path in blue nodes (left > right > left > right). **Example 3:** **Input:** root = [1] **Output:** 0 **Constraints:** * The number of nodes in the tree is in the range `[1, 5 * 104]`. * `1 <= Node.val <= 100`","completion":"from math import gcd from functools import reduce def is_good_array(nums): gcd_value = reduce(gcd, nums) return gcd_value == 1"},{"prompt":"You have `n` buckets each containing some gallons of water in it, represented by a **0indexed** integer array `buckets`, where the `ith` bucket contains `buckets[i]` gallons of water. You are also given an integer `loss`. You want to make the amount of water in each bucket equal. You can pour any amount of water from one bucket to another bucket (not necessarily an integer). However, every time you pour `k` gallons of water, you spill `loss` **percent** of `k`. Return _the **maximum** amount of water in each bucket after making the amount of water equal._ Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** buckets = [1,2,7], loss = 80 **Output:** 2.00000 **Explanation:** Pour 5 gallons of water from buckets[2] to buckets[0]. 5 * 80% = 4 gallons are spilled and buckets[0] only receives 5 4 = 1 gallon of water. All buckets have 2 gallons of water in them so return 2. **Example 2:** **Input:** buckets = [2,4,6], loss = 50 **Output:** 3.50000 **Explanation:** Pour 0.5 gallons of water from buckets[1] to buckets[0]. 0.5 * 50% = 0.25 gallons are spilled and buckets[0] only receives 0.5 0.25 = 0.25 gallons of water. Now, buckets = [2.25, 3.5, 6]. Pour 2.5 gallons of water from buckets[2] to buckets[0]. 2.5 * 50% = 1.25 gallons are spilled and buckets[0] only receives 2.5 1.25 = 1.25 gallons of water. All buckets have 3.5 gallons of water in them so return 3.5. **Example 3:** **Input:** buckets = [3,3,3,3], loss = 40 **Output:** 3.00000 **Explanation:** All buckets already have the same amount of water in them. **Constraints:** * `1 <= buckets.length <= 105` * `0 <= buckets[i] <= 105` * `0 <= loss <= 99`","completion":"def perform_operations(operations): X = 0 for op in operations: if op == \\"++X\\" or op == \\"X++\\": X += 1 elif op == \\"--X\\" or op == \\"X--\\": X -= 1 return X"},{"prompt":"Sometimes people repeat letters to represent extra feeling. For example: * `hello > heeellooo ` * `hi > hiiii ` In these strings like `heeellooo `, we have groups of adjacent letters that are all the same: `h `, `eee `, `ll `, `ooo `. You are given a string `s` and an array of query strings `words`. A query word is **stretchy** if it can be made to be equal to `s` by any number of applications of the following extension operation: choose a group consisting of characters `c`, and add some number of characters `c` to the group so that the size of the group is **three or more**. * For example, starting with `hello `, we could do an extension on the group `o ` to get `hellooo `, but we cannot get `helloo ` since the group `oo ` has a size less than three. Also, we could do another extension like `ll > lllll ` to get `helllllooo `. If `s = helllllooo `, then the query word `hello ` would be **stretchy** because of these two extension operations: `query = hello > hellooo > helllllooo = s`. Return _the number of query strings that are **stretchy**_. **Example 1:** **Input:** s = heeellooo , words = [ hello , hi , helo ] **Output:** 1 **Explanation:** We can extend e and o in the word hello to get heeellooo . We can\'t extend helo to get heeellooo because the group ll is not size 3 or more. **Example 2:** **Input:** s = zzzzzyyyyy , words = [ zzyy , zy , zyy ] **Output:** 3 **Constraints:** * `1 <= s.length, words.length <= 100` * `1 <= words[i].length <= 100` * `s` and `words[i]` consist of lowercase letters.","completion":"def num_zeros(k): x = 0 i = 5 while k // i >= 1: x += k // i i *= 5 return x"},{"prompt":"There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly. Given a string `text` of words separated by a single space (no leading or trailing spaces) and a string `brokenLetters` of all **distinct** letter keys that are broken, return _the **number of words** in_ `text` _you can fully type using this keyboard_. **Example 1:** **Input:** text = hello world , brokenLetters = ad **Output:** 1 **Explanation:** We cannot type world because the \'d\' key is broken. **Example 2:** **Input:** text = leet code , brokenLetters = lt **Output:** 1 **Explanation:** We cannot type leet because the \'l\' and \'t\' keys are broken. **Example 3:** **Input:** text = leet code , brokenLetters = e **Output:** 0 **Explanation:** We cannot type either word because the \'e\' key is broken. **Constraints:** * `1 <= text.length <= 104` * `0 <= brokenLetters.length <= 26` * `text` consists of words separated by a single space without any leading or trailing spaces. * Each word only consists of lowercase English letters. * `brokenLetters` consists of **distinct** lowercase English letters.","completion":"def min_operations(n): count = 1 temp = 1 while temp % n != 0: temp = (temp * 2) % n count += 1 return count"},{"prompt":"You are given a string `s` consisting of lowercase English letters. A **duplicate removal** consists of choosing two **adjacent** and **equal** letters and removing them. We repeatedly make **duplicate removals** on `s` until we no longer can. Return _the final string after all such duplicate removals have been made_. It can be proven that the answer is **unique**. **Example 1:** **Input:** s = abbaca **Output:** ca **Explanation:** For example, in abbaca we could remove bb since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is aaca , of which only aa is possible, so the final string is ca . **Example 2:** **Input:** s = azxxzy **Output:** ay **Constraints:** * `1 <= s.length <= 105` * `s` consists of lowercase English letters.","completion":"import heapq def maxSumAfterKOperations(nums, k): heapq.heapify(nums) for _ in range(k): current = heapq.heappop(nums) heapq.heappush(nums, -current) return sum(nums)"},{"prompt":"You are given an array `points` where `points[i] = [xi, yi]` is the coordinates of the `ith` point on a 2D plane. Multiple points can have the **same** coordinates. You are also given an array `queries` where `queries[j] = [xj, yj, rj]` describes a circle centered at `(xj, yj)` with a radius of `rj`. For each query `queries[j]`, compute the number of points **inside** the `jth` circle. Points **on the border** of the circle are considered **inside**. Return _an array_ `answer`_, where_ `answer[j]` _is the answer to the_ `jth` _query_. **Example 1:** **Input:** points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]] **Output:** [3,2,2] **Explanation:** The points and circles are shown above. queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle. **Example 2:** **Input:** points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]] **Output:** [2,3,2,4] **Explanation:** The points and circles are shown above. queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple. **Constraints:** * `1 <= points.length <= 500` * `points[i].length == 2` * `0 <= x​​​​​​i, y​​​​​​i <= 500` * `1 <= queries.length <= 500` * `queries[j].length == 3` * `0 <= xj, yj <= 500` * `1 <= rj <= 500` * All coordinates are integers.","completion":"def countPoints(points, queries): answer = [] for query in queries: inside = 0 for point in points: dx = point[0] - query[0] dy = point[1] - query[1] if dx * dx + dy * dy <= query[2] * query[2]: inside += 1 answer.append(inside) return answer"},{"prompt":"There is a 1 million by 1 million grid on an XYplane, and the coordinates of each grid square are `(x, y)`. We start at the `source = [sx, sy]` square and want to reach the `target = [tx, ty]` square. There is also an array of `blocked` squares, where each `blocked[i] = [xi, yi]` represents a blocked square with coordinates `(xi, yi)`. Each move, we can walk one square north, east, south, or west if the square is **not** in the array of `blocked` squares. We are also not allowed to walk outside of the grid. Return `true` _if and only if it is possible to reach the_ `target` _square from the_ `source` _square through a sequence of valid moves_. **Example 1:** **Input:** blocked = [[0,1],[1,0]], source = [0,0], target = [0,2] **Output:** false **Explanation:** The target square is inaccessible starting from the source square because we cannot move. We cannot move north or east because those squares are blocked. We cannot move south or west because we cannot go outside of the grid. **Example 2:** **Input:** blocked = [], source = [0,0], target = [999999,999999] **Output:** true **Explanation:** Because there are no blocked cells, it is possible to reach the target square. **Constraints:** * `0 <= blocked.length <= 200` * `blocked[i].length == 2` * `0 <= xi, yi < 106` * `source.length == target.length == 2` * `0 <= sx, sy, tx, ty < 106` * `source != target` * It is guaranteed that `source` and `target` are not blocked.","completion":"from collections import deque def orangesRotting(grid): m, n = len(grid), len(grid[0]) fresh_oranges = sum(row.count(1) for row in grid) rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2]) minutes = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while rotten and fresh_oranges: for _ in range(len(rotten)): x, y = rotten.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 rotten.append((nx, ny)) minutes += 1 return minutes if fresh_oranges == 0 else -1"},{"prompt":"You are given an array `rectangles` where `rectangles[i] = [li, wi]` represents the `ith` rectangle of length `li` and width `wi`. You can cut the `ith` rectangle to form a square with a side length of `k` if both `k <= li` and `k <= wi`. For example, if you have a rectangle `[4,6]`, you can cut it to get a square with a side length of at most `4`. Let `maxLen` be the side length of the **largest** square you can obtain from any of the given rectangles. Return _the **number** of rectangles that can make a square with a side length of_ `maxLen`. **Example 1:** **Input:** rectangles = [[5,8],[3,9],[5,12],[16,5]] **Output:** 3 **Explanation:** The largest squares you can get from each rectangle are of lengths [5,3,5,5]. The largest possible square is of length 5, and you can get it out of 3 rectangles. **Example 2:** **Input:** rectangles = [[2,3],[3,7],[4,3],[3,7]] **Output:** 3 **Constraints:** * `1 <= rectangles.length <= 1000` * `rectangles[i].length == 2` * `1 <= li, wi <= 109` * `li != wi`","completion":"def numberOfSets(n, k): mod = 10**9 + 7 dp = [[0] * (k + 1) for _ in range(n)] presum = [1] * n for j in range(1, k + 1): for i in range(n): dp[i][j] = presum[i] if i > 0: dp[i][j] += dp[i - 1][j] dp[i][j] %= mod presum[i] = (presum[i] + dp[i][j - 1]) % mod return dp[n - 1][k]"},{"prompt":"Given an array of integers arr, find the sum of `min(b)`, where `b` ranges over every (contiguous) subarray of `arr`. Since the answer may be large, return the answer **modulo** `109 + 7`. **Example 1:** **Input:** arr = [3,1,2,4] **Output:** 17 **Explanation:** Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. **Example 2:** **Input:** arr = [11,81,94,43,3] **Output:** 444 **Constraints:** * `1 <= arr.length <= 3 * 104` * `1 <= arr[i] <= 3 * 104`","completion":"def minEatingSpeed(piles, h): left, right = 1, max(piles) while left < right: mid = left + (right - left) // 2 totalHours = sum((pile + mid - 1) // mid for pile in piles) if totalHours > h: left = mid + 1 else: right = mid return left"},{"prompt":"There are several squares being dropped onto the Xaxis of a 2D plane. You are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with Xcoordinate `lefti`. Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands **on the top side of another square** or **on the Xaxis**. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved. After each square is dropped, you must record the **height of the current tallest stack of squares**. Return _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_. **Example 1:** **Input:** positions = [[1,2],[2,3],[6,1]] **Output:** [2,5,5] **Explanation:** After the first drop, the tallest stack is square 1 with a height of 2. After the second drop, the tallest stack is squares 1 and 2 with a height of 5. After the third drop, the tallest stack is still squares 1 and 2 with a height of 5. Thus, we return an answer of [2, 5, 5]. **Example 2:** **Input:** positions = [[100,100],[200,100]] **Output:** [100,100] **Explanation:** After the first drop, the tallest stack is square 1 with a height of 100. After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100. Thus, we return an answer of [100, 100]. Note that square 2 only brushes the right side of square 1, which does not count as landing on it. **Constraints:** * `1 <= positions.length <= 1000` * `1 <= lefti <= 108` * `1 <= sideLengthi <= 106`","completion":"def fallingSquares(positions): ans = [] intervals = [] for p in positions: L, size = p R = L + size h = size for h2, R2 in intervals: if R2 > L and R > R2: h = max(h, size + h2) maxHeight = max((h2 for h2, R2 in intervals), default=0) ans.append(max(maxHeight, h)) intervals.append((h, R)) return ans"},{"prompt":"You are given two integers `height` and `width` representing a garden of size `height x width`. You are also given: * an array `tree` where `tree = [treer, treec]` is the position of the tree in the garden, * an array `squirrel` where `squirrel = [squirrelr, squirrelc]` is the position of the squirrel in the garden, * and an array `nuts` where `nuts[i] = [nutir, nutic]` is the position of the `ith` nut in the garden. The squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell. Return _the **minimal distance** for the squirrel to collect all the nuts and put them under the tree one by one_. The **distance** is the number of moves. **Example 1:** **Input:** height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]] **Output:** 12 **Explanation:** The squirrel should go to the nut at [2, 5] first to achieve a minimal distance. **Example 2:** **Input:** height = 1, width = 3, tree = [0,1], squirrel = [0,0], nuts = [[0,2]] **Output:** 3 **Constraints:** * `1 <= height, width <= 100` * `tree.length == 2` * `squirrel.length == 2` * `1 <= nuts.length <= 5000` * `nuts[i].length == 2` * `0 <= treer, squirrelr, nutir <= height` * `0 <= treec, squirrelc, nutic <= width`","completion":"def minDistance(height, width, tree, squirrel, nuts): totalDist = 0 minDiff = float(\\"inf\\") for nut in nuts: treeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1]) squirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1]) totalDist += 2 * treeDist minDiff = min(minDiff, squirrelDist - treeDist) return totalDist + minDiff"},{"prompt":"You are given an array of **distinct** positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively. At each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`. Notice that `fuel` **cannot** become negative at any point in time, and that you are **allowed** to visit any city more than once (including `start` and `finish`). Return _the count of all possible routes from_ `start` _to_ `finish`. Since the answer may be too large, return it modulo `109 + 7`. **Example 1:** **Input:** locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5 **Output:** 4 **Explanation:** The following are all possible routes, each uses 5 units of fuel: 1 > 3 1 > 2 > 3 1 > 4 > 3 1 > 4 > 2 > 3 **Example 2:** **Input:** locations = [4,3,1], start = 1, finish = 0, fuel = 6 **Output:** 5 **Explanation:** The following are all possible routes: 1 > 0, used fuel = 1 1 > 2 > 0, used fuel = 5 1 > 2 > 1 > 0, used fuel = 5 1 > 0 > 1 > 0, used fuel = 3 1 > 0 > 1 > 0 > 1 > 0, used fuel = 5 **Example 3:** **Input:** locations = [5,2,1], start = 0, finish = 2, fuel = 3 **Output:** 0 **Explanation:** It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel. **Constraints:** * `2 <= locations.length <= 100` * `1 <= locations[i] <= 109` * All integers in `locations` are **distinct**. * `0 <= start, finish < locations.length` * `1 <= fuel <= 200`","completion":"def maxArea(h, w, horizontalCuts, verticalCuts): horizontalCuts.sort() verticalCuts.sort() maxH = max(horizontalCuts[0], h - horizontalCuts[-1]) maxV = max(verticalCuts[0], w - verticalCuts[-1]) for i in range(1, len(horizontalCuts)): maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1]) for i in range(1, len(verticalCuts)): maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1]) return (maxH * maxV) % (10**9 + 7)"},{"prompt":"You are given a binary string `s` consisting only of zeroes and ones. A substring of `s` is considered balanced if **all zeroes are before ones** and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring. Return _the length of the longest balanced substring of_ `s`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** **Input:** s = 01000111 **Output:** 6 **Explanation:** The longest balanced substring is 000111 , which has length 6. **Example 2:** **Input:** s = 00111 **Output:** 4 **Explanation:** The longest balanced substring is 0011 , which has length 4. **Example 3:** **Input:** s = 111 **Output:** 0 **Explanation:** There is no balanced substring except the empty substring, so the answer is 0. **Constraints:** * `1 <= s.length <= 50` * `\'0\' <= s[i] <= \'1\'`","completion":"def longestBalancedSubstring(s): max_len = 0 zeros = ones = 0 for c in s: if c == \'0\': zeros += 1 else: ones += 1 if zeros == ones: max_len = max(max_len, zeros * 2) elif zeros > ones: zeros = ones = 0 zeros = ones = 0 for c in reversed(s): if c == \'0\': zeros += 1 else: ones += 1 if zeros == ones: max_len = max(max_len, zeros * 2) elif zeros < ones: zeros = ones = 0 return max_len"},{"prompt":"Given an array `nums` with `n` integers, your task is to check if it could become nondecreasing by modifying **at most one element**. We define an array is nondecreasing if `nums[i] <= nums[i + 1]` holds for every `i` (**0based**) such that (`0 <= i <= n 2`). **Example 1:** **Input:** nums = [4,2,3] **Output:** true **Explanation:** You could modify the first 4 to 1 to get a nondecreasing array. **Example 2:** **Input:** nums = [4,2,1] **Output:** false **Explanation:** You cannot get a nondecreasing array by modifying at most one element. **Constraints:** * `n == nums.length` * `1 <= n <= 104` * `105 <= nums[i] <= 105`","completion":"def checkPossibility(nums): cnt = 0 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: cnt += 1 if i == 1 or nums[i] >= nums[i - 2]: nums[i-1] = nums[i] else: nums[i] = nums[i - 1] if cnt > 1: return False return True"},{"prompt":"Let `f(x)` be the number of zeroes at the end of `x!`. Recall that `x! = 1 * 2 * 3 * ... * x` and by convention, `0! = 1`. * For example, `f(3) = 0` because `3! = 6` has no zeroes at the end, while `f(11) = 2` because `11! = 39916800` has two zeroes at the end. Given an integer `k`, return the number of nonnegative integers `x` have the property that `f(x) = k`. **Example 1:** **Input:** k = 0 **Output:** 5 **Explanation:** 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes. **Example 2:** **Input:** k = 5 **Output:** 0 **Explanation:** There is no x such that x! ends in k = 5 zeroes. **Example 3:** **Input:** k = 3 **Output:** 5 **Constraints:** * `0 <= k <= 109`","completion":"def canTransform(start: str, end: str) -> bool: if len(start) != len(end): return False i, j = 0, 0 n = len(start) while i < n and j < n: while i < n and start[i] == \'X\': i += 1 while j < n and end[j] == \'X\': j += 1 if start[i] != end[j]: return False if (start[i] == \'R\' and i > j) or (start[i] == \'L\' and i < j): return False i += 1 j += 1 return True"},{"prompt":"You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in **kilometers**. In addition, you are given an integer `speed`, which is the speed (in **km/h**) you will travel at. After you travel road `i`, you must rest and wait for the **next integer hour** before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting. * For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait. However, you are allowed to **skip** some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks. * For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately. Return _the **minimum number of skips required** to arrive at the meeting on time, or_ `1` _if it is **impossible**_. **Example 1:** **Input:** dist = [1,3,2], speed = 4, hoursBefore = 2 **Output:** 1 **Explanation:** Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours. You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours. Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest. **Example 2:** **Input:** dist = [7,3,5,5], speed = 2, hoursBefore = 10 **Output:** 2 **Explanation:** Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours. You can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours. **Example 3:** **Input:** dist = [7,3,5,5], speed = 1, hoursBefore = 10 **Output:** 1 **Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests. **Constraints:** * `n == dist.length` * `1 <= n <= 1000` * `1 <= dist[i] <= 105` * `1 <= speed <= 106` * `1 <= hoursBefore <= 107`","completion":"def minSkips(dist, speed, hoursBefore): n = len(dist) dp = [[1e9] * (n + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(n): for j in range(i+1): t = dist[i] / speed + (1 if j else 0) dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t) skipped_t = -(-dist[i] / speed) - dp[i][j] dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t) for i in range(n + 1): if dp[n][i] <= hoursBefore: return i return -1"},{"prompt":"You are given a string `num`, representing a large integer. Return _the **largestvalued odd** integer (as a string) that is a **nonempty substring** of_ `num`_, or an empty string_ ` ` _if no odd integer exists_. A **substring** is a contiguous sequence of characters within a string. **Example 1:** **Input:** num = 52 **Output:** 5 **Explanation:** The only nonempty substrings are 5 , 2 , and 52 . 5 is the only odd number. **Example 2:** **Input:** num = 4206 **Output:** **Explanation:** There are no odd numbers in 4206 . **Example 3:** **Input:** num = 35427 **Output:** 35427 **Explanation:** 35427 is already an odd number. **Constraints:** * `1 <= num.length <= 105` * `num` only consists of digits and does not contain any leading zeros.","completion":"def largest_odd_number(num: str) -> str: for i in range(len(num) - 1, -1, -1): if int(num[i]) % 2 != 0: return num[:i + 1] return \\"\\""},{"prompt":"A cinema has `n` rows of seats, numbered from 1 to `n` and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above. Given the array `reservedSeats` containing the numbers of seats already reserved, for example, `reservedSeats[i] = [3,8]` means the seat located in row **3** and labelled with **8** is already reserved. _Return the maximum number of fourperson groups you can assign on the cinema seats._ A fourperson group occupies four adjacent seats **in one single row**. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a fourperson group, in that case, the aisle split a fourperson group in the middle, which means to have two people on each side. **Example 1:** **Input:** n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]] **Output:** 4 **Explanation:** The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group. **Example 2:** **Input:** n = 2, reservedSeats = [[2,1],[1,8],[2,6]] **Output:** 2 **Example 3:** **Input:** n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]] **Output:** 4 **Constraints:** * `1 <= n <= 10^9` * `1 <= reservedSeats.length <= min(10*n, 10^4)` * `reservedSeats[i].length == 2` * `1 <= reservedSeats[i][0] <= n` * `1 <= reservedSeats[i][1] <= 10` * All `reservedSeats[i]` are distinct.","completion":"def shiftGrid(grid, k): m, n = len(grid), len(grid[0]) k %= (m * n) res = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): idx = (i * n + j + k) % (m * n) res[idx // n][idx % n] = grid[i][j] return res"},{"prompt":"You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer. A **cornered path** is defined as a set of adjacent cells with **at most** one turn. More specifically, the path should exclusively move either **horizontally** or **vertically** up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the **alternate** direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell. The **product** of a path is defined as the product of all the values in the path. Return _the **maximum** number of **trailing zeros** in the product of a cornered path found in_ `grid`. Note: * **Horizontal** movement means moving in either the left or right direction. * **Vertical** movement means moving in either the up or down direction. **Example 1:** **Input:** grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]] **Output:** 3 **Explanation:** The grid on the left shows a valid cornered path. It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros. It can be shown that this is the maximum trailing zeros in the product of a cornered path. The grid in the middle is not a cornered path as it has more than one turn. The grid on the right is not a cornered path as it requires a return to a previously visited cell. **Example 2:** **Input:** grid = [[4,3,2],[7,6,1],[8,8,8]] **Output:** 0 **Explanation:** The grid is shown in the figure above. There are no cornered paths in the grid that result in a product with a trailing zero. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 105` * `1 <= m * n <= 105` * `1 <= grid[i][j] <= 1000`","completion":"def can_destroy_all_asteroids(mass, asteroids): asteroids.sort() for asteroid in asteroids: if mass >= asteroid: mass += asteroid else: return False return True"},{"prompt":"There are `n` cities labeled from `1` to `n`. You are given the integer `n` and an array `connections` where `connections[i] = [xi, yi, costi]` indicates that the cost of connecting city `xi` and city `yi` (bidirectional connection) is `costi`. Return _the minimum **cost** to connect all the_ `n` _cities such that there is at least one path between each pair of cities_. If it is impossible to connect all the `n` cities, return `1`, The **cost** is the sum of the connections\' costs used. **Example 1:** **Input:** n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]] **Output:** 6 **Explanation:** Choosing any 2 edges will connect all cities so we choose the minimum 2. **Example 2:** **Input:** n = 4, connections = [[1,2,3],[3,4,4]] **Output:** 1 **Explanation:** There is no way to connect all cities even if all edges are used. **Constraints:** * `1 <= n <= 104` * `1 <= connections.length <= 104` * `connections[i].length == 3` * `1 <= xi, yi <= n` * `xi != yi` * `0 <= costi <= 105`","completion":"def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def minimumCost(n, connections): connections.sort(key=lambda x: x[2]) parent = list(range(n + 1)) cost = 0 edges = 0 for c in connections: root_x = find(parent, c[0]) root_y = find(parent, c[1]) if root_x != root_y: parent[root_y] = root_x cost += c[2] edges += 1 if edges == n - 1: break return cost if edges == n - 1 else -1"},{"prompt":"You are given two integer arrays of the same length `nums1` and `nums2`. In one operation, you are allowed to swap `nums1[i]` with `nums2[i]`. * For example, if `nums1 = [1,2,3,8]`, and `nums2 = [5,6,7,4]`, you can swap the element at `i = 3` to obtain `nums1 = [1,2,3,4]` and `nums2 = [5,6,7,8]`. Return _the minimum number of needed operations to make_ `nums1` _and_ `nums2` _**strictly increasing**_. The test cases are generated so that the given input always makes it possible. An array `arr` is **strictly increasing** if and only if `arr[0] < arr[1] < arr[2] < ... < arr[arr.length 1]`. **Example 1:** **Input:** nums1 = [1,3,5,4], nums2 = [1,2,3,7] **Output:** 1 **Explanation:** Swap nums1[3] and nums2[3]. Then the sequences are: nums1 = [1, 3, 5, 7] and nums2 = [1, 2, 3, 4] which are both strictly increasing. **Example 2:** **Input:** nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9] **Output:** 1 **Constraints:** * `2 <= nums1.length <= 105` * `nums2.length == nums1.length` * `0 <= nums1[i], nums2[i] <= 2 * 105`","completion":"from collections import deque def isBipartite(graph): colors = [0] * len(graph) for i in range(len(graph)): if colors[i] != 0: continue colors[i] = 1 queue = deque([i]) while queue: node = queue.popleft() for neighbor in graph[node]: if colors[neighbor] == 0: colors[neighbor] = -colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True"},{"prompt":"You are given a **0indexed** 2D integer array `questions` where `questions[i] = [pointsi, brainpoweri]`. The array describes the questions of an exam, where you have to process the questions **in order** (i.e., starting from question `0`) and make a decision whether to **solve** or **skip** each question. Solving question `i` will **earn** you `pointsi` points but you will be **unable** to solve each of the next `brainpoweri` questions. If you skip question `i`, you get to make the decision on the next question. * For example, given `questions = [[3, 2], [4, 3], [4, 4], [2, 5]]`: * If question `0` is solved, you will earn `3` points but you will be unable to solve questions `1` and `2`. * If instead, question `0` is skipped and question `1` is solved, you will earn `4` points but you will be unable to solve questions `2` and `3`. Return _the **maximum** points you can earn for the exam_. **Example 1:** **Input:** questions = [[3,2],[4,3],[4,4],[2,5]] **Output:** 5 **Explanation:** The maximum points can be earned by solving questions 0 and 3. Solve question 0: Earn 3 points, will be unable to solve the next 2 questions Unable to solve questions 1 and 2 Solve question 3: Earn 2 points Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points. **Example 2:** **Input:** questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] **Output:** 7 **Explanation:** The maximum points can be earned by solving questions 1 and 4. Skip question 0 Solve question 1: Earn 2 points, will be unable to solve the next 2 questions Unable to solve questions 2 and 3 Solve question 4: Earn 5 points Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points. **Constraints:** * `1 <= questions.length <= 105` * `questions[i].length == 2` * `1 <= pointsi, brainpoweri <= 105`","completion":"def longest_subsequence_repeated_k(s, k): counts = [0] * 26 for c in s: counts[ord(c) - ord(\'a\')] += 1 seq = \'\'.join([chr(i + ord(\'a\')) * (counts[i] // k) for i in range(25, -1, -1)]) return seq"},{"prompt":"You are given an array `nums`​​​ and an integer `k`​​​​​. The XOR of a segment `[left, right]` where `left <= right` is the `XOR` of all the elements with indices between `left` and `right`, inclusive: `nums[left] XOR nums[left+1] XOR ... XOR nums[right]`. Return _the minimum number of elements to change in the array_ such that the `XOR` of all segments of size `k`​​​​​​ is equal to zero. **Example 1:** **Input:** nums = [1,2,0,3,0], k = 1 **Output:** 3 **Explanation:** Modify the array from [**1**,**2**,0,**3**,0] to from [**0**,**0**,0,**0**,0]. **Example 2:** **Input:** nums = [3,4,5,2,1,7,3,4,7], k = 3 **Output:** 3 **Explanation:** Modify the array from [3,4,**5**,**2**,**1**,7,3,4,7] to [3,4,**7**,**3**,**4**,7,3,4,7]. **Example 3:** **Input:** nums = [1,2,4,1,2,5,1,2,6], k = 3 **Output:** 3 **Explanation:** Modify the array from [1,2,**4,**1,2,**5**,1,2,**6**] to [1,2,**3**,1,2,**3**,1,2,**3**]. **Constraints:** * `1 <= k <= nums.length <= 2000` * `​​​​​​0 <= nums[i] < 210`","completion":"def calculate_summation_of_absolute_differences(nums): n = len(nums) result = [0] * n for i in range(n): for j in range(n): if i != j: result[i] += abs(nums[i] - nums[j]) return result"},{"prompt":"You are given an array of strings `words` and a string `pref`. Return _the number of strings in_ `words` _that contain_ `pref` _as a **prefix**_. A **prefix** of a string `s` is any leading contiguous substring of `s`. **Example 1:** **Input:** words = [ pay , **at**tention , practice , **at**tend ], `pref` = at **Output:** 2 **Explanation:** The 2 strings that contain at as a prefix are: **at**tention and **at**tend . **Example 2:** **Input:** words = [ leetcode , win , loops , success ], `pref` = code **Output:** 0 **Explanation:** There are no strings that contain code as a prefix. **Constraints:** * `1 <= words.length <= 100` * `1 <= words[i].length, pref.length <= 100` * `words[i]` and `pref` consist of lowercase English letters.","completion":"def count_prefixes(words, pref): return sum(1 for word in words if word.startswith(pref))"},{"prompt":"A series of highways connect `n` cities numbered from `0` to `n 1`. You are given a 2D integer array `highways` where `highways[i] = [city1i, city2i, tolli]` indicates that there is a highway that connects `city1i` and `city2i`, allowing a car to go from `city1i` to `city2i` and **vice versa** for a cost of `tolli`. You are also given an integer `k`. You are going on a trip that crosses **exactly** `k` highways. You may start at any city, but you may only visit each city **at most** once during your trip. Return _the **maximum** cost of your trip. If there is no trip that meets the requirements, return_ `1`_._ **Example 1:** **Input:** n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], k = 3 **Output:** 17 **Explanation:** One possible trip is to go from 0 > 1 > 4 > 3. The cost of this trip is 4 + 11 + 2 = 17. Another possible trip is to go from 4 > 1 > 2 > 3. The cost of this trip is 11 + 3 + 3 = 17. It can be proven that 17 is the maximum possible cost of any valid trip. Note that the trip 4 > 1 > 0 > 1 is not allowed because you visit the city 1 twice. **Example 2:** **Input:** n = 4, highways = [[0,1,3],[2,3,2]], k = 2 **Output:** 1 **Explanation:** There are no valid trips of length 2, so return 1. **Constraints:** * `2 <= n <= 15` * `1 <= highways.length <= 50` * `highways[i].length == 3` * `0 <= city1i, city2i <= n 1` * `city1i != city2i` * `0 <= tolli <= 100` * `1 <= k <= 50` * There are no duplicate highways.","completion":"def dfs(curr_city, remaining_highways, cost_so_far, highways, visited): if remaining_highways == 0: return cost_so_far visited[curr_city] = True max_cost = -1 for highway in highways: next_city = -1 if highway[0] == curr_city and not visited[highway[1]]: next_city = highway[1] elif highway[1] == curr_city and not visited[highway[0]]: next_city = highway[0] if next_city != -1: cost = dfs(next_city, remaining_highways - 1, cost_so_far + highway[2], highways, visited) max_cost = max(max_cost, cost) visited[curr_city] = False return max_cost def max_cost(n, highways, k): visited = [False] * n max_cost = -1 for i in range(n): cost = dfs(i, k, 0, highways, visited) max_cost = max(max_cost, cost) return max_cost"},{"prompt":"Given a palindromic string of lowercase English letters `palindrome`, replace **exactly one** character with any lowercase English letter so that the resulting string is **not** a palindrome and that it is the **lexicographically smallest** one possible. Return _the resulting string. If there is no way to replace a character to make it not a palindrome, return an **empty string**._ A string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly smaller than the corresponding character in `b`. For example, `abcc ` is lexicographically smaller than `abcd ` because the first position they differ is at the fourth character, and `\'c\'` is smaller than `\'d\'`. **Example 1:** **Input:** palindrome = abccba **Output:** aaccba **Explanation:** There are many ways to make abccba not a palindrome, such as zbccba , aaccba , and abacba . Of all the ways, aaccba is the lexicographically smallest. **Example 2:** **Input:** palindrome = a **Output:** **Explanation:** There is no way to replace a single character to make a not a palindrome, so return an empty string. **Constraints:** * `1 <= palindrome.length <= 1000` * `palindrome` consists of only lowercase English letters.","completion":"def breakPalindrome(palindrome: str) -> str: length = len(palindrome) if length == 1: return \\"\\" chars = list(palindrome) for i in range(length // 2): if chars[i] != \'a\': chars[i] = \'a\' return \\"\\".join(chars) chars[length - 1] = \'b\' return \\"\\".join(chars)"},{"prompt":"You are given two positive integer arrays `nums` and `target`, of the same length. In one operation, you can choose any two **distinct** indices `i` and `j` where `0 <= i, j < nums.length` and: * set `nums[i] = nums[i] + 2` and * set `nums[j] = nums[j] 2`. Two arrays are considered to be **similar** if the frequency of each element is the same. Return _the minimum number of operations required to make_ `nums` _similar to_ `target`. The test cases are generated such that `nums` can always be similar to `target`. **Example 1:** **Input:** nums = [8,12,6], target = [2,14,10] **Output:** 2 **Explanation:** It is possible to make nums similar to target in two operations: Choose i = 0 and j = 2, nums = [10,12,4]. Choose i = 1 and j = 2, nums = [10,14,2]. It can be shown that 2 is the minimum number of operations needed. **Example 2:** **Input:** nums = [1,2,5], target = [4,1,3] **Output:** 1 **Explanation:** We can make nums similar to target in one operation: Choose i = 1 and j = 2, nums = [1,4,3]. **Example 3:** **Input:** nums = [1,1,1,1,1], target = [1,1,1,1,1] **Output:** 0 **Explanation:** The array nums is already similiar to target. **Constraints:** * `n == nums.length == target.length` * `1 <= n <= 105` * `1 <= nums[i], target[i] <= 106` * It is possible to make `nums` similar to `target`.","completion":"def minOperations(nums, target): n = len(nums) sum_nums = sum(nums) sum_target = sum(target) diff = (sum_target - sum_nums) // 2 cnt = 0 for i in range(n): if nums[i] > target[i]: cnt += (nums[i] - target[i] - diff) // 2 return cnt"},{"prompt":"Given an `n x n` binary matrix `grid`, return _the length of the shortest **clear path** in the matrix_. If there is no clear path, return `1`. A **clear path** in a binary matrix is a path from the **topleft** cell (i.e., `(0, 0)`) to the **bottomright** cell (i.e., `(n 1, n 1)`) such that: * All the visited cells of the path are `0`. * All the adjacent cells of the path are **8directionally** connected (i.e., they are different and they share an edge or a corner). The **length of a clear path** is the number of visited cells of this path. **Example 1:** **Input:** grid = [[0,1],[1,0]] **Output:** 2 **Example 2:** **Input:** grid = [[0,0,0],[1,1,0],[1,1,0]] **Output:** 4 **Example 3:** **Input:** grid = [[1,0,0],[1,1,0],[1,1,0]] **Output:** 1 **Constraints:** * `n == grid.length` * `n == grid[i].length` * `1 <= n <= 100` * `grid[i][j] is 0 or 1`","completion":"from collections import deque def shortestPathBinaryMatrix(grid): n = len(grid) if grid[0][0] or grid[n - 1][n - 1]: return -1 dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]] q = deque([(0, 0)]) grid[0][0] = 1 pathLength = 1 while q: qlen = len(q) for _ in range(qlen): x, y = q.popleft() if x == n - 1 and y == n - 1: return pathLength for d in dir: newX, newY = x + d[0], y + d[1] if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0: q.append((newX, newY)) grid[newX][newY] = 1 pathLength += 1 return -1"},{"prompt":"ercy wants to save money for his first car. He puts money in the Leetcode bank **every day**. He starts by putting in `1` on Monday, the first day. Every day from Tuesday to Sunday, he will put in `1` more than the day before. On every subsequent Monday, he will put in `1` more than the **previous Monday**. Given `n`, return _the total amount of money he will have in the Leetcode bank at the end of the_ `nth` _day._ **Example 1:** **Input:** n = 4 **Output:** 10 **Explanation:** After the 4th day, the total is 1 + 2 + 3 + 4 = 10. **Example 2:** **Input:** n = 10 **Output:** 37 **Explanation:** After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in 2. **Example 3:** **Input:** n = 20 **Output:** 96 **Explanation:** After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96. **Constraints:** * `1 <= n <= 1000`","completion":"def maxProductPath(grid): m, n, mod = len(grid), len(grid[0]), int(1e9 + 7) dp = [[[0, 0] for _ in range(n)] for _ in range(m)] dp[0][0] = [grid[0][0], grid[0][0]] for i in range(1, m): dp[i][0] = [dp[i - 1][0][0] * grid[i][0], dp[i - 1][0][0] * grid[i][0]] for j in range(1, n): dp[0][j] = [dp[0][j - 1][0] * grid[0][j], dp[0][j - 1][0] * grid[0][j]] for i in range(1, m): for j in range(1, n): if grid[i][j] < 0: dp[i][j][0] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j] dp[i][j][1] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j] else: dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) * grid[i][j] dp[i][j][1] = min(dp[i - 1][j][1], dp[i][j - 1][1]) * grid[i][j] return dp[m - 1][n - 1][0] % mod if dp[m - 1][n - 1][0] >= 0 else -1"},{"prompt":"Given a `wordlist`, we want to implement a spellchecker that converts a query word into a correct word. For a given `query` word, the spell checker handles two categories of spelling mistakes: * Capitalization: If the query matches a word in the wordlist (**caseinsensitive**), then the query word is returned with the same case as the case in the wordlist. * Example: `wordlist = [ yellow ]`, `query = YellOw `: `correct = yellow ` * Example: `wordlist = [ Yellow ]`, `query = yellow `: `correct = Yellow ` * Example: `wordlist = [ yellow ]`, `query = yellow `: `correct = yellow ` * Vowel Errors: If after replacing the vowels `(\'a\', \'e\', \'i\', \'o\', \'u\')` of the query word with any vowel individually, it matches a word in the wordlist (**caseinsensitive**), then the query word is returned with the same case as the match in the wordlist. * Example: `wordlist = [ YellOw ]`, `query = yollow `: `correct = YellOw ` * Example: `wordlist = [ YellOw ]`, `query = yeellow `: `correct = ` (no match) * Example: `wordlist = [ YellOw ]`, `query = yllw `: `correct = ` (no match) In addition, the spell checker operates under the following precedence rules: * When the query exactly matches a word in the wordlist (**casesensitive**), you should return the same word back. * When the query matches a word up to capitlization, you should return the first such match in the wordlist. * When the query matches a word up to vowel errors, you should return the first such match in the wordlist. * If the query has no matches in the wordlist, you should return the empty string. Given some `queries`, return a list of words `answer`, where `answer[i]` is the correct word for `query = queries[i]`. **Example 1:** **Input:** wordlist = [KiTe,kite,hare,Hare], queries = [kite,Kite,KiTe,Hare,HARE,Hear,hear,keti,keet,keto] **Output:** [kite,KiTe,KiTe,Hare,hare,,,KiTe,,KiTe] **Example 2:** **Input:** wordlist = [yellow], queries = [YellOw] **Output:** [yellow] **Constraints:** * `1 <= wordlist.length, queries.length <= 5000` * `1 <= wordlist[i].length, queries[i].length <= 7` * `wordlist[i]` and `queries[i]` consist only of only English letters.","completion":"def num_subarrays_with_sum(nums, goal): from collections import defaultdict prefix_sum_count = defaultdict(int) prefix_sum_count[0] = 1 cumulative_sum, result = 0, 0 for num in nums: cumulative_sum += num result += prefix_sum_count[cumulative_sum - goal] prefix_sum_count[cumulative_sum] += 1 return result"},{"prompt":"You are given a tree with `n` nodes numbered from `0` to `n 1` in the form of a parent array `parent` where `parent[i]` is the parent of `ith` node. The root of the tree is node `0`. Find the `kth` ancestor of a given node. The `kth` ancestor of a tree node is the `kth` node in the path from that node to the root node. Implement the `TreeAncestor` class: * `TreeAncestor(int n, int[] parent)` Initializes the object with the number of nodes in the tree and the parent array. * `int getKthAncestor(int node, int k)` return the `kth` ancestor of the given node `node`. If there is no such ancestor, return `1`. **Example 1:** **Input** [ TreeAncestor , getKthAncestor , getKthAncestor , getKthAncestor ] [[7, [1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]] **Output** [null, 1, 0, 1] **Explanation** TreeAncestor treeAncestor = new TreeAncestor(7, [1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3 treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5 treeAncestor.getKthAncestor(6, 3); // returns 1 because there is no such ancestor **Constraints:** * `1 <= k <= n <= 5 * 104` * `parent.length == n` * `parent[0] == 1` * `0 <= parent[i] < n` for all `0 < i < n` * `0 <= node < n` * There will be at most `5 * 104` queries.","completion":"def rank_teams(votes): teams = len(votes[0]) ranks = [[0] * teams for _ in range(26)] for vote in votes: for i in range(teams): ranks[ord(vote[i]) - ord(\'A\')][i] += 1 result = list(votes[0]) result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord(\'A\')][i] for i in range(teams)] + [ch])) return \'\'.join(result)"},{"prompt":"A train line going through a city has two routes, the regular route and the express route. Both routes go through the **same** `n + 1` stops labeled from `0` to `n`. Initially, you start on the regular route at stop `0`. You are given two **1indexed** integer arrays `regular` and `express`, both of length `n`. `regular[i]` describes the cost it takes to go from stop `i 1` to stop `i` using the regular route, and `express[i]` describes the cost it takes to go from stop `i 1` to stop `i` using the express route. You are also given an integer `expressCost` which represents the cost to transfer from the regular route to the express route. Note that: * There is no cost to transfer from the express route back to the regular route. * You pay `expressCost` **every** time you transfer from the regular route to the express route. * There is no extra cost to stay on the express route. Return _a **1indexed** array_ `costs` _of length_ `n`_, where_ `costs[i]` _is the **minimum** cost to reach stop_ `i` _from stop_ `0`. Note that a stop can be counted as **reached** from either route. **Example 1:** **Input:** regular = [1,6,9,5], express = [5,2,3,10], expressCost = 8 **Output:** [1,7,14,19] **Explanation:** The diagram above shows how to reach stop 4 from stop 0 with minimum cost. Take the regular route from stop 0 to stop 1, costing 1. Take the express route from stop 1 to stop 2, costing 8 + 2 = 10. Take the express route from stop 2 to stop 3, costing 3. Take the regular route from stop 3 to stop 4, costing 5. The total cost is 1 + 10 + 3 + 5 = 19. Note that a different route could be taken to reach the other stops with minimum cost. **Example 2:** **Input:** regular = [11,5,13], express = [7,10,6], expressCost = 3 **Output:** [10,15,24] **Explanation:** The diagram above shows how to reach stop 3 from stop 0 with minimum cost. Take the express route from stop 0 to stop 1, costing 3 + 7 = 10. Take the regular route from stop 1 to stop 2, costing 5. Take the express route from stop 2 to stop 3, costing 3 + 6 = 9. The total cost is 10 + 5 + 9 = 24. Note that the expressCost is paid again to transfer back to the express route. **Constraints:** * `n == regular.length == express.length` * `1 <= n <= 105` * `1 <= regular[i], express[i], expressCost <= 105`","completion":"def min_stop_costs(regular, express, express_cost): n = len(regular) costs = [0] * n regular_sum, express_sum = 0, express_cost for i in range(n): regular_sum += regular[i] express_sum += express[i] costs[i] = min(regular_sum, express_sum + express_cost) return costs"},{"prompt":"You are given an integer array `deck`. There is a deck of cards where every card has a unique integer. The integer on the `ith` card is `deck[i]`. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. You will do the following steps repeatedly until all cards are revealed: 1. Take the top card of the deck, reveal it, and take it out of the deck. 2. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck. 3. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return _an ordering of the deck that would reveal the cards in increasing order_. **Note** that the first entry in the answer is considered to be the top of the deck. **Example 1:** **Input:** deck = [17,13,11,2,3,5,7] **Output:** [2,13,3,11,5,17,7] **Explanation:** We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. **Example 2:** **Input:** deck = [1,1000] **Output:** [1,1000] **Constraints:** * `1 <= deck.length <= 1000` * `1 <= deck[i] <= 106` * All the values of `deck` are **unique**.","completion":"from collections import Counter from math import gcd from functools import reduce def hasGroupsSizeX(deck): counts = Counter(deck) gcd_result = reduce(gcd, counts.values()) return gcd_result > 1"},{"prompt":"Given two integers `left` and `right`, return _the **count** of numbers in the **inclusive** range_ `[left, right]` _having a **prime number of set bits** in their binary representation_. Recall that the **number of set bits** an integer has is the number of `1`\'s present when written in binary. * For example, `21` written in binary is `10101`, which has `3` set bits. **Example 1:** **Input:** left = 6, right = 10 **Output:** 4 **Explanation:** 6 > 110 (2 set bits, 2 is prime) 7 > 111 (3 set bits, 3 is prime) 8 > 1000 (1 set bit, 1 is not prime) 9 > 1001 (2 set bits, 2 is prime) 10 > 1010 (2 set bits, 2 is prime) 4 numbers have a prime number of set bits. **Example 2:** **Input:** left = 10, right = 15 **Output:** 5 **Explanation:** 10 > 1010 (2 set bits, 2 is prime) 11 > 1011 (3 set bits, 3 is prime) 12 > 1100 (2 set bits, 2 is prime) 13 > 1101 (3 set bits, 3 is prime) 14 > 1110 (3 set bits, 3 is prime) 15 > 1111 (4 set bits, 4 is not prime) 5 numbers have a prime number of set bits. **Constraints:** * `1 <= left <= right <= 106` * `0 <= right left <= 104`","completion":"def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_prime_set_bits(left: int, right: int) -> int: return sum(is_prime(bin(i).count(\'1\')) for i in range(left, right + 1))"},{"prompt":"There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.). The tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round. * For example, if the row consists of players `1, 2, 4, 6, 7` * Player `1` competes against player `7`. * Player `2` competes against player `6`. * Player `4` automatically advances to the next round. After each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order). The players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round. Given the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_. **Example 1:** **Input:** n = 11, firstPlayer = 2, secondPlayer = 4 **Output:** [3,4] **Explanation:** One possible scenario which leads to the earliest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 2, 3, 4, 5, 6, 11 Third round: 2, 3, 4 One possible scenario which leads to the latest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 1, 2, 3, 4, 5, 6 Third round: 1, 2, 4 Fourth round: 2, 4 **Example 2:** **Input:** n = 5, firstPlayer = 1, secondPlayer = 5 **Output:** [1,1] **Explanation:** The players numbered 1 and 5 compete in the first round. There is no way to make them compete in any other round. **Constraints:** * `2 <= n <= 28` * `1 <= firstPlayer < secondPlayer <= n`","completion":"def closest_cost(base_costs, topping_costs, target): closest = base_costs[0] for base in base_costs: cost = base for i in range(1 << (len(topping_costs) * 2)): bit_mask = i for j, topping_cost in enumerate(topping_costs): cost += (bit_mask & 3) * topping_cost bit_mask >>= 2 if abs(target - cost) < abs(target - closest): closest = cost elif abs(target - cost) == abs(target - closest) and cost < closest: closest = cost cost = base return closest"},{"prompt":"We have two special characters: * The first character can be represented by one bit `0`. * The second character can be represented by two bits (`10` or `11`). Given a binary array `bits` that ends with `0`, return `true` if the last character must be a onebit character. **Example 1:** **Input:** bits = [1,0,0] **Output:** true **Explanation:** The only way to decode it is twobit character and onebit character. So the last character is onebit character. **Example 2:** **Input:** bits = [1,1,1,0] **Output:** false **Explanation:** The only way to decode it is twobit character and twobit character. So the last character is not onebit character. **Constraints:** * `1 <= bits.length <= 1000` * `bits[i]` is either `0` or `1`.","completion":"def is_one_bit_character(bits): i = 0 while i < len(bits) - 1: i += bits[i] + 1 return i == len(bits) - 1"},{"prompt":"Given a url `startUrl` and an interface `HtmlParser`, implement a web crawler to crawl all links that are under the **same hostname** as `startUrl`. Return all urls obtained by your web crawler in **any** order. Your crawler should: * Start from the page: `startUrl` * Call `HtmlParser.getUrls(url)` to get all urls from a webpage of given url. * Do not crawl the same link twice. * Explore only the links that are under the **same hostname** as `startUrl`. As shown in the example url above, the hostname is `example.org`. For simplicity sake, you may assume all urls use **http protocol** without any **port** specified. For example, the urls `http://leetcode.com/problems` and `http://leetcode.com/contest` are under the same hostname, while urls `http://example.org/test` and `http://example.com/abc` are not under the same hostname. The `HtmlParser` interface is defined as such: interface HtmlParser { // Return a list of all urls from a webpage of given _url_. public List getUrls(String url); } Below are two examples explaining the functionality of the problem, for custom testing purposes you\'ll have three variables `urls`, `edges` and `startUrl`. Notice that you will only have access to `startUrl` in your code, while `urls` and `edges` are not directly accessible to you in code. Note: Consider the same URL with the trailing slash / as a different URL. For example, http://news.yahoo.com , and http://news.yahoo.com/ are different urls. **Example 1:** **Input:** urls = [ http://news.yahoo.com , http://news.yahoo.com/news , http://news.yahoo.com/news/topics/ , http://news.google.com , http://news.yahoo.com/us ] edges = [[2,0],[2,1],[3,2],[3,1],[0,4]] startUrl = http://news.yahoo.com/news/topics/ **Output:** [ http://news.yahoo.com , http://news.yahoo.com/news , http://news.yahoo.com/news/topics/ , http://news.yahoo.com/us ] **Example 2:** **Input:** urls = [ http://news.yahoo.com , http://news.yahoo.com/news , http://news.yahoo.com/news/topics/ , http://news.google.com ] edges = [[0,2],[2,1],[3,2],[3,1],[3,0]] startUrl = http://news.google.com **Output:** [ http://news.google.com ] **Explanation:** The startUrl links to all other pages that do not share the same hostname. **Constraints:** * `1 <= urls.length <= 1000` * `1 <= urls[i].length <= 300` * `startUrl` is one of the `urls`. * Hostname label must be from 1 to 63 characters long, including the dots, may contain only the ASCII letters from \'a\' to \'z\', digits from \'0\' to \'9\' and the hyphenminus character (\'\'). * The hostname may not start or end with the hyphenminus character (\'\'). * See: [https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames](https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames) * You may assume there\'re no duplicates in url library.","completion":"def tribonacci(n: int) -> int: if n == 0: return 0 if n == 1 or n == 2: return 1 a, b, c = 0, 1, 1 for _ in range(3, n + 1): a, b, c = b, c, a + b + c return c"},{"prompt":"You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths. Each video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`. We can cut these clips into segments freely. * For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`. Return _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `1`. **Example 1:** **Input:** clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10 **Output:** 3 **Explanation:** We take the clips [0,2], [8,10], [1,9]; a total of 3 clips. Then, we can reconstruct the sporting event as follows: We cut [1,9] into segments [1,2] + [2,8] + [8,9]. Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10]. **Example 2:** **Input:** clips = [[0,1],[1,2]], time = 5 **Output:** 1 **Explanation:** We cannot cover [0,5] with only [0,1] and [1,2]. **Example 3:** **Input:** clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9 **Output:** 3 **Explanation:** We can take clips [0,4], [4,7], and [6,9]. **Constraints:** * `1 <= clips.length <= 100` * `0 <= starti <= endi <= 100` * `1 <= time <= 100` 0 <= i < j < k < nums.length, and nums[i] & nums[j] & nums[k] != 0. (`&` represents the bitwise AND operation.)","completion":"def count_and_triples(nums): count = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): for k in range(j + 1, len(nums)): if nums[i] & nums[j] & nums[k] != 0: count += 1 return count"},{"prompt":"You are given two positive integers `n` and `target`. An integer is considered **beautiful** if the sum of its digits is less than or equal to `target`. Return the _minimum **nonnegative** integer_ `x` _such that_ `n + x` _is beautiful_. The input will be generated such that it is always possible to make `n` beautiful. **Example 1:** **Input:** n = 16, target = 6 **Output:** 4 **Explanation:** Initially n is 16 and its digit sum is 1 + 6 = 7. After adding 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be shown that we can not make n beautiful with adding nonnegative integer less than 4. **Example 2:** **Input:** n = 467, target = 6 **Output:** 33 **Explanation:** Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5. It can be shown that we can not make n beautiful with adding nonnegative integer less than 33. **Example 3:** **Input:** n = 1, target = 1 **Output:** 0 **Explanation:** Initially n is 1 and its digit sum is 1, which is already smaller than or equal to target. **Constraints:** * `1 <= n <= 1012` * `1 <= target <= 150` * The input will be generated such that it is always possible to make `n` beautiful.","completion":"def digit_sum(n): return sum(int(digit) for digit in str(n)) def minimum_beautiful(n, target): x = 0 while digit_sum(n + x) > target: x += 1 return x"},{"prompt":"Given an undirected tree consisting of `n` vertices numbered from `0` to `n1`, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. _Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at **vertex 0** and coming back to this vertex._ The edges of the undirected tree are given in the array `edges`, where `edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai` and `bi`. Additionally, there is a boolean array `hasApple`, where `hasApple[i] = true` means that vertex `i` has an apple; otherwise, it does not have any apple. **Example 1:** **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] **Output:** 8 **Explanation:** The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. **Example 2:** **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] **Output:** 6 **Explanation:** The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. **Example 3:** **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] **Output:** 0 **Constraints:** * `1 <= n <= 105` * `edges.length == n 1` * `edges[i].length == 2` * `0 <= ai < bi <= n 1` * `hasApple.length == n`","completion":"def minimum_distance(word: str) -> int: def dp(first: int, second: int, pos: int) -> int: if pos == len(word): return 0 ans = float(\'inf\') for i in [first, second]: if i != -1: dx = abs(ord(word[pos]) - ord(word[i])) % 6 dy = abs(ord(word[pos]) - ord(word[i])) // 6 ans = min(ans, min(dx, dy) * 2 + max(dx, dy)) ans += dp(first, second, pos + 1) if first == -1 or second == -1: ans = min(ans, dp(pos if first == -1 else first, ord(word[pos]), pos + 1)) return ans return dp(-1, -1, 0)"},{"prompt":"You are given a **sorted** array `nums` of `n` nonnegative integers and an integer `maximumBit`. You want to perform the following query `n` **times**: 1. Find a nonnegative integer `k < 2maximumBit` such that `nums[0] XOR nums[1] XOR ... XOR nums[nums.length1] XOR k` is **maximized**. `k` is the answer to the `ith` query. 2. Remove the **last** element from the current array `nums`. Return _an array_ `answer`_, where_ `answer[i]` _is the answer to the_ `ith` _query_. **Example 1:** **Input:** nums = [0,1,1,3], maximumBit = 2 **Output:** [0,3,2,3] **Explanation**: The queries are answered as follows: 1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3. 2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3. 3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3. 4th query: nums = [0], k = 3 since 0 XOR 3 = 3. **Example 2:** **Input:** nums = [2,3,4,7], maximumBit = 3 **Output:** [5,2,6,5] **Explanation**: The queries are answered as follows: 1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7. 2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7. 3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7. 4th query: nums = [2], k = 5 since 2 XOR 5 = 7. **Example 3:** **Input:** nums = [0,1,2,2,5,7], maximumBit = 3 **Output:** [4,3,6,4,6,7] **Constraints:** * `nums.length == n` * `1 <= n <= 105` * `1 <= maximumBit <= 20` * `0 <= nums[i] < 2maximumBit` * `nums`​​​ is sorted in **ascending** order.","completion":"def maximumUnits(boxTypes, truckSize): boxTypes.sort(key=lambda x: x[1], reverse=True) totalUnits = 0 for box in boxTypes: boxCount = min(truckSize, box[0]) totalUnits += boxCount * box[1] truckSize -= boxCount if truckSize == 0: break return totalUnits"},{"prompt":"Given a string `s`, return _the maximum number of unique substrings that the given string can be split into_. You can split string `s` into any list of **nonempty substrings**, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are **unique**. A **substring** is a contiguous sequence of characters within a string. **Example 1:** **Input:** s = ababccc **Output:** 5 **Explanation**: One way to split maximally is [\'a\', \'b\', \'ab\', \'c\', \'cc\']. Splitting like [\'a\', \'b\', \'a\', \'b\', \'c\', \'cc\'] is not valid as you have \'a\' and \'b\' multiple times. **Example 2:** **Input:** s = aba **Output:** 2 **Explanation**: One way to split maximally is [\'a\', \'ba\']. **Example 3:** **Input:** s = aa **Output:** 1 **Explanation**: It is impossible to split the string any further. **Constraints:** * `1 <= s.length <= 16` * `s` contains only lower case English letters.","completion":"def maxUniqueSplit(s, start=0, seen=None): if seen is None: seen = set() if start == len(s): return 0 maxUnique = -1 for i in range(start + 1, len(s) + 1): sub = s[start:i] if sub not in seen: seen.add(sub) unique = maxUniqueSplit(s, i, seen) if unique != -1: maxUnique = max(maxUnique, unique + 1) seen.remove(sub) return maxUnique"},{"prompt":"There are `n` friends that are playing a game. The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**. More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend. The rules of the game are as follows: 1. **Start** at the `1st` friend. 2. Count the next `k` friends in the clockwise direction **including** the friend you started at. The counting wraps around the circle and may count some friends more than once. 3. The last friend you counted leaves the circle and loses the game. 4. If there is still more than one friend in the circle, go back to step `2` **starting** from the friend **immediately clockwise** of the friend who just lost and repeat. 5. Else, the last friend in the circle wins the game. Given the number of friends, `n`, and an integer `k`, return _the winner of the game_. **Example 1:** **Input:** n = 5, k = 2 **Output:** 3 **Explanation:** Here are the steps of the game: 1) Start at friend 1. 2) Count 2 friends clockwise, which are friends 1 and 2. 3) Friend 2 leaves the circle. Next start is friend 3. 4) Count 2 friends clockwise, which are friends 3 and 4. 5) Friend 4 leaves the circle. Next start is friend 5. 6) Count 2 friends clockwise, which are friends 5 and 1. 7) Friend 1 leaves the circle. Next start is friend 3. 8) Count 2 friends clockwise, which are friends 3 and 5. 9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner. **Example 2:** **Input:** n = 6, k = 5 **Output:** 1 **Explanation:** The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1. **Constraints:** * `1 <= k <= n <= 500`","completion":"def halves_are_alike(s: str) -> bool: half_length = len(s) // 2 count_a, count_b = 0, 0 for i in range(half_length): if s[i] in \\"aeiouAEIOU\\": count_a += 1 for i in range(half_length, len(s)): if s[i] in \\"aeiouAEIOU\\": count_b += 1 return count_a == count_b"},{"prompt":"The **width** of a sequence is the difference between the maximum and minimum elements in the sequence. Given an array of integers `nums`, return _the sum of the **widths** of all the nonempty **subsequences** of_ `nums`. Since the answer may be very large, return it **modulo** `109 + 7`. A **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`. **Example 1:** **Input:** nums = [2,1,3] **Output:** 6 Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6. **Example 2:** **Input:** nums = [2] **Output:** 0 **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 105`","completion":"def matrixScore(grid): m, n = len(grid), len(grid[0]) for i in range(m): if grid[i][0] == 0: for j in range(n): grid[i][j] = 1 - grid[i][j] for j in range(1, n): count = sum(grid[i][j] for i in range(m)) if count <= m // 2: for i in range(m): grid[i][j] = 1 - grid[i][j] return sum(sum(grid[i][j]*(1 << (n - 1 - j)) for j in range(n)) for i in range(m))"},{"prompt":"Given a fixedlength integer array `arr`, duplicate each occurrence of zero, shifting the remaining elements to the right. **Note** that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. **Example 1:** **Input:** arr = [1,0,2,3,0,4,5,0] **Output:** [1,0,0,2,3,0,0,4] **Explanation:** After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] **Example 2:** **Input:** arr = [1,2,3] **Output:** [1,2,3] **Explanation:** After calling your function, the input array is modified to: [1,2,3] **Constraints:** * `1 <= arr.length <= 104` * `0 <= arr[i] <= 9`","completion":"def duplicateZeros(arr): n = len(arr) i = 0 while i < n - 1: if arr[i] == 0: for j in range(n - 1, i + 1, -1): arr[j] = arr[j - 1] arr[i + 1] = 0 i += 1 i += 1"},{"prompt":"There is an undirected tree with `n` nodes labeled from `0` to `n 1`. You are given the integer `n` and a 2D integer array `edges` of length `n 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. The root of the tree is the node labeled `0`. Each node has an associated **value**. You are given an array `values` of length `n`, where `values[i]` is the **value** of the `ith` node. Select any two **nonoverlapping** subtrees. Your **score** is the bitwise XOR of the sum of the values within those subtrees. Return _the_ _**maximum**_ _possible **score** you can achieve_. _If it is impossible to find two nonoverlapping subtrees_, return `0`. **Note** that: * The **subtree** of a node is the tree consisting of that node and all of its descendants. * Two subtrees are **nonoverlapping** if they do not share **any common** node. **Example 1:** **Input:** n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5] **Output:** 24 **Explanation:** Node 1\'s subtree has sum of values 16, while node 2\'s subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain. **Example 2:** **Input:** n = 3, edges = [[0,1],[1,2]], values = [4,6,1] **Output:** 0 **Explanation:** There is no possible way to select two nonoverlapping subtrees, so we just return 0. **Constraints:** * `2 <= n <= 5 * 104` * `edges.length == n 1` * `0 <= ai, bi < n` * `values.length == n` * `1 <= values[i] <= 109` * It is guaranteed that `edges` represents a valid tree.","completion":"from collections import defaultdict def maxXorSubtree(n, edges, values): tree = defaultdict(list) for edge in edges: tree[edge[0]].append(edge[1]) tree[edge[1]].append(edge[0]) first_max = [0] root_sum = dfs(0, -1, tree, values, first_max) return root_sum ^ first_max[0] def dfs(node, parent, tree, values, first_max): current_sum = values[node] for child in tree[node]: if child != parent: current_sum ^= dfs(child, node, tree, values, first_max) first_max[0] = max(first_max[0], current_sum) return current_sum"},{"prompt":"Given the array `nums`, for each `nums[i]` find out how many numbers in the array are smaller than it. That is, for each `nums[i]` you have to count the number of valid `j\'s` such that `j != i` **and** `nums[j] < nums[i]`. Return the answer in an array. **Example 1:** **Input:** nums = [8,1,2,2,3] **Output:** [4,0,1,1,3] **Explanation:** For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). For nums[1]=1 does not exist any smaller number than it. For nums[2]=2 there exist one smaller number than it (1). For nums[3]=2 there exist one smaller number than it (1). For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2). **Example 2:** **Input:** nums = [6,5,4,8] **Output:** [2,1,0,3] **Example 3:** **Input:** nums = [7,7,7,7] **Output:** [0,0,0,0] **Constraints:** * `2 <= nums.length <= 500` * `0 <= nums[i] <= 100`","completion":"def smallerNumbersThanCurrent(nums): result = [] for i in range(len(nums)): count = 0 for j in range(len(nums)): if i != j and nums[j] < nums[i]: count += 1 result.append(count) return result"},{"prompt":"You are given a **0indexed** integer array `order` of length `n`, a **permutation** of integers from `1` to `n` representing the **order** of insertion into a **binary search tree**. A binary search tree is defined as follows: * The left subtree of a node contains only nodes with keys **less than** the node\'s key. * The right subtree of a node contains only nodes with keys **greater than** the node\'s key. * Both the left and right subtrees must also be binary search trees. The binary search tree is constructed as follows: * `order[0]` will be the **root** of the binary search tree. * All subsequent elements are inserted as the **child** of **any** existing node such that the binary search tree properties hold. Return _the **depth** of the binary search tree_. A binary tree\'s **depth** is the number of **nodes** along the **longest path** from the root node down to the farthest leaf node. **Example 1:** **Input:** order = [2,1,4,3] **Output:** 3 **Explanation:** The binary search tree has a depth of 3 with path 2>3>4. **Example 2:** **Input:** order = [2,1,3,4] **Output:** 3 **Explanation:** The binary search tree has a depth of 3 with path 2>3>4. **Example 3:** **Input:** order = [1,2,3,4] **Output:** 4 **Explanation:** The binary search tree has a depth of 4 with path 1>2>3>4. **Constraints:** * `n == order.length` * `1 <= n <= 105` * `order` is a permutation of integers between `1` and `n`.","completion":"def get_collision_times(cars): n = len(cars) collisions = [-1] * n for i in range(n-1, -1, -1): time_to_collision = 1e9 for j in range(i+1, n): if cars[j][1] > cars[i][1]: continue current_collision = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]) if current_collision < time_to_collision: time_to_collision = min(time_to_collision, min(collisions[j], current_collision)) collisions[i] = -1.0 if time_to_collision == 1e9 else time_to_collision return collisions"},{"prompt":"A string is considered **beautiful** if it satisfies the following conditions: * Each of the 5 English vowels (`\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, `\'u\'`) must appear **at least once** in it. * The letters must be sorted in **alphabetical order** (i.e. all `\'a\'`s before `\'e\'`s, all `\'e\'`s before `\'i\'`s, etc.). For example, strings `aeiou ` and `aaaaaaeiiiioou ` are considered **beautiful**, but `uaeio `, `aeoiu `, and `aaaeeeooo ` are **not beautiful**. Given a string `word` consisting of English vowels, return _the **length of the longest beautiful substring** of_ `word`_. If no such substring exists, return_ `0`. A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** word = aeiaaioaaaaeiiiiouuuooaauuaeiu **Output:** 13 **Explanation:** The longest beautiful substring in word is aaaaeiiiiouuu of length 13. **Example 2:** **Input:** word = aeeeiiiioooauuuaeiou **Output:** 5 **Explanation:** The longest beautiful substring in word is aeiou of length 5. **Example 3:** **Input:** word = a **Output:** 0 **Explanation:** There is no beautiful substring, so return 0. **Constraints:** * `1 <= word.length <= 5 * 105` * `word` consists of characters `\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, and `\'u\'`.","completion":"def decode(encoded, first): arr = [first] for num in encoded: arr.append(arr[-1] ^ num) return arr"},{"prompt":"You are given an integer array `ranks` and a character array `suits`. You have `5` cards where the `ith` card has a rank of `ranks[i]` and a suit of `suits[i]`. The following are the types of **poker hands** you can make from best to worst: 1. `Flush `: Five cards of the same suit. 2. `Three of a Kind `: Three cards of the same rank. 3. `Pair `: Two cards of the same rank. 4. `High Card `: Any single card. Return _a string representing the **best** type of **poker hand** you can make with the given cards._ **Note** that the return values are **casesensitive**. **Example 1:** **Input:** ranks = [13,2,3,1,9], suits = [ a , a , a , a , a ] **Output:** Flush **Explanation:** The hand with all the cards consists of 5 cards with the same suit, so we have a Flush . **Example 2:** **Input:** ranks = [4,4,2,4,4], suits = [ d , a , a , b , c ] **Output:** Three of a Kind **Explanation:** The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a Three of a Kind . Note that we could also make a Pair hand but Three of a Kind is a better hand. Also note that other cards could be used to make the Three of a Kind hand. **Example 3:** **Input:** ranks = [10,10,2,12,9], suits = [ a , b , c , a , d ] **Output:** Pair **Explanation:** The hand with the first and second card consists of 2 cards with the same rank, so we have a Pair . Note that we cannot make a Flush or a Three of a Kind . **Constraints:** * `ranks.length == suits.length == 5` * `1 <= ranks[i] <= 13` * `\'a\' <= suits[i] <= \'d\'` * No two cards have the same rank and suit.","completion":"def best_poker_hand(ranks, suits): rank_count = {} suit_count = {} for rank, suit in zip(ranks, suits): rank_count[rank] = rank_count.get(rank, 0) + 1 suit_count[suit] = suit_count.get(suit, 0) + 1 if len(suit_count) == 1: return \\"Flush \\" if len(rank_count) == 3: return \\"Three of a Kind \\" for value in rank_count.values(): if value == 2: return \\"Pair \\" return \\"High Card \\""},{"prompt":"You are given two integer arrays `persons` and `times`. In an election, the `ith` vote was cast for `persons[i]` at time `times[i]`. For each query at a time `t`, find the person that was leading the election at time `t`. Votes cast at time `t` will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins. Implement the `TopVotedCandidate` class: * `TopVotedCandidate(int[] persons, int[] times)` Initializes the object with the `persons` and `times` arrays. * `int q(int t)` Returns the number of the person that was leading the election at time `t` according to the mentioned rules. **Example 1:** **Input** [ TopVotedCandidate , q , q , q , q , q , q ] [[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]] **Output** [null, 0, 1, 1, 0, 0, 1] **Explanation** TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]); topVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading. topVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading. topVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) topVotedCandidate.q(15); // return 0 topVotedCandidate.q(24); // return 0 topVotedCandidate.q(8); // return 1 **Constraints:** * `1 <= persons.length <= 5000` * `times.length == persons.length` * `0 <= persons[i] < persons.length` * `0 <= times[i] <= 109` * `times` is sorted in a strictly increasing order. * `times[0] <= t <= 109` * At most `104` calls will be made to `q`.","completion":"def profitableSchemes(n, minProfit, group, profit): dp = [[0] * (minProfit + 1) for _ in range(n + 1)] mod = 10**9 + 7 dp[0][0] = 1 for i in range(len(group)): for j in range(n, group[i] - 1, -1): for k in range(minProfit, -1, -1): dp[j][k] = (dp[j][k] + dp[j - group[i]][max(0, k - profit[i])]) % mod return sum(dp[i][minProfit] for i in range(1, n + 1)) % mod"},{"prompt":"is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are `n` ice cream bars. You are given an array `costs` of length `n`, where `costs[i]` is the price of the `ith` ice cream bar in coins. The boy initially has `coins` coins to spend, and he wants to buy as many ice cream bars as possible. **Note:** The boy can buy the ice cream bars in any order. Return _the **maximum** number of ice cream bars the boy can buy with_ `coins` _coins._ You must solve the problem by counting sort. **Example 1:** **Input:** costs = [1,3,2,4,1], coins = 7 **Output:** 4 **Explanation:** The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7. **Example 2:** **Input:** costs = [10,6,8,7,7,8], coins = 5 **Output:** 0 **Explanation:** The boy cannot afford any of the ice cream bars. **Example 3:** **Input:** costs = [1,6,3,1,2,5], coins = 20 **Output:** 6 **Explanation:** The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18. **Constraints:** * `costs.length == n` * `1 <= n <= 105` * `1 <= costs[i] <= 105` * `1 <= coins <= 108`","completion":"def largestAltitude(gain): max_altitude, current_altitude = 0, 0 for i in gain: current_altitude += i max_altitude = max(max_altitude, current_altitude) return max_altitude"},{"prompt":"Given a **0indexed** integer array `nums`, return `true` _if it can be made **strictly increasing** after removing **exactly one** element, or_ `false` _otherwise. If the array is already strictly increasing, return_ `true`. The array `nums` is **strictly increasing** if `nums[i 1] < nums[i]` for each index `(1 <= i < nums.length).` **Example 1:** **Input:** nums = [1,2,10,5,7] **Output:** true **Explanation:** By removing 10 at index 2 from nums, it becomes [1,2,5,7]. [1,2,5,7] is strictly increasing, so return true. **Example 2:** **Input:** nums = [2,3,1,2] **Output:** false **Explanation:** [3,1,2] is the result of removing the element at index 0. [2,1,2] is the result of removing the element at index 1. [2,3,2] is the result of removing the element at index 2. [2,3,1] is the result of removing the element at index 3. No resulting array is strictly increasing, so return false. **Example 3:** **Input:** nums = [1,1,1] **Output:** false **Explanation:** The result of removing any element is [1,1]. [1,1] is not strictly increasing, so return false. **Constraints:** * `2 <= nums.length <= 1000` * `1 <= nums[i] <= 1000`","completion":"def canBeIncreasing(nums): count = 0 for i in range(1, len(nums)): if nums[i - 1] >= nums[i]: count += 1 if count > 1: return False if i > 1 and nums[i - 2] >= nums[i] and i < len(nums) - 1 and nums[i - 1] >= nums[i + 1]: return False return True"},{"prompt":"`n` passengers board an airplane with exactly `n` seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: * Take their own seat if it is still available, and * Pick other seats randomly when they find their seat occupied Return _the probability that the_ `nth` _person gets his own seat_. **Example 1:** **Input:** n = 1 **Output:** 1.00000 **Explanation:** The first person can only get the first seat. **Example 2:** **Input:** n = 2 **Output:** 0.50000 **Explanation:** The second person has a probability of 0.5 to get the second seat (when first person gets the first seat). **Constraints:** * `1 <= n <= 105`","completion":"from collections import defaultdict def num_equiv_domino_pairs(dominoes): freq = defaultdict(int) result = 0 for domino in dominoes: key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1]) result += freq[key] freq[key] += 1 return result"},{"prompt":"Given an integer array `nums`, return _the sum of divisors of the integers in that array that have exactly four divisors_. If there is no such integer in the array, return `0`. **Example 1:** **Input:** nums = [21,4,7] **Output:** 32 **Explanation:** 21 has 4 divisors: 1, 3, 7, 21 4 has 3 divisors: 1, 2, 4 7 has 2 divisors: 1, 7 The answer is the sum of divisors of 21 only. **Example 2:** **Input:** nums = [21,21] **Output:** 64 **Example 3:** **Input:** nums = [1,2,3,4,5] **Output:** 0 **Constraints:** * `1 <= nums.length <= 104` * `1 <= nums[i] <= 105`","completion":"def sum_of_four_divisors(nums): total_sum = 0 for num in nums: count = 0 div_sum = 0 i = 1 while i * i <= num: if num % i == 0: count += 1 if i * i == num else 2 div_sum += i + (num // i) if count > 4: break i += 1 if count == 4: total_sum += div_sum return total_sum"},{"prompt":"Alice is a caretaker of `n` gardens and she wants to plant flowers to maximize the total beauty of all her gardens. You are given a **0indexed** integer array `flowers` of size `n`, where `flowers[i]` is the number of flowers already planted in the `ith` garden. Flowers that are already planted **cannot** be removed. You are then given another integer `newFlowers`, which is the **maximum** number of flowers that Alice can additionally plant. You are also given the integers `target`, `full`, and `partial`. A garden is considered **complete** if it has **at least** `target` flowers. The **total beauty** of the gardens is then determined as the **sum** of the following: * The number of **complete** gardens multiplied by `full`. * The **minimum** number of flowers in any of the **incomplete** gardens multiplied by `partial`. If there are no incomplete gardens, then this value will be `0`. Return _the **maximum** total beauty that Alice can obtain after planting at most_ `newFlowers` _flowers._ **Example 1:** **Input:** flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1 **Output:** 14 **Explanation:** Alice can plant 2 flowers in the 0th garden 3 flowers in the 1st garden 1 flower in the 2nd garden 1 flower in the 3rd garden The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers. There is 1 garden that is complete. The minimum number of flowers in the incomplete gardens is 2. Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14. No other way of planting flowers can obtain a total beauty higher than 14. **Example 2:** **Input:** flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6 **Output:** 30 **Explanation:** Alice can plant 3 flowers in the 0th garden 0 flowers in the 1st garden 0 flowers in the 2nd garden 2 flowers in the 3rd garden The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers. There are 3 gardens that are complete. The minimum number of flowers in the incomplete gardens is 4. Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30. No other way of planting flowers can obtain a total beauty higher than 30. Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty. **Constraints:** * `1 <= flowers.length <= 105` * `1 <= flowers[i], target <= 105` * `1 <= newFlowers <= 1010` * `1 <= full, partial <= 105`","completion":"def min_operations_to_K_increasing(arr, k): operations = 0 for i in range(k, len(arr)): if arr[i] <= arr[i - k]: operations += (arr[i - k] - arr[i] + 1) arr[i] = arr[i - k] + 1 return operations"},{"prompt":"You are given two positive integer arrays `nums1` and `nums2`, both of length `n`. The **absolute sum difference** of arrays `nums1` and `nums2` is defined as the **sum** of `|nums1[i] nums2[i]|` for each `0 <= i < n` (**0indexed**). You can replace **at most one** element of `nums1` with **any** other element in `nums1` to **minimize** the absolute sum difference. Return the _minimum absolute sum difference **after** replacing at most one element in the array `nums1`._ Since the answer may be large, return it **modulo** `109 + 7`. `|x|` is defined as: * `x` if `x >= 0`, or * `x` if `x < 0`. **Example 1:** **Input:** nums1 = [1,7,5], nums2 = [2,3,5] **Output:** 3 **Explanation:** There are two possible optimal solutions: Replace the second element with the first: [1,**7**,5] => [1,**1**,5], or Replace the second element with the third: [1,**7**,5] => [1,**5**,5]. Both will yield an absolute sum difference of `|12| + (|13| or |53|) + |55| =` 3. **Example 2:** **Input:** nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10] **Output:** 0 **Explanation:** nums1 is equal to nums2 so no replacement is needed. This will result in an absolute sum difference of 0. **Example 3:** **Input:** nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4] **Output:** 20 **Explanation:** Replace the first element with the second: [**1**,10,4,4,2,7] => [**10**,10,4,4,2,7]. This yields an absolute sum difference of `|109| + |103| + |45| + |41| + |27| + |74| = 20` **Constraints:** * `n == nums1.length` * `n == nums2.length` * `1 <= n <= 105` * `1 <= nums1[i], nums2[i] <= 105`","completion":"def max_points(s, x, y): points = 0 s = list(s) for i in range(1, len(s)): if s[i] == s[i - 1]: points += max(x, y) s[i] = \'#\' return points"},{"prompt":"The **beauty** of a string is the difference in frequencies between the most frequent and least frequent characters. * For example, the beauty of `abaacc ` is `3 1 = 2`. Given a string `s`, return _the sum of **beauty** of all of its substrings._ **Example 1:** **Input:** s = aabcb **Output:** 5 **Explanation:** The substrings with nonzero beauty are [ aab , aabc , aabcb , abcb , bcb ], each with beauty equal to 1. **Example 2:** **Input:** s = aabcbaa **Output:** 17 **Constraints:** * `1 <= s.length <= 500` * `s` consists of only lowercase English letters.","completion":"def arrayStringsAreEqual(word1, word2): return \\"\\".join(word1) == \\"\\".join(word2)"},{"prompt":"You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and: * There are no duplicates. * `xi < yi` Let `ways` be the number of rooted trees that satisfy the following conditions: * The tree consists of nodes whose values appeared in `pairs`. * A pair `[xi, yi]` exists in `pairs` **if and only if** `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`. * **Note:** the tree does not have to be a binary tree. Two ways are considered to be different if there is at least one node that has different parents in both ways. Return: * `0` if `ways == 0` * `1` if `ways == 1` * `2` if `ways > 1` A **rooted tree** is a tree that has a single root node, and all edges are oriented to be outgoing from the root. An **ancestor** of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors. **Example 1:** **Input:** pairs = [[1,2],[2,3]] **Output:** 1 **Explanation:** There is exactly one valid rooted tree, which is shown in the above figure. **Example 2:** **Input:** pairs = [[1,2],[2,3],[1,3]] **Output:** 2 **Explanation:** There are multiple valid rooted trees. Three of them are shown in the above figures. **Example 3:** **Input:** pairs = [[1,2],[2,3],[2,4],[1,5]] **Output:** 0 **Explanation:** There are no valid rooted trees. **Constraints:** * `1 <= pairs.length <= 105` * `1 <= xi < yi <= 500` * The elements in `pairs` are unique.","completion":"def check_ways(pairs): candidates = {} for x, y in pairs: candidates[x] = candidates.get(x, 0) + 1 candidates[y] = candidates.get(y, 0) + 1 root_count = sum(1 for v in candidates.values() if v == 1) return min(root_count, 2)"},{"prompt":"The chess knight has a **unique movement**, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an **L**). The possible movements of chess knight are shown in this diagaram: A chess knight can move as indicated in the chess diagram below: We have a chess knight and a phone pad as shown below, the knight **can only stand on a numeric cell** (i.e. blue cell). Given an integer `n`, return how many distinct phone numbers of length `n` we can dial. You are allowed to place the knight **on any numeric cell** initially and then you should perform `n 1` jumps to dial a number of length `n`. All jumps should be **valid** knight jumps. As the answer may be very large, **return the answer modulo** `109 + 7`. **Example 1:** **Input:** n = 1 **Output:** 10 **Explanation:** We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient. **Example 2:** **Input:** n = 2 **Output:** 20 **Explanation:** All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94] **Example 3:** **Input:** n = 3131 **Output:** 136006598 **Explanation:** Please take care of the mod. **Constraints:** * `1 <= n <= 5000`","completion":"def lex_smallest_string(s, k): res = s for i in range(k): tmp = s[i:] + s[:i] if tmp < res: res = tmp return res"},{"prompt":"A string `originalText` is encoded using a **slanted transposition cipher** to a string `encodedText` with the help of a matrix having a **fixed number of rows** `rows`. `originalText` is placed first in a topleft to bottomright manner. The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of `originalText`. The arrow indicates the order in which the cells are filled. All empty cells are filled with `\' \'`. The number of columns is chosen such that the rightmost column will **not be empty** after filling in `originalText`. `encodedText` is then formed by appending all characters of the matrix in a rowwise fashion. The characters in the blue cells are appended first to `encodedText`, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed. For example, if `originalText = cipher ` and `rows = 3`, then we encode it in the following manner: The blue arrows depict how `originalText` is placed in the matrix, and the red arrows denote the order in which `encodedText` is formed. In the above example, `encodedText = ch ie pr `. Given the encoded string `encodedText` and number of rows `rows`, return _the original string_ `originalText`. **Note:** `originalText` **does not** have any trailing spaces `\' \'`. The test cases are generated such that there is only one possible `originalText`. **Example 1:** **Input:** encodedText = ch ie pr , rows = 3 **Output:** cipher **Explanation:** This is the same example described in the problem description. **Example 2:** **Input:** encodedText = iveo eed l te olc , rows = 4 **Output:** i love leetcode **Explanation:** The figure above denotes the matrix that was used to encode originalText. The blue arrows show how we can find originalText from encodedText. **Example 3:** **Input:** encodedText = coding , rows = 1 **Output:** coding **Explanation:** Since there is only 1 row, both originalText and encodedText are the same. **Constraints:** * `0 <= encodedText.length <= 106` * `encodedText` consists of lowercase English letters and `\' \'` only. * `encodedText` is a valid encoding of some `originalText` that **does not** have trailing spaces. * `1 <= rows <= 1000` * The testcases are generated such that there is **only one** possible `originalText`.","completion":"def slanted_transposition_cipher(encodedText, rows): if rows == 1: return encodedText n = len(encodedText) cols = (n + rows - 2) // (rows - 1) pos = 0 matrix = [[\' \' for col in range(cols)] for row in range(rows)] for k in range(cols): for i in range(rows): if k % 2 == 0 or i != 0: matrix[i][k] = encodedText[pos] pos += 1 originalText = \'\'.join(\'\'.join(row) for row in matrix) return originalText"},{"prompt":"You have an undirected, connected graph of `n` nodes labeled from `0` to `n 1`. You are given an array `graph` where `graph[i]` is a list of all the nodes connected with node `i` by an edge. Return _the length of the shortest path that visits every node_. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges. **Example 1:** **Input:** graph = [[1,2,3],[0],[0],[0]] **Output:** 4 **Explanation:** One possible path is [1,0,2,0,3] **Example 2:** **Input:** graph = [[1],[0,2,4],[1,3,4],[2],[1,2]] **Output:** 4 **Explanation:** One possible path is [0,1,4,2,3] **Constraints:** * `n == graph.length` * `1 <= n <= 12` * `0 <= graph[i].length < n` * `graph[i]` does not contain `i`. * If `graph[a]` contains `b`, then `graph[b]` contains `a`. * The input graph is always connected.","completion":"from collections import deque def shortestPathLength(graph): n = len(graph) queue = deque([(i, 1 << i, 0) for i in range(n)]) visited = [[False] * (1 << n) for _ in range(n)] for i in range(n): visited[i][1 << i] = True while queue: node, bitmask, length = queue.popleft() if bitmask == (1 << n) - 1: return length for nei in graph[node]: next_bitmask = bitmask | (1 << nei) if not visited[nei][next_bitmask]: visited[nei][next_bitmask] = True queue.append((nei, next_bitmask, length + 1)) return 0"},{"prompt":"You are given a binary array `nums` and an integer `k`. A **kbit flip** is choosing a **subarray** of length `k` from `nums` and simultaneously changing every `0` in the subarray to `1`, and every `1` in the subarray to `0`. Return _the minimum number of **kbit flips** required so that there is no_ `0` _in the array_. If it is not possible, return `1`. A **subarray** is a **contiguous** part of an array. **Example 1:** **Input:** nums = [0,1,0], k = 1 **Output:** 2 **Explanation:** Flip nums[0], then flip nums[2]. **Example 2:** **Input:** nums = [1,1,0], k = 2 **Output:** 1 **Explanation:** No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1]. **Example 3:** **Input:** nums = [0,0,0,1,0,1,1,0], k = 3 **Output:** 3 **Explanation:** Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0] Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0] Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1] **Constraints:** * `1 <= nums.length <= 105` * `1 <= k <= nums.length`","completion":"def min_k_bit_flips(nums, k): n = len(nums) flipped = [0] * n flips = ans = 0 for i in range(n): if i >= k: flips -= flipped[i - k] if (flips + nums[i]) % 2 == 0: if i + k > n: return -1 flipped[i] = 1 flips += 1 ans += 1 return ans"},{"prompt":"You are given a binary array `nums` containing only the integers `0` and `1`. Return _the number of **subarrays** in nums that have **more**_ `1`\'_s than_ `0`_\'s. Since the answer may be very large, return it **modulo**_ `109 + 7`. A **subarray** is a contiguous sequence of elements within an array. **Example 1:** **Input:** nums = [0,1,1,0,1] **Output:** 9 **Explanation:** The subarrays of size 1 that have more ones than zeros are: [1], [1], [1] The subarrays of size 2 that have more ones than zeros are: [1,1] The subarrays of size 3 that have more ones than zeros are: [0,1,1], [1,1,0], [1,0,1] The subarrays of size 4 that have more ones than zeros are: [1,1,0,1] The subarrays of size 5 that have more ones than zeros are: [0,1,1,0,1] **Example 2:** **Input:** nums = [0] **Output:** 0 **Explanation:** No subarrays have more ones than zeros. **Example 3:** **Input:** nums = [1] **Output:** 1 **Explanation:** The subarrays of size 1 that have more ones than zeros are: [1] **Constraints:** * `1 <= nums.length <= 105` * `0 <= nums[i] <= 1`","completion":"def min_moves(n): dp = [0, 1] + [0] * (n - 1) for i in range(2, n + 1): dp[i] = i for x in range(1, i): broken = x - 1 unbroken = i - x dp[i] = min(dp[i], 1 + max(dp[broken], dp[unbroken])) return dp[n]"},{"prompt":"You have some coins. The `i`th coin has a probability `prob[i]` of facing heads when tossed. Return the probability that the number of coins facing heads equals `target` if you toss every coin exactly once. **Example 1:** **Input:** prob = [0.4], target = 1 **Output:** 0.40000 **Example 2:** **Input:** prob = [0.5,0.5,0.5,0.5,0.5], target = 0 **Output:** 0.03125 **Constraints:** * `1 <= prob.length <= 1000` * `0 <= prob[i] <= 1` * `0 <= target` `<= prob.length` * Answers will be accepted as correct if they are within `10^5` of the correct answer.","completion":"def max_value(arr1, arr2): n = len(arr1) max1 = max2 = max3 = max4 = float(\'-inf\') min1 = min2 = min3 = min4 = float(\'inf\') for i in range(n): max1 = max(max1, arr1[i] - arr2[i] + i) max2 = max(max2, arr1[i] + arr2[i] + i) max3 = max(max3, -arr1[i] + arr2[i] + i) max4 = max(max4, -arr1[i] - arr2[i] + i) min1 = min(min1, arr1[i] - arr2[i] + i) min2 = min(min2, arr1[i] + arr2[i] + i) min3 = min(min3, -arr1[i] + arr2[i] + i) min4 = min(min4, -arr1[i] - arr2[i] + i) return max(max1 - min1, max2 - min2, max3 - min3, max4 - min4)"},{"prompt":"Given an integer array `arr`, and an integer `target`, return the number of tuples `i, j, k` such that `i < j < k` and `arr[i] + arr[j] + arr[k] == target`. As the answer can be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** arr = [1,1,2,2,3,3,4,4,5,5], target = 8 **Output:** 20 **Explanation:** Enumerating by the values (arr[i], arr[j], arr[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times. **Example 2:** **Input:** arr = [1,1,2,2,2,2], target = 5 **Output:** 12 **Explanation:** arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways. **Example 3:** **Input:** arr = [2,1,3], target = 6 **Output:** 1 **Explanation:** (1, 2, 3) occured one time in the array so we return 1. **Constraints:** * `3 <= arr.length <= 3000` * `0 <= arr[i] <= 100` * `0 <= target <= 300`","completion":"def min_moves(k, n): if k == 1 or n == 0 or n == 1: return n res = float(\'inf\') for i in range(1, n + 1): temp = max(min_moves(k - 1, i - 1), min_moves(k, n - i)) res = min(res, temp) return res + 1"},{"prompt":"Given an equation, represented by `words` on the left side and the `result` on the right side. You need to check if the equation is solvable under the following rules: * Each character is decoded as one digit (0 9). * No two characters can map to the same digit. * Each `words[i]` and `result` are decoded as one number **without** leading zeros. * Sum of numbers on the left side (`words`) will equal to the number on the right side (`result`). Return `true` _if the equation is solvable, otherwise return_ `false`. **Example 1:** **Input:** words = [ SEND , MORE ], result = MONEY **Output:** true **Explanation:** Map \'S\'> 9, \'E\'>5, \'N\'>6, \'D\'>7, \'M\'>1, \'O\'>0, \'R\'>8, \'Y\'>\'2\' Such that: SEND + MORE = MONEY , 9567 + 1085 = 10652 **Example 2:** **Input:** words = [ SIX , SEVEN , SEVEN ], result = TWENTY **Output:** true **Explanation:** Map \'S\'> 6, \'I\'>5, \'X\'>0, \'E\'>8, \'V\'>7, \'N\'>2, \'T\'>1, \'W\'>\'3\', \'Y\'>4 Such that: SIX + SEVEN + SEVEN = TWENTY , 650 + 68782 + 68782 = 138214 **Example 3:** **Input:** words = [ LEET , CODE ], result = POINT **Output:** false **Explanation:** There is no possible mapping to satisfy the equation, so we return false. Note that two different characters cannot map to the same digit. **Constraints:** * `2 <= words.length <= 5` * `1 <= words[i].length, result.length <= 7` * `words[i], result` contain only uppercase English letters. * The number of different characters used in the expression is at most `10`.","completion":"def nthUglyNumber(n, a, b, c): from math import gcd ab = a * b // gcd(a, b) ac = a * c // gcd(a, c) bc = b * c // gcd(b, c) abc = a * bc // gcd(a, bc) left, right = 0, 2 * 10**9 while left < right: mid = left + (right - left) // 2 cnt = mid // a + mid // b + mid // c - mid // ab - mid // ac - mid // bc + mid // abc if cnt < n: left = mid + 1 else: right = mid return left"},{"prompt":"Given an array of positive integers `nums`, remove the **smallest** subarray (possibly **empty**) such that the **sum** of the remaining elements is divisible by `p`. It is **not** allowed to remove the whole array. Return _the length of the smallest subarray that you need to remove, or_ `1` _if it\'s impossible_. A **subarray** is defined as a contiguous block of elements in the array. **Example 1:** **Input:** nums = [3,1,4,2], p = 6 **Output:** 1 **Explanation:** The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6. **Example 2:** **Input:** nums = [6,3,5,2], p = 9 **Output:** 2 **Explanation:** We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9. **Example 3:** **Input:** nums = [1,2,3], p = 3 **Output:** 0 **Explanation:** Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109` * `1 <= p <= 109`","completion":"def minSubarray(nums, p): n, res, need, cur = len(nums), len(nums), 0, 0 for num in nums: need = (need + num) % p if need == 0: return 0 last_seen = {0: -1} for i, num in enumerate(nums): cur = (cur + num) % p last_seen[cur] = i res = min(res, i - last_seen.get((cur - need + p) % p, -n)) return res if res < n else -1"},{"prompt":"Given three integers `x`, `y`, and `bound`, return _a list of all the **powerful integers** that have a value less than or equal to_ `bound`. An integer is **powerful** if it can be represented as `xi + yj` for some integers `i >= 0` and `j >= 0`. You may return the answer in **any order**. In your answer, each value should occur **at most once**. **Example 1:** **Input:** x = 2, y = 3, bound = 10 **Output:** [2,3,4,5,7,9,10] **Explanation:** 2 = 20 + 30 3 = 21 + 30 4 = 20 + 31 5 = 21 + 31 7 = 22 + 31 9 = 23 + 30 10 = 20 + 32 **Example 2:** **Input:** x = 3, y = 5, bound = 15 **Output:** [2,4,6,8,10,14] **Constraints:** * `1 <= x, y <= 100` * `0 <= bound <= 106`","completion":"def powerfulIntegers(x, y, bound): max_i = 0 if x == 1 else int(math.log(bound, x)) max_j = 0 if y == 1 else int(math.log(bound, y)) result_set = set() for i in range(max_i + 1): for j in range(max_j + 1): powerful_num = x ** i + y ** j if powerful_num <= bound: result_set.add(powerful_num) return list(result_set)"},{"prompt":"You are given a **0indexed** integer array `books` of length `n` where `books[i]` denotes the number of books on the `ith` shelf of a bookshelf. You are going to take books from a **contiguous** section of the bookshelf spanning from `l` to `r` where `0 <= l <= r < n`. For each index `i` in the range `l <= i < r`, you must take **strictly fewer** books from shelf `i` than shelf `i + 1`. Return _the **maximum** number of books you can take from the bookshelf._ **Example 1:** **Input:** books = [8,5,2,7,9] **Output:** 19 **Explanation:** Take 1 book from shelf 1. Take 2 books from shelf 2. Take 7 books from shelf 3. Take 9 books from shelf 4. You have taken 19 books, so return 19. It can be proven that 19 is the maximum number of books you can take. **Example 2:** **Input:** books = [7,0,3,4,5] **Output:** 12 **Explanation:** Take 3 books from shelf 2. Take 4 books from shelf 3. Take 5 books from shelf 4. You have taken 12 books so return 12. It can be proven that 12 is the maximum number of books you can take. **Example 3:** **Input:** books = [8,2,3,7,3,4,0,1,4,3] **Output:** 13 **Explanation:** Take 1 book from shelf 0. Take 2 books from shelf 1. Take 3 books from shelf 2. Take 7 books from shelf 3. You have taken 13 books so return 13. It can be proven that 13 is the maximum number of books you can take. **Constraints:** * `1 <= books.length <= 105` * `0 <= books[i] <= 105`","completion":"def max_books(books): n = len(books) max_books = 0 for l in range(n): r = l + 1 books_taken = books[l] min_taken = books[l] max_books = max(max_books, books_taken) while r < n: min_taken = min(min_taken, books[r]) books_taken += min_taken max_books = max(max_books, books_taken) if min_taken <= 1: break # Can\'t decrease further r += 1 return max_books"},{"prompt":"There are `m` boys and `n` girls in a class attending an upcoming party. You are given an `m x n` integer matrix `grid`, where `grid[i][j]` equals `0` or `1`. If `grid[i][j] == 1`, then that means the `ith` boy can invite the `jth` girl to the party. A boy can invite at most **one girl**, and a girl can accept at most **one invitation** from a boy. Return _the **maximum** possible number of accepted invitations._ **Example 1:** **Input:** grid = [[1,1,1], [1,0,1], [0,0,1]] **Output:** 3 **Explanation:** The invitations are sent as follows: The 1st boy invites the 2nd girl. The 2nd boy invites the 1st girl. The 3rd boy invites the 3rd girl. **Example 2:** **Input:** grid = [[1,0,1,0], [1,0,0,0], [0,0,1,0], [1,1,1,0]] **Output:** 3 **Explanation:** The invitations are sent as follows: The 1st boy invites the 3rd girl. The 2nd boy invites the 1st girl. The 3rd boy invites no one. The 4th boy invites the 2nd girl. **Constraints:** * `grid.length == m` * `grid[i].length == n` * `1 <= m, n <= 200` * `grid[i][j]` is either `0` or `1`.","completion":"def count_trees(pairs): nodes = len(pairs) + 1 in_degrees = [0] * nodes for x, y in pairs: in_degrees[y] += 1 res = 1 for in_degree in in_degrees[1:]: res *= in_degree return res"},{"prompt":"Design a system that manages the reservation state of `n` seats that are numbered from `1` to `n`. Implement the `SeatManager` class: * `SeatManager(int n)` Initializes a `SeatManager` object that will manage `n` seats numbered from `1` to `n`. All seats are initially available. * `int reserve()` Fetches the **smallestnumbered** unreserved seat, reserves it, and returns its number. * `void unreserve(int seatNumber)` Unreserves the seat with the given `seatNumber`. **Example 1:** **Input** [ SeatManager , reserve , reserve , unreserve , reserve , reserve , reserve , reserve , unreserve ] [[5], [], [], [2], [], [], [], [], [5]] **Output** [null, 1, 2, null, 2, 3, 4, 5, null] **Explanation** SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats. seatManager.reserve(); // All seats are available, so return the lowest numbered seat, which is 1. seatManager.reserve(); // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5]. seatManager.reserve(); // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.reserve(); // The available seats are [3,4,5], so return the lowest of them, which is 3. seatManager.reserve(); // The available seats are [4,5], so return the lowest of them, which is 4. seatManager.reserve(); // The only available seat is seat 5, so return 5. seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5]. **Constraints:** * `1 <= n <= 105` * `1 <= seatNumber <= n` * For each call to `reserve`, it is guaranteed that there will be at least one unreserved seat. * For each call to `unreserve`, it is guaranteed that `seatNumber` will be reserved. * At most `105` calls **in total** will be made to `reserve` and `unreserve`.","completion":"def largestSubmatrix(matrix): m, n = len(matrix), len(matrix[0]) height = [0] * n max_area = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: height[j] += 1 else: height[j] = 0 sorted_height = sorted(height) for j in range(n): max_area = max(max_area, sorted_height[j] * (n - j)) return max_area"},{"prompt":"A **sentence** is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters. A sentence can be **shuffled** by appending the **1indexed word position** to each word then rearranging the words in the sentence. * For example, the sentence `This is a sentence ` can be shuffled as `sentence4 a3 is2 This1 ` or `is2 sentence4 This1 a3 `. Given a **shuffled sentence** `s` containing no more than `9` words, reconstruct and return _the original sentence_. **Example 1:** **Input:** s = is2 sentence4 This1 a3 **Output:** This is a sentence **Explanation:** Sort the words in s to their original positions This1 is2 a3 sentence4 , then remove the numbers. **Example 2:** **Input:** s = Myself2 Me1 I4 and3 **Output:** Me Myself and I **Explanation:** Sort the words in s to their original positions Me1 Myself2 and3 I4 , then remove the numbers. **Constraints:** * `2 <= s.length <= 200` * `s` consists of lowercase and uppercase English letters, spaces, and digits from `1` to `9`. * The number of words in `s` is between `1` and `9`. * The words in `s` are separated by a single space. * `s` contains no leading or trailing spaces. 1. All characters in a are strictly less than those in b (i.e., a[i] < b[i] for all i). 2. All characters in b are strictly less than those in a (i.e., a[i] > b[i] for all i). 3. All characters in a and b are the same (i.e., a[i] = b[i] for all i).","completion":"def min_operations_to_satisfy_conditions(a: str, b: str) -> int: same, less, greater = 0, 0, 0 for i in range(len(a)): if a[i] == b[i]: same += 1 elif a[i] < b[i]: less += 1 else: greater += 1 return min(same + max(less, greater), less, greater)"},{"prompt":"You are given an array of equallength strings `words`. Assume that the length of each string is `n`. Each string `words[i]` can be converted into a **difference integer array** `difference[i]` of length `n 1` where `difference[i][j] = words[i][j+1] words[i][j]` where `0 <= j <= n 2`. Note that the difference between two letters is the difference between their **positions** in the alphabet i.e. the position of `\'a\'` is `0`, `\'b\'` is `1`, and `\'z\'` is `25`. * For example, for the string `acb `, the difference integer array is `[2 0, 1 2] = [2, 1]`. All the strings in words have the same difference integer array, **except one**. You should find that string. Return _the string in_ `words` _that has different **difference integer array**._ **Example 1:** **Input:** words = [ adc , wzy , abc ] **Output:** abc **Explanation:** The difference integer array of adc is [3 0, 2 3] = [3, 1]. The difference integer array of wzy is [25 22, 24 25]= [3, 1]. The difference integer array of abc is [1 0, 2 1] = [1, 1]. The odd array out is [1, 1], so we return the corresponding string, abc . **Example 2:** **Input:** words = [ aaa , bob , ccc , ddd ] **Output:** bob **Explanation:** All the integer arrays are [0, 0] except for bob , which corresponds to [13, 13]. **Constraints:** * `3 <= words.length <= 100` * `n == words[i].length` * `2 <= n <= 20` * `words[i]` consists of lowercase English letters.","completion":"def stringWithDifferentDifference(words): def get_difference_array(word): return [ord(word[i+1]) - ord(word[i]) for i in range(len(word) - 1)] diffArrays = [get_difference_array(word) for word in words] oddArrayIndex = -1 for i in range(1, len(diffArrays)): matchCount = sum(diffArrays[0][j] == diffArrays[i][j] for j in range(len(diffArrays[i]))) if matchCount == 0: oddArrayIndex = i break return words[oddArrayIndex]"},{"prompt":"A string `s` is called **good** if there are no two different characters in `s` that have the same **frequency**. Given a string `s`, return _the **minimum** number of characters you need to delete to make_ `s` _**good**._ The **frequency** of a character in a string is the number of times it appears in the string. For example, in the string `aab `, the **frequency** of `\'a\'` is `2`, while the **frequency** of `\'b\'` is `1`. **Example 1:** **Input:** s = aab **Output:** 0 **Explanation:** `s` is already good. **Example 2:** **Input:** s = aaabbbcc **Output:** 2 **Explanation:** You can delete two \'b\'s resulting in the good string aaabcc . Another way it to delete one \'b\' and one \'c\' resulting in the good string aaabbc . **Example 3:** **Input:** s = ceabaacb **Output:** 2 **Explanation:** You can delete both \'c\'s resulting in the good string eabaab . Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored). **Constraints:** * `1 <= s.length <= 105` * `s` contains only lowercase English letters.","completion":"def can_convert(s, t, k): diff = 0 for i in range(len(s)): curr_diff = (ord(t[i]) - ord(s[i]) + 26) % 26 if curr_diff > 0: diff += curr_diff k -= curr_diff return k >= 0 and k >= diff - len(s) and k % 26 == 0"},{"prompt":"You are given two **0indexed** arrays `nums1` and `nums2` of length `n`, both of which are **permutations** of `[0, 1, ..., n 1]`. A **good triplet** is a set of `3` **distinct** values which are present in **increasing order** by position both in `nums1` and `nums2`. In other words, if we consider `pos1v` as the index of the value `v` in `nums1` and `pos2v` as the index of the value `v` in `nums2`, then a good triplet will be a set `(x, y, z)` where `0 <= x, y, z <= n 1`, such that `pos1x < pos1y < pos1z` and `pos2x < pos2y < pos2z`. Return _the **total number** of good triplets_. **Example 1:** **Input:** nums1 = [2,0,1,3], nums2 = [0,1,2,3] **Output:** 1 **Explanation:** There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). Out of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet. **Example 2:** **Input:** nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3] **Output:** 4 **Explanation:** The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2). **Constraints:** * `n == nums1.length == nums2.length` * `3 <= n <= 105` * `0 <= nums1[i], nums2[i] <= n 1` * `nums1` and `nums2` are permutations of `[0, 1, ..., n 1]`.","completion":"def max_beauty(items, queries): sorted_items = [0] * 10001 for price, beauty in items: sorted_items[price] = max(sorted_items[price], beauty) for i in range(1, len(sorted_items)): sorted_items[i] = max(sorted_items[i], sorted_items[i - 1]) return [sorted_items[query] for query in queries]"},{"prompt":"Given an array of digits `digits`, return _the largest multiple of **three** that can be formed by concatenating some of the given digits in **any order**_. If there is no answer return an empty string. Since the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros. **Example 1:** **Input:** digits = [8,1,9] **Output:** 981 **Example 2:** **Input:** digits = [8,6,7,1,0] **Output:** 8760 **Example 3:** **Input:** digits = [1] **Output:** **Constraints:** * `1 <= digits.length <= 104` * `0 <= digits[i] <= 9`","completion":"from collections import defaultdict def largest_multiple_of_three(digits): digits.sort(reverse=True) sum_digits = sum(digits) if sum_digits % 3 == 0: return \'0\' if digits[-1] == 0 else \'\'.join(map(str, digits)) mod = defaultdict(list) for digit in digits: mod[digit % 3].append(digit) if sum_digits % 3 == 1: if mod[1]: mod[1].pop() else: mod[2].pop(), mod[2].pop() else: if mod[2]: mod[2].pop() else: mod[1].pop(), mod[1].pop() result = \\"\\".join(str(digit) for value in mod.values() for digit in value) result = \\"\\".join(sorted(result, reverse=True)) return \'0\' if not result or result[0] == \'0\' else result"},{"prompt":"You are given a **0indexed** integer array `nums` containing **distinct** numbers, an integer `start`, and an integer `goal`. There is an integer `x` that is initially set to `start`, and you want to perform operations on `x` such that it is converted to `goal`. You can perform the following operation repeatedly on the number `x`: If `0 <= x <= 1000`, then for any index `i` in the array (`0 <= i < nums.length`), you can set `x` to any of the following: * `x + nums[i]` * `x nums[i]` * `x ^ nums[i]` (bitwiseXOR) Note that you can use each `nums[i]` any number of times in any order. Operations that set `x` to be out of the range `0 <= x <= 1000` are valid, but no more operations can be done afterward. Return _the **minimum** number of operations needed to convert_ `x = start` _into_ `goal`_, and_ `1` _if it is not possible_. **Example 1:** **Input:** nums = [2,4,12], start = 2, goal = 12 **Output:** 2 **Explanation:** We can go from 2 > 14 > 12 with the following 2 operations. 2 + 12 = 14 14 2 = 12 **Example 2:** **Input:** nums = [3,5,7], start = 0, goal = 4 **Output:** 2 **Explanation:** We can go from 0 > 3 > 4 with the following 2 operations. 0 + 3 = 3 3 7 = 4 Note that the last operation sets x out of the range 0 <= x <= 1000, which is valid. **Example 3:** **Input:** nums = [2,8,16], start = 0, goal = 1 **Output:** 1 **Explanation:** There is no way to convert 0 into 1. **Constraints:** * `1 <= nums.length <= 1000` * `109 <= nums[i], goal <= 109` * `0 <= start <= 1000` * `start != goal` * All the integers in `nums` are distinct.","completion":"def count_three_char_palindromes(s): count = 0 freq = {} for ch in s: if ch in freq: freq[ch] += 1 else: freq[ch] = 1 for value in freq.values(): count += value * (value - 1) // 2 return count"},{"prompt":"This question is about implementing a basic elimination algorithm for Candy Crush. Given an `m x n` integer array `board` representing the grid of candy where `board[i][j]` represents the type of candy. A value of `board[i][j] == 0` represents that the cell is empty. The given board represents the state of the game following the player\'s move. Now, you need to restore the board to a stable state by crushing candies according to the following rules: * If three or more candies of the same type are adjacent vertically or horizontally, crush them all at the same time these positions become empty. * After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. No new candies will drop outside the top boundary. * After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps. * If there does not exist more candies that can be crushed (i.e., the board is stable), then return the current board. You need to perform the above rules until the board becomes stable, then return _the stable board_. **Example 1:** **Input:** board = [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]] **Output:** [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]] **Example 2:** **Input:** board = [[1,3,5,5,2],[3,4,3,3,1],[3,2,4,5,2],[2,4,4,5,5],[1,4,4,1,1]] **Output:** [[1,3,0,0,0],[3,4,0,5,2],[3,2,0,3,1],[2,4,0,5,2],[1,4,3,1,1]] **Constraints:** * `m == board.length` * `n == board[i].length` * `3 <= m, n <= 50` * `1 <= board[i][j] <= 2000`","completion":"def candyCrush(board): rows = len(board) cols = len(board[0]) toDo = False for r in range(rows): for c in range(cols - 2): val = abs(board[r][c]) if val and val == abs(board[r][c + 1]) and val == abs(board[r][c + 2]): board[r][c] = board[r][c + 1] = board[r][c + 2] = -val toDo = True for r in range(rows - 2): for c in range(cols): val = abs(board[r][c]) if val and val == abs(board[r + 1][c]) and val == abs(board[r + 2][c]): board[r][c] = board[r + 1][c] = board[r + 2][c] = -val toDo = True for c in range(cols): wr = rows - 1 for r in range(rows - 1, -1, -1): if board[r][c] > 0: board[wr][c] = board[r][c] wr -= 1 for r in range(wr, -1, -1): board[r][c] = 0 return candyCrush(board) if toDo else board"},{"prompt":"You have `n` binary tree nodes numbered from `0` to `n 1` where node `i` has two children `leftChild[i]` and `rightChild[i]`, return `true` if and only if **all** the given nodes form **exactly one** valid binary tree. If node `i` has no left child then `leftChild[i]` will equal `1`, similarly for the right child. Note that the nodes have no values and that we only use the node numbers in this problem. **Example 1:** **Input:** n = 4, leftChild = [1,1,3,1], rightChild = [2,1,1,1] **Output:** true **Example 2:** **Input:** n = 4, leftChild = [1,1,3,1], rightChild = [2,3,1,1] **Output:** false **Example 3:** **Input:** n = 2, leftChild = [1,0], rightChild = [1,1] **Output:** false **Constraints:** * `n == leftChild.length == rightChild.length` * `1 <= n <= 104` * `1 <= leftChild[i], rightChild[i] <= n 1`","completion":"def tilingRectangle(n, m): if n > m: n, m = m, n if n == 1: return m if n == m: return 1 res = float(\'inf\') for a in range(1, n // 2 + 1): res = min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m)) for b in range(1, m // 2 + 1): res = min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b)) return res"},{"prompt":"A cell `(r, c)` of an excel sheet is represented as a string ` ` where: * denotes the column number `c` of the cell. It is represented by **alphabetical letters**. * For example, the `1st` column is denoted by `\'A\'`, the `2nd` by `\'B\'`, the `3rd` by `\'C\'`, and so on. * is the row number `r` of the cell. The `rth` row is represented by the **integer** `r`. You are given a string `s` in the format `: `, where represents the column `c1`, represents the row `r1`, represents the column `c2`, and represents the row `r2`, such that `r1 <= r2` and `c1 <= c2`. Return _the **list of cells**_ `(x, y)` _such that_ `r1 <= x <= r2` _and_ `c1 <= y <= c2`. The cells should be represented as **strings** in the format mentioned above and be sorted in **nondecreasing** order first by columns and then by rows. **Example 1:** **Input:** s = K1:L2 **Output:** [ K1 , K2 , L1 , L2 ] **Explanation:** The above diagram shows the cells which should be present in the list. The red arrows denote the order in which the cells should be presented. **Example 2:** **Input:** s = A1:F1 **Output:** [ A1 , B1 , C1 , D1 , E1 , F1 ] **Explanation:** The above diagram shows the cells which should be present in the list. The red arrow denotes the order in which the cells should be presented. **Constraints:** * `s.length == 5` * `\'A\' <= s[0] <= s[3] <= \'Z\'` * `\'1\' <= s[1] <= s[4] <= \'9\'` * `s` consists of uppercase English letters, digits and `\':\'`.","completion":"def cell_range(s): r1 = int(s[1]) r2 = int(s[4]) c1 = ord(s[0]) - ord(\'A\') + 1 c2 = ord(s[3]) - ord(\'A\') + 1 res = [] for c in range(c1, c2 + 1): for r in range(r1, r2 + 1): res.append(chr(ord(\'A\') + c - 1) + str(r)) return res"},{"prompt":"There are `n` people, each person has a unique _id_ between `0` and `n1`. Given the arrays `watchedVideos` and `friends`, where `watchedVideos[i]` and `friends[i]` contain the list of watched videos and the list of friends respectively for the person with `id = i`. Level **1** of videos are all watched videos by your friends, level **2** of videos are all watched videos by the friends of your friends and so on. In general, the level `k` of videos are all watched videos by people with the shortest path **exactly** equal to `k` with you. Given your `id` and the `level` of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest. **Example 1:** **Input:** watchedVideos = [[ A , B ],[ C ],[ B , C ],[ D ]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1 **Output:** [ B , C ] **Explanation:** You have id = 0 (green color in the figure) and your friends are (yellow color in the figure): Person with id = 1 > watchedVideos = [ C ] Person with id = 2 > watchedVideos = [ B , C ] The frequencies of watchedVideos by your friends are: B > 1 C > 2 **Example 2:** **Input:** watchedVideos = [[ A , B ],[ C ],[ B , C ],[ D ]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2 **Output:** [ D ] **Explanation:** You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure). **Constraints:** * `n == watchedVideos.length == friends.length` * `2 <= n <= 100` * `1 <= watchedVideos[i].length <= 100` * `1 <= watchedVideos[i][j].length <= 8` * `0 <= friends[i].length < n` * `0 <= friends[i][j] < n` * `0 <= id < n` * `1 <= level < n` * if `friends[i]` contains `j`, then `friends[j]` contains `i`","completion":"def largestMagicSquare(grid): m, n = len(grid), len(grid[0]) row = [[0] * (n + 1) for _ in range(m)] col = [[0] * n for _ in range(m + 1)] for i in range(m): for j in range(n): row[i][j + 1] = row[i][j] + grid[i][j] col[i + 1][j] = col[i][j] + grid[i][j] for k in reversed(range(2, min(m, n) + 1)): for i in range(m - k + 1): for j in range(n - k + 1): _sum = row[i][j + k] - row[i][j] ok = all(row[i + t][j + k] - row[i + t][j] == _sum for t in range(1, k)) and all( col[i + k][j + t] - col[i][j + t] == _sum for t in range(1, k)) if not ok: continue diag1 = sum(grid[i + t][j + t] for t in range(k)) diag2 = sum(grid[i + t][j + k - 1 - t] for t in range(k)) if diag1 == _sum and diag2 == _sum: return k return 1"},{"prompt":"There are `n` computers numbered from `0` to `n 1` connected by ethernet cables `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between computers `ai` and `bi`. Any computer can reach any other computer directly or indirectly through the network. You are given an initial computer network `connections`. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return _the minimum number of times you need to do this in order to make all the computers connected_. If it is not possible, return `1`. **Example 1:** **Input:** n = 4, connections = [[0,1],[0,2],[1,2]] **Output:** 1 **Explanation:** Remove cable between computer 1 and 2 and place between computers 1 and 3. **Example 2:** **Input:** n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] **Output:** 2 **Example 3:** **Input:** n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] **Output:** 1 **Explanation:** There are not enough cables. **Constraints:** * `1 <= n <= 105` * `1 <= connections.length <= min(n * (n 1) / 2, 105)` * `connections[i].length == 2` * `0 <= ai, bi < n` * `ai != bi` * There are no repeated connections. * No two computers are connected by more than one cable.","completion":"def unique_occurrences(arr): counts = {} for num in arr: counts[num] = counts.get(num, 0) + 1 unique_counts = set() for count in counts.values(): if count in unique_counts: return False unique_counts.add(count) return True"},{"prompt":"Given a string `word`, return _the **sum of the number of vowels** (_`\'a\'`, `\'e\'`_,_ `\'i\'`_,_ `\'o\'`_, and_ `\'u\'`_)_ _in every substring of_ `word`. A **substring** is a contiguous (nonempty) sequence of characters within a string. **Note:** Due to the large constraints, the answer may not fit in a signed 32bit integer. Please be careful during the calculations. **Example 1:** **Input:** word = aba **Output:** 6 **Explanation:** All possible substrings are: a , ab , aba , b , ba , and a . b has 0 vowels in it a , ab , ba , and a have 1 vowel each aba has 2 vowels in it Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. **Example 2:** **Input:** word = abc **Output:** 3 **Explanation:** All possible substrings are: a , ab , abc , b , bc , and c . a , ab , and abc have 1 vowel each b , bc , and c have 0 vowels each Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3. **Example 3:** **Input:** word = ltcd **Output:** 0 **Explanation:** There are no vowels in any substring of ltcd . **Constraints:** * `1 <= word.length <= 105` * `word` consists of lowercase English letters.","completion":"def count_vowels(word): sum = 0 count = 0 for letter in word: if letter in \\"aeiou\\": count += 1 sum += count return sum def count_vowels_in_substrings(word): return count_vowels(word)"},{"prompt":"We can represent a sentence as an array of words, for example, the sentence `I am happy with leetcode ` can be represented as `arr = [ I , am ,happy , with , leetcode ]`. Given two sentences `sentence1` and `sentence2` each represented as a string array and given an array of string pairs `similarPairs` where `similarPairs[i] = [xi, yi]` indicates that the two words `xi` and `yi` are similar. Return _`true` if `sentence1` and `sentence2` are similar, or `false` if they are not similar_. Two sentences are similar if: * They have **the same length** (i.e., the same number of words) * `sentence1[i]` and `sentence2[i]` are similar. Notice that a word is always similar to itself, also notice that the similarity relation is not transitive. For example, if the words `a` and `b` are similar, and the words `b` and `c` are similar, `a` and `c` are **not necessarily similar**. **Example 1:** **Input:** sentence1 = [ great , acting , skills ], sentence2 = [ fine , drama , talent ], similarPairs = [[ great , fine ],[ drama , acting ],[ skills , talent ]] **Output:** true **Explanation:** The two sentences have the same length and each word i of sentence1 is also similar to the corresponding word in sentence2. **Example 2:** **Input:** sentence1 = [ great ], sentence2 = [ great ], similarPairs = [] **Output:** true **Explanation:** A word is similar to itself. **Example 3:** **Input:** sentence1 = [ great ], sentence2 = [ doubleplus , good ], similarPairs = [[ great , doubleplus ]] **Output:** false **Explanation:** As they don\'t have the same length, we return false. **Constraints:** * `1 <= sentence1.length, sentence2.length <= 1000` * `1 <= sentence1[i].length, sentence2[i].length <= 20` * `sentence1[i]` and `sentence2[i]` consist of English letters. * `0 <= similarPairs.length <= 1000` * `similarPairs[i].length == 2` * `1 <= xi.length, yi.length <= 20` * `xi` and `yi` consist of lowercase and uppercase English letters. * All the pairs `(xi, yi)` are **distinct**.","completion":"from collections import defaultdict def areSentencesSimilar(sentence1, sentence2, similarPairs): if len(sentence1) != len(sentence2): return False similarityMap = defaultdict(set) for pair in similarPairs: similarityMap[pair[0]].add(pair[1]) similarityMap[pair[1]].add(pair[0]) for i in range(len(sentence1)): if sentence1[i] != sentence2[i] and sentence2[i] not in similarityMap[sentence1[i]]: return False return True"},{"prompt":"Given two strings `str1` and `str2` of the same length, determine whether you can transform `str1` into `str2` by doing **zero or more** _conversions_. In one conversion you can convert **all** occurrences of one character in `str1` to **any** other lowercase English character. Return `true` if and only if you can transform `str1` into `str2`. **Example 1:** **Input:** str1 = aabcc , str2 = ccdee **Output:** true **Explanation:** Convert \'c\' to \'e\' then \'b\' to \'d\' then \'a\' to \'c\'. Note that the order of conversions matter. **Example 2:** **Input:** str1 = leetcode , str2 = codeleet **Output:** false **Explanation:** There is no way to transform str1 to str2. **Constraints:** * `1 <= str1.length == str2.length <= 104` * `str1` and `str2` contain only lowercase English letters.","completion":"def canConvert(str1, str2): if str1 == str2: return True conversion = {} for c1, c2 in zip(str1, str2): if c1 in conversion and conversion[c1] != c2: return False conversion[c1] = c2 return len(set(str2)) < 26"},{"prompt":"You are given a tree with `n` nodes numbered from `0` to `n 1` in the form of a parent array `parent` where `parent[i]` is the parent of the `ith` node. The root of the tree is node `0`, so `parent[0] = 1` since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree. The data structure should support the following functions: * **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked. * **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user. * **Upgrade****: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true: * The node is unlocked, * It has at least one locked descendant (by **any** user), and * It does not have any locked ancestors. Implement the `LockingTree` class: * `LockingTree(int[] parent)` initializes the data structure with the parent array. * `lock(int num, int user)` returns `true` if it is possible for the user with id `user` to lock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **locked** by the user with id `user`. * `unlock(int num, int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **unlocked**. * `upgrade(int num, int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num`, or `false` otherwise. If it is possible, the node `num` will be **upgraded**. **Example 1:** **Input** [ LockingTree , lock , unlock , unlock , lock , upgrade , lock ] [[[1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]] **Output** [null, true, false, true, true, true, false] **Explanation** LockingTree lockingTree = new LockingTree([1, 0, 0, 1, 1, 2, 2]); lockingTree.lock(2, 2); // return true because node 2 is unlocked. // Node 2 will now be locked by user 2. lockingTree.unlock(2, 3); // return false because user 3 cannot unlock a node locked by user 2. lockingTree.unlock(2, 2); // return true because node 2 was previously locked by user 2. // Node 2 will now be unlocked. lockingTree.lock(4, 5); // return true because node 4 is unlocked. // Node 4 will now be locked by user 5. lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4). // Node 0 will now be locked by user 1 and node 4 will now be unlocked. lockingTree.lock(0, 1); // return false because node 0 is already locked. **Constraints:** * `n == parent.length` * `2 <= n <= 2000` * `0 <= parent[i] <= n 1` for `i != 0` * `parent[0] == 1` * `0 <= num <= n 1` * `1 <= user <= 104` * `parent` represents a valid tree. * At most `2000` calls **in total** will be made to `lock`, `unlock`, and `upgrade`.","completion":"def subset_xor_sum(nums): result = 0 n = len(nums) num_subsets = 1 << n for i in range(num_subsets): subset_xor = 0 for j in range(n): if i & (1 << j): subset_xor ^= nums[j] result += subset_xor return result"},{"prompt":"Given the coordinates of four points in 2D space `p1`, `p2`, `p3` and `p4`, return `true` _if the four points construct a square_. The coordinate of a point `pi` is represented as `[xi, yi]`. The input is **not** given in any order. A **valid square** has four equal sides with positive length and four equal angles (90degree angles). **Example 1:** **Input:** p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] **Output:** true **Example 2:** **Input:** p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12] **Output:** false **Example 3:** **Input:** p1 = [1,0], p2 = [1,0], p3 = [0,1], p4 = [0,1] **Output:** true **Constraints:** * `p1.length == p2.length == p3.length == p4.length == 2` * `104 <= xi, yi <= 104`","completion":"def validSquare(p1, p2, p3, p4): def dist_sq(p, q): return (p[0] - q[0])**2 + (p[1] - q[1])**2 points = [p1, p2, p3, p4] dists = set() for i in range(4): for j in range(i + 1, 4): dists.add(dist_sq(points[i], points[j])) return len(dists) == 2 and 0 not in dists"},{"prompt":"Given a list of strings `dict` where all the strings are of the same length. Return `true` if there are 2 strings that only differ by 1 character in the same index, otherwise return `false`. **Example 1:** **Input:** dict = [ abcd , acbd , aacd ] **Output:** true **Explanation:** Strings a**b**cd and a**a**cd differ only by one character in the index 1. **Example 2:** **Input:** dict = [ ab , cd , yz ] **Output:** false **Example 3:** **Input:** dict = [ abcd , cccc , abyd , abab ] **Output:** true **Constraints:** * The number of characters in `dict <= 105` * `dict[i].length == dict[j].length` * `dict[i]` should be unique. * `dict[i]` contains only lowercase English letters.","completion":"def minTime(n, edges, hasApple): graph = {i: {} for i in range(n)} for a, b in edges: graph[a][b] = 0 graph[b][a] = 0 def dfs(v, parent): ans = 0 for u in graph[v]: if u == parent: continue ans += dfs(u, v) * 2 return ans + int(hasApple[v] or ans > 0) return dfs(0, -1)"},{"prompt":"Given two strings `s1` and `s2`, return `true` _if_ `s2` _contains a permutation of_ `s1`_, or_ `false` _otherwise_. In other words, return `true` if one of `s1`\'s permutations is the substring of `s2`. **Example 1:** **Input:** s1 = ab , s2 = eidbaooo **Output:** true **Explanation:** s2 contains one permutation of s1 ( ba ). **Example 2:** **Input:** s1 = ab , s2 = eidboaoo **Output:** false **Constraints:** * `1 <= s1.length, s2.length <= 104` * `s1` and `s2` consist of lowercase English letters.","completion":"def checkInclusion(s1: str, s2: str) -> bool: if len(s1) > len(s2): return False s1_map = [0] * 26 s2_map = [0] * 26 for i in range(len(s1)): s1_map[ord(s1[i]) - ord(\'a\')] += 1 s2_map[ord(s2[i]) - ord(\'a\')] += 1 for i in range(len(s2) - len(s1)): if s1_map == s2_map: return True s2_map[ord(s2[i]) - ord(\'a\')] -= 1 s2_map[ord(s2[i + len(s1)]) - ord(\'a\')] += 1 return s1_map == s2_map"},{"prompt":"Given an integer `n`, return _the number of strings of length_ `n` _that consist only of vowels (_`a`_,_ `e`_,_ `i`_,_ `o`_,_ `u`_) and are **lexicographically sorted**._ A string `s` is **lexicographically sorted** if for all valid `i`, `s[i]` is the same as or comes before `s[i+1]` in the alphabet. **Example 1:** **Input:** n = 1 **Output:** 5 **Explanation:** The 5 sorted strings that consist of vowels only are `[ a , e , i , o , u ].` **Example 2:** **Input:** n = 2 **Output:** 15 **Explanation:** The 15 sorted strings that consist of vowels only are [ aa , ae , ai , ao , au , ee , ei , eo , eu , ii , io , iu , oo , ou , uu ]. Note that ea is not a valid string since \'e\' comes after \'a\' in the alphabet. **Example 3:** **Input:** n = 33 **Output:** 66045 **Constraints:** * `1 <= n <= 50`","completion":"def countVowelStrings(n: int) -> int: dp = [1, 1, 1, 1, 1] for i in range(2, n + 1): for j in range(3, -1, -1): dp[j] = dp[j] + dp[j + 1] return sum(dp)"},{"prompt":"The **value** of an alphanumeric string can be defined as: * The **numeric** representation of the string in base `10`, if it comprises of digits **only**. * The **length** of the string, otherwise. Given an array `strs` of alphanumeric strings, return _the **maximum value** of any string in_ `strs`. **Example 1:** **Input:** strs = [ alic3 , bob , 3 , 4 , 00000 ] **Output:** 5 **Explanation:** alic3 consists of both letters and digits, so its value is its length, i.e. 5. bob consists only of letters, so its value is also its length, i.e. 3. 3 consists only of digits, so its value is its numeric equivalent, i.e. 3. 4 also consists only of digits, so its value is 4. 00000 consists only of digits, so its value is 0. Hence, the maximum value is 5, of alic3 . **Example 2:** **Input:** strs = [ 1 , 01 , 001 , 0001 ] **Output:** 1 **Explanation:** Each string in the array has value 1. Hence, we return 1. **Constraints:** * `1 <= strs.length <= 100` * `1 <= strs[i].length <= 9` * `strs[i]` consists of only lowercase English letters and digits.","completion":"def maxValue(strs) -> int: max_value = 0 for str in strs: if str.isdigit(): value = int(str) else: value = len(str) max_value = max(max_value, value) return max_value"},{"prompt":"You are given an undirected graph (the **original graph **) with `n` nodes labeled from `0` to `n 1`. You decide to **subdivide** each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge. The graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will **subdivide** the edge into. Note that `cnti == 0` means you will not subdivide the edge. To **subdivide** the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti1, xcnti]`, `[xcnti, vi]`. In this **new graph**, you want to know how many nodes are **reachable** from the node `0`, where a node is **reachable** if the distance is `maxMoves` or less. Given the original graph and `maxMoves`, return _the number of nodes that are **reachable** from node_ `0` _in the new graph_. **Example 1:** **Input:** edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3 **Output:** 13 **Explanation:** The edge subdivisions are shown in the image above. The nodes that are reachable are highlighted in yellow. **Example 2:** **Input:** edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4 **Output:** 23 **Example 3:** **Input:** edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5 **Output:** 1 **Explanation:** Node 0 is disconnected from the rest of the graph, so only node 0 is reachable. **Constraints:** * `0 <= edges.length <= min(n * (n 1) / 2, 104)` * `edges[i].length == 3` * `0 <= ui < vi < n` * There are **no multiple edges** in the graph. * `0 <= cnti <= 104` * `0 <= maxMoves <= 109` * `1 <= n <= 3000`","completion":"def peakIndexInMountainArray(arr): low, high = 0, len(arr) - 1 while low < high: mid = low + (high - low) // 2 if arr[mid] < arr[mid + 1]: low = mid + 1 else: high = mid return low"},{"prompt":"Given an integer `n`, return **any** array containing `n` **unique** integers such that they add up to `0`. **Example 1:** **Input:** n = 5 **Output:** [7,1,1,3,4] **Explanation:** These arrays also are accepted [5,1,1,2,3] , [3,1,2,2,4]. **Example 2:** **Input:** n = 3 **Output:** [1,0,1] **Example 3:** **Input:** n = 1 **Output:** [0] **Constraints:** * `1 <= n <= 1000`","completion":"from heapq import heappush, heappop def longestHappyString(a, b, c): res = \\"\\" pq = [] if a: heappush(pq, (-a, \'a\')) if b: heappush(pq, (-b, \'b\')) if c: heappush(pq, (-c, \'c\')) while pq: curr = heappop(pq) if len(res) >= 2 and res[-1] == curr[1] and res[-2] == curr[1]: if not pq: break next = heappop(pq) res += next[1] if next[0] < -1: heappush(pq, (next[0] + 1, next[1])) heappush(pq, curr) else: res += curr[1] if curr[0] < -1: heappush(pq, (curr[0] + 1, curr[1])) return res"},{"prompt":"Given an integer `num`, return _three consecutive integers (as a sorted array)_ _that **sum** to_ `num`. If `num` cannot be expressed as the sum of three consecutive integers, return _an **empty** array._ **Example 1:** **Input:** num = 33 **Output:** [10,11,12] **Explanation:** 33 can be expressed as 10 + 11 + 12 = 33. 10, 11, 12 are 3 consecutive integers, so we return [10, 11, 12]. **Example 2:** **Input:** num = 4 **Output:** [] **Explanation:** There is no way to express 4 as the sum of 3 consecutive integers. **Constraints:** * `0 <= num <= 1015`","completion":"def almost_equivalent(word1, word2): freq1 = {} freq2 = {} for c in word1: freq1[c] = freq1.get(c, 0) + 1 for c in word2: freq2[c] = freq2.get(c, 0) + 1 for c in \\"abcdefghijklmnopqrstuvwxyz\\": if abs(freq1.get(c, 0) - freq2.get(c, 0)) > 3: return False return True"},{"prompt":"Given two strings `s` and `t`, each of which represents a nonnegative rational number, return `true` if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number. A **rational number** can be represented using up to three parts: , , and a . The number will be represented in one of the following three ways: * * For example, `12`, `0`, and `123`. * `**<.>**` * For example, `0.5`, `1.`, `2.12`, and `123.0001`. * `**<.>****<(>****<)>**` * For example, `0.1(6)`, `1.(9)`, `123.00(1212)`. The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example: * `1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)`. **Example 1:** **Input:** s = 0.(52) , t = 0.5(25) **Output:** true **Explanation:** Because 0.(52) represents 0.52525252..., and 0.5(25) represents 0.52525252525..... , the strings represent the same number. **Example 2:** **Input:** s = 0.1666(6) , t = 0.166(66) **Output:** true **Example 3:** **Input:** s = 0.9(9) , t = 1. **Output:** true **Explanation:** 0.9(9) represents 0.999999999... repeated forever, which equals 1. [[See this link for an explanation.](https://en.wikipedia.org/wiki/0.999...)] 1. represents the number 1, which is formed correctly: (IntegerPart) = 1 and (NonRepeatingPart) = . **Constraints:** * Each part consists only of digits. * The does not have leading zeros (except for the zero itself). * `1 <= .length <= 4` * `0 <= .length <= 4` * `1 <= .length <= 4`","completion":"def knightDialer(n: int) -> int: if n == 1: return 10 MOD = 10**9 + 7 moves = [ [4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [1, 7, 0], [2, 6], [1, 3], [2, 4] ] dp = [1] * 10 for _ in range(2, n + 1): new_dp = [0] * 10 for j in range(10): for move in moves[j]: new_dp[j] = (new_dp[j] + dp[move]) % MOD dp = new_dp return sum(dp) % MOD"},{"prompt":"You are given two **0indexed** strings `word1` and `word2`. A **move** consists of choosing two indices `i` and `j` such that `0 <= i < word1.length` and `0 <= j < word2.length` and swapping `word1[i]` with `word2[j]`. Return `true` _if it is possible to get the number of distinct characters in_ `word1` _and_ `word2` _to be equal with **exactly one** move._ Return `false` _otherwise_. **Example 1:** **Input:** word1 = ac , word2 = b **Output:** false **Explanation:** Any pair of swaps would yield two distinct characters in the first string, and one in the second string. **Example 2:** **Input:** word1 = abcc , word2 = aab **Output:** true **Explanation:** We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = abac and word2 = cab , which both have 3 distinct characters. **Example 3:** **Input:** word1 = abcde , word2 = fghij **Output:** true **Explanation:** Both resulting strings will have 5 distinct characters, regardless of which indices we swap. **Constraints:** * `1 <= word1.length, word2.length <= 105` * `word1` and `word2` consist of only lowercase English letters.","completion":"def compare(w1, w2): counts_w1 = [0]*26 counts_w2 = [0]*26 for c in w1: counts_w1[ord(c)-ord(\'a\')] += 1 for c in w2: counts_w2[ord(c)-ord(\'a\')] += 1 for i in range(26): if counts_w1[i] and counts_w2[i]: return True return False def swap_equal_distinct(word1, word2): exch = compare(word1, word2) return exch and len(word1) == len(word2)"},{"prompt":"Given a nonnegative integer `num`, Return its _encoding_ string. The encoding is done by converting the integer to a string using a secret function that you should deduce from the following table: **Example 1:** **Input:** num = 23 **Output:** 1000 **Example 2:** **Input:** num = 107 **Output:** 101100 **Constraints:** * `0 <= num <= 10^9` Rank is an integer starting from 1. The larger the element, the larger the rank. If two elements are the same, their rank must be the same. Rank should be as small as possible. Function signature: `int[] arrayRankTransform(int[] arr)`","completion":"def arrayRankTransform(arr): sorted_arr = sorted(arr) rank_map = {} rank = 1 for num in sorted_arr: if num not in rank_map: rank_map[num] = rank rank += 1 return [rank_map[num] for num in arr]"},{"prompt":"You are given a string `s` of even length. Split this string into two halves of equal lengths, and let `a` be the first half and `b` be the second half. Two strings are **alike** if they have the same number of vowels (`\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, `\'u\'`, `\'A\'`, `\'E\'`, `\'I\'`, `\'O\'`, `\'U\'`). Notice that `s` contains uppercase and lowercase letters. Return `true` _if_ `a` _and_ `b` _are **alike**_. Otherwise, return `false`. **Example 1:** **Input:** s = book **Output:** true **Explanation:** a = bo and b = ok . a has 1 vowel and b has 1 vowel. Therefore, they are alike. **Example 2:** **Input:** s = textbook **Output:** false **Explanation:** a = text and b = book . a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. **Constraints:** * `2 <= s.length <= 1000` * `s.length` is even. * `s` consists of **uppercase and lowercase** letters.","completion":"def numSpecial(mat): m, n = len(mat), len(mat[0]) row, col = [0] * m, [0] * n for i in range(m): for j in range(n): if mat[i][j] == 1: row[i] += 1 col[j] += 1 special_positions = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and row[i] == 1 and col[j] == 1: special_positions += 1 return special_positions"},{"prompt":"Given an integer number `n`, return the difference between the product of its digits and the sum of its digits. **Example 1:** **Input:** n = 234 **Output:** 15 **Explanation:** Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 9 = 15 **Example 2:** **Input:** n = 4421 **Output:** 21 **Explanation:** Product of digits = 4 * 4 * 2 * 1 = 32 Sum of digits = 4 + 4 + 2 + 1 = 11 Result = 32 11 = 21 **Constraints:** * `1 <= n <= 10^5`","completion":"def can_make_pali_queries(s, queries): result = [] for left, right, k in queries: count = [0] * 26 for i in range(left, right + 1): count[ord(s[i]) - ord(\'a\')] += 1 odd_count = sum(c % 2 for c in count) result.append(odd_count // 2 <= k) return result"},{"prompt":"Given an integer array **sorted** in nondecreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer. **Example 1:** **Input:** arr = [1,2,2,6,6,6,6,7,10] **Output:** 6 **Example 2:** **Input:** arr = [1,1] **Output:** 1 **Constraints:** * `1 <= arr.length <= 104` * `0 <= arr[i] <= 105`","completion":"def shortest_distance(distance, start, destination): total_distance = sum(distance) clockwise_distance = sum(distance[start:destination]) return min(clockwise_distance, total_distance - clockwise_distance)"},{"prompt":"Given an integer array `arr`, return `true` if there are three consecutive odd numbers in the array. Otherwise, return `false`. **Example 1:** **Input:** arr = [2,6,4,1] **Output:** false **Explanation:** There are no three consecutive odds. **Example 2:** **Input:** arr = [1,2,34,3,4,5,7,23,12] **Output:** true **Explanation:** [5,7,23] are three consecutive odds. **Constraints:** * `1 <= arr.length <= 1000` * `1 <= arr[i] <= 1000`","completion":"import heapq def kthSmallest(mat, k): m, n = len(mat), len(mat[0]) minHeap = [(mat[0][0], 0, 0)] visited = [[False for _ in range(n)] for _ in range(m)] visited[0][0] = True for _ in range(k): res, i, j = heapq.heappop(minHeap) if i < m - 1 and not visited[i+1][j]: heapq.heappush(minHeap, (res - mat[i][j] + mat[i + 1][j], i + 1, j)) visited[i+1][j] = True if j < n - 1 and not visited[i][j+1]: heapq.heappush(minHeap, (res - mat[i][j] + mat[i][j + 1], i, j + 1)) visited[i][j+1] = True return res"},{"prompt":"You are given two **0indexed** arrays of strings `startWords` and `targetWords`. Each string consists of **lowercase English letters** only. For each string in `targetWords`, check if it is possible to choose a string from `startWords` and perform a **conversion operation** on it to be equal to that from `targetWords`. The **conversion operation** is described in the following two steps: 1. **Append** any lowercase letter that is **not present** in the string to its end. * For example, if the string is `abc `, the letters `\'d\'`, `\'e\'`, or `\'y\'` can be added to it, but not `\'a\'`. If `\'d\'` is added, the resulting string will be `abcd `. 2. **Rearrange** the letters of the new string in **any** arbitrary order. * For example, `abcd ` can be rearranged to `acbd `, `bacd `, `cbda `, and so on. Note that it can also be rearranged to `abcd ` itself. Return _the **number of strings** in_ `targetWords` _that can be obtained by performing the operations on **any** string of_ `startWords`. **Note** that you will only be verifying if the string in `targetWords` can be obtained from a string in `startWords` by performing the operations. The strings in `startWords` **do not** actually change during this process. **Example 1:** **Input:** startWords = [ ant , act , tack ], targetWords = [ tack , act , acti ] **Output:** 2 **Explanation:** In order to form targetWords[0] = tack , we use startWords[1] = act , append \'k\' to it, and rearrange actk to tack . There is no string in startWords that can be used to obtain targetWords[1] = act . Note that act does exist in startWords, but we **must** append one letter to the string before rearranging it. In order to form targetWords[2] = acti , we use startWords[1] = act , append \'i\' to it, and rearrange acti to acti itself. **Example 2:** **Input:** startWords = [ ab , a ], targetWords = [ abc , abcd ] **Output:** 1 **Explanation:** In order to form targetWords[0] = abc , we use startWords[0] = ab , add \'c\' to it, and rearrange it to abc . There is no string in startWords that can be used to obtain targetWords[1] = abcd . **Constraints:** * `1 <= startWords.length, targetWords.length <= 5 * 104` * `1 <= startWords[i].length, targetWords[j].length <= 26` * Each string of `startWords` and `targetWords` consists of lowercase English letters only. * No letter occurs more than once in any string of `startWords` or `targetWords`.","completion":"def numOfWays(nums, k): left = 0 right = 0 for num in nums: if num < k: left += 1 if num <= k: right += 1 if left == len(nums): return 0 if right - left != len(nums) - right: return left + 1 return left"},{"prompt":"You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string. Return _the merged string._ **Example 1:** **Input:** word1 = abc , word2 = pqr **Output:** apbqcr **Explanation:** The merged string will be merged as so: word1: a b c word2: p q r merged: a p b q c r **Example 2:** **Input:** word1 = ab , word2 = pqrs **Output:** apbqrs **Explanation:** Notice that as word2 is longer, rs is appended to the end. word1: a b word2: p q r s merged: a p b q r s **Example 3:** **Input:** word1 = abcd , word2 = pq **Output:** apbqcd **Explanation:** Notice that as word1 is longer, cd is appended to the end. word1: a b c d word2: p q merged: a p b q c d **Constraints:** * `1 <= word1.length, word2.length <= 100` * `word1` and `word2` consist of lowercase English letters.","completion":"def mergeAlternately(word1: str, word2: str) -> str: result = [] i, j = 0, 0 while i < len(word1) and j < len(word2): result.append(word1[i]) result.append(word2[j]) i += 1 j += 1 result += word1[i:] result += word2[j:] return \\"\\".join(result)"},{"prompt":"You are given a **0indexed** integer array `nums`. In one operation, you may do the following: * Choose **two** integers in `nums` that are **equal**. * Remove both integers from `nums`, forming a **pair**. The operation is done on `nums` as many times as possible. Return _a **0indexed** integer array_ `answer` _of size_ `2` _where_ `answer[0]` _is the number of pairs that are formed and_ `answer[1]` _is the number of leftover integers in_ `nums` _after doing the operation as many times as possible_. **Example 1:** **Input:** nums = [1,3,2,1,3,2,2] **Output:** [3,1] **Explanation:** Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2]. Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2]. Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2]. No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums. **Example 2:** **Input:** nums = [1,1] **Output:** [1,0] **Explanation:** Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = []. No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums. **Example 3:** **Input:** nums = [0] **Output:** [0,1] **Explanation:** No pairs can be formed, and there is 1 number leftover in nums. **Constraints:** * `1 <= nums.length <= 100` * `0 <= nums[i] <= 100`","completion":"def count_pairs_leftovers(nums): counter = [0] * 101 pairs, leftovers = 0, 0 for n in nums: counter[n] += 1 for count in counter: pairs += count // 2 leftovers += count % 2 return [pairs, leftovers]"},{"prompt":"You are given a **0indexed** integer array `nums` of length `n`. `nums` contains a **valid split** at index `i` if the following are true: * The sum of the first `i + 1` elements is **greater than or equal to** the sum of the last `n i 1` elements. * There is **at least one** element to the right of `i`. That is, `0 <= i < n 1`. Return _the number of **valid splits** in_ `nums`. **Example 1:** **Input:** nums = [10,4,8,7] **Output:** 2 **Explanation:** There are three ways of splitting nums into two nonempty parts: Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split. Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [8,7], and its sum is 1. Since 14 >= 1, i = 1 is a valid split. Split nums at index 2. Then, the first part is [10,4,8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split. Thus, the number of valid splits in nums is 2. **Example 2:** **Input:** nums = [2,3,1,0] **Output:** 2 **Explanation:** There are two valid splits in nums: Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split. **Constraints:** * `2 <= nums.length <= 105` * `105 <= nums[i] <= 105`","completion":"def lonely_numbers(nums): num_set = set(nums) lonely = [] for num in nums: if num - 1 not in num_set and num + 1 not in num_set: lonely.append(num) return lonely"},{"prompt":"You are given a positive integer array `nums`. * The **element sum** is the sum of all the elements in `nums`. * The **digit sum** is the sum of all the digits (not necessarily distinct) that appear in `nums`. Return _the **absolute** difference between the **element sum** and **digit sum** of_ `nums`. **Note** that the absolute difference between two integers `x` and `y` is defined as `|x y|`. **Example 1:** **Input:** nums = [1,15,6,3] **Output:** 9 **Explanation:** The element sum of nums is 1 + 15 + 6 + 3 = 25. The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16. The absolute difference between the element sum and digit sum is |25 16| = 9. **Example 2:** **Input:** nums = [1,2,3,4] **Output:** 0 **Explanation:** The element sum of nums is 1 + 2 + 3 + 4 = 10. The digit sum of nums is 1 + 2 + 3 + 4 = 10. The absolute difference between the element sum and digit sum is |10 10| = 0. **Constraints:** * `1 <= nums.length <= 2000` * `1 <= nums[i] <= 2000`","completion":"def difference_between_element_and_digit_sum(nums): element_sum = sum(nums) digit_sum = sum(sum(int(digit) for digit in str(num)) for num in nums) return abs(element_sum - digit_sum)"},{"prompt":"You are given two positive integer arrays `nums` and `numsDivide`. You can delete any number of elements from `nums`. Return _the **minimum** number of deletions such that the **smallest** element in_ `nums` _**divides** all the elements of_ `numsDivide`. If this is not possible, return `1`. Note that an integer `x` divides `y` if `y % x == 0`. **Example 1:** **Input:** nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15] **Output:** 2 **Explanation:** The smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide. We use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3]. The smallest element in [3,4,3] is 3, which divides all the elements of numsDivide. It can be shown that 2 is the minimum number of deletions needed. **Example 2:** **Input:** nums = [4,3,6], numsDivide = [8,2,6,10] **Output:** 1 **Explanation:** We want the smallest element in nums to divide all the elements of numsDivide. There is no way to delete elements from nums to allow this. **Constraints:** * `1 <= nums.length, numsDivide.length <= 105` * `1 <= nums[i], numsDivide[i] <= 109`","completion":"def min_deletions(nums, nums_divide): res = float(\'inf\') for num in nums: cnt = 0 found = True for d in nums_divide: if d % num != 0: found = False break if found: for n in nums: if n == num: cnt += 1 res = min(res, len(nums) - cnt) return -1 if res == float(\'inf\') else res"},{"prompt":"There are `n` persons on a social media website. You are given an integer array `ages` where `ages[i]` is the age of the `ith` person. A Person `x` will not send a friend request to a person `y` (`x != y`) if any of the following conditions is true: * `age[y] <= 0.5 * age[x] + 7` * `age[y] > age[x]` * `age[y] > 100 && age[x] < 100` Otherwise, `x` will send a friend request to `y`. Note that if `x` sends a request to `y`, `y` will not necessarily send a request to `x`. Also, a person will not send a friend request to themself. Return _the total number of friend requests made_. **Example 1:** **Input:** ages = [16,16] **Output:** 2 **Explanation:** 2 people friend request each other. **Example 2:** **Input:** ages = [16,17,18] **Output:** 2 **Explanation:** Friend requests are made 17 > 16, 18 > 17. **Example 3:** **Input:** ages = [20,30,100,110,120] **Output:** 3 **Explanation:** Friend requests are made 110 > 100, 120 > 110, 120 > 100. **Constraints:** * `n == ages.length` * `1 <= n <= 2 * 104` * `1 <= ages[i] <= 120`","completion":"def max_increase_keeping_skyline(grid): n = len(grid) row_max = [0] * n col_max = [0] * n for i in range(n): for j in range(n): row_max[i] = max(row_max[i], grid[i][j]) col_max[j] = max(col_max[j], grid[i][j]) total_sum = 0 for i in range(n): for j in range(n): total_sum += min(row_max[i], col_max[j]) - grid[i][j] return total_sum"},{"prompt":"You are given an `n x n` binary grid `board`. In each move, you can swap any two rows with each other, or any two columns with each other. Return _the minimum number of moves to transform the board into a **chessboard board**_. If the task is impossible, return `1`. A **chessboard board** is a board where no `0`\'s and no `1`\'s are 4directionally adjacent. **Example 1:** **Input:** board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] **Output:** 2 **Explanation:** One potential sequence of moves is shown. The first move swaps the first and second column. The second move swaps the second and third row. **Example 2:** **Input:** board = [[0,1],[1,0]] **Output:** 0 **Explanation:** Also note that the board with 0 in the top left corner, is also a valid chessboard. **Example 3:** **Input:** board = [[1,0],[1,0]] **Output:** 1 **Explanation:** No matter what sequence of moves you make, you cannot end with a valid chessboard. **Constraints:** * `n == board.length` * `n == board[i].length` * `2 <= n <= 30` * `board[i][j]` is either `0` or `1`.","completion":"def numJewelsInStones(jewels, stones): count = 0 for s in stones: if s in jewels: count += 1 return count"},{"prompt":"Alice is throwing `n` darts on a very large wall. You are given an array `darts` where `darts[i] = [xi, yi]` is the position of the `ith` dart that Alice threw on the wall. Bob knows the positions of the `n` darts on the wall. He wants to place a dartboard of radius `r` on the wall so that the maximum number of darts that Alice throws lies on the dartboard. Given the integer `r`, return _the maximum number of darts that can lie on the dartboard_. **Example 1:** **Input:** darts = [[2,0],[2,0],[0,2],[0,2]], r = 2 **Output:** 4 **Explanation:** Circle dartboard with center in (0,0) and radius = 2 contain all points. **Example 2:** **Input:** darts = [[3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5 **Output:** 5 **Explanation:** Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8). **Constraints:** * `1 <= darts.length <= 100` * `darts[i].length == 2` * `104 <= xi, yi <= 104` * All the `darts` are unique * `1 <= r <= 5000`","completion":"def numPoints(darts, r): n = len(darts) result = 1 for i in range(n): for j in range(n): cnt = 0 for k in range(n): dx = darts[i][0] - darts[k][0] dy = darts[i][1] - darts[k][1] if (dx * dx + dy * dy) ** 0.5 <= r: cnt += 1 if cnt > result: result = cnt return result"},{"prompt":"You have two fruit baskets containing `n` fruits each. You are given two **0indexed** integer arrays `basket1` and `basket2` representing the cost of fruit in each basket. You want to make both baskets **equal**. To do so, you can use the following operation as many times as you want: * Chose two indices `i` and `j`, and swap the `ith` fruit of `basket1` with the `jth` fruit of `basket2`. * The cost of the swap is `min(basket1[i],basket2[j])`. Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets. Return _the minimum cost to make both the baskets equal or_ `1` _if impossible._ **Example 1:** **Input:** basket1 = [4,2,2,2], basket2 = [1,4,1,2] **Output:** 1 **Explanation:** Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal. **Example 2:** **Input:** basket1 = [2,3,4,1], basket2 = [3,2,5,1] **Output:** 1 **Explanation:** It can be shown that it is impossible to make both the baskets equal. **Constraints:** * `basket1.length == bakste2.length` * `1 <= basket1.length <= 105` * `1 <= basket1[i],basket2[i] <= 109`","completion":"def min_cost_to_equal_baskets(basket1, basket2): diff_count = {} for i in range(len(basket1)): diff = basket1[i] - basket2[i] diff_count[diff] = diff_count.get(diff, 0) + 1 min_cost = float(\'inf\') for diff, count in diff_count.items(): if count == diff_count.get(-diff, 0): cost = sum(min(basket1[i], basket2[i]) for i in range(len(basket1)) if basket1[i] - basket2[i] == diff) min_cost = min(min_cost, cost) return -1 if min_cost == float(\'inf\') else min_cost // 2"},{"prompt":"You are given an integer array `nums`, and you can perform the following operation **any** number of times on `nums`: * Swap the positions of two elements `nums[i]` and `nums[j]` if `gcd(nums[i], nums[j]) > 1` where `gcd(nums[i], nums[j])` is the **greatest common divisor** of `nums[i]` and `nums[j]`. Return `true` _if it is possible to sort_ `nums` _in **nondecreasing** order using the above swap method, or_ `false` _otherwise._ **Example 1:** **Input:** nums = [7,21,3] **Output:** true **Explanation:** We can sort [7,21,3] by performing the following operations: Swap 7 and 21 because gcd(7,21) = 7. nums = [**21**,**7**,3] Swap 21 and 3 because gcd(21,3) = 3. nums = [**3**,7,**21**] **Example 2:** **Input:** nums = [5,2,6,2] **Output:** false **Explanation:** It is impossible to sort the array because 5 cannot be swapped with any other element. **Example 3:** **Input:** nums = [10,5,9,3,15] **Output:** true We can sort [10,5,9,3,15] by performing the following operations: Swap 10 and 15 because gcd(10,15) = 5. nums = [**15**,5,9,3,**10**] Swap 15 and 3 because gcd(15,3) = 3. nums = [**3**,5,9,**15**,10] Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,**10**,**15**] **Constraints:** * `1 <= nums.length <= 3 * 104` * `2 <= nums[i] <= 105`","completion":"from math import gcd def can_be_sorted(nums): sorted_nums = sorted(nums) for i in range(len(nums)): if nums[i] != sorted_nums[i] and gcd(nums[i], sorted_nums[i]) == 1: return False return True"},{"prompt":"You are given a **0indexed** string `s` that you must perform `k` replacement operations on. The replacement operations are given as three **0indexed** parallel arrays, `indices`, `sources`, and `targets`, all of length `k`. To complete the `ith` replacement operation: 1. Check if the **substring** `sources[i]` occurs at index `indices[i]` in the **original string** `s`. 2. If it does not occur, **do nothing**. 3. Otherwise if it does occur, **replace** that substring with `targets[i]`. For example, if `s = abcd `, `indices[i] = 0`, `sources[i] = ab `, and `targets[i] = eee `, then the result of this replacement will be `eeecd `. All replacement operations must occur **simultaneously**, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will **not overlap**. * For example, a testcase with `s = abc `, `indices = [0, 1]`, and `sources = [ ab , bc ]` will not be generated because the `ab ` and `bc ` replacements overlap. Return _the **resulting string** after performing all replacement operations on_ `s`. A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** s = abcd , indices = [0, 2], sources = [ a , cd ], targets = [ eee , ffff ] **Output:** eeebffff **Explanation:** a occurs at index 0 in s, so we replace it with eee . cd occurs at index 2 in s, so we replace it with ffff . **Example 2:** **Input:** s = abcd , indices = [0, 2], sources = [ ab , ec ], targets = [ eee , ffff ] **Output:** eeecd **Explanation:** ab occurs at index 0 in s, so we replace it with eee . ec does not occur at index 2 in s, so we do nothing. **Constraints:** * `1 <= s.length <= 1000` * `k == indices.length == sources.length == targets.length` * `1 <= k <= 100` * `0 <= indexes[i] < s.length` * `1 <= sources[i].length, targets[i].length <= 50` * `s` consists of only lowercase English letters. * `sources[i]` and `targets[i]` consist of only lowercase English letters.","completion":"from collections import defaultdict from queue import Queue def numBusesToDestination(routes, source, target): if source == target: return 0 stop_to_buses = defaultdict(set) for i, route in enumerate(routes): for stop in route: stop_to_buses[stop].add(i) q = Queue() visited_buses = set() num_buses = 0 q.put(source) while not q.empty(): size = q.qsize() for _ in range(size): stop = q.get() for bus in stop_to_buses[stop]: if bus in visited_buses: continue visited_buses.add(bus) for next_stop in routes[bus]: if next_stop == target: return num_buses + 1 q.put(next_stop) num_buses += 1 return -1"},{"prompt":"You are given a **0indexed** integer array `nums` of length `n`. You can perform the following operation as many times as you want: * Pick an index `i` that you haven\'t picked before, and pick a prime `p` **strictly less than** `nums[i]`, then subtract `p` from `nums[i]`. Return _true if you can make `nums` a strictly increasing array using the above operation and false otherwise._ A **strictly increasing array** is an array whose each element is strictly greater than its preceding element. **Example 1:** **Input:** nums = [4,9,6,10] **Output:** true **Explanation:** In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10]. In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10]. After the second operation, nums is sorted in strictly increasing order, so the answer is true. **Example 2:** **Input:** nums = [6,8,11,12] **Output:** true **Explanation:** Initially nums is sorted in strictly increasing order, so we don\'t need to make any operations. **Example 3:** **Input:** nums = [5,8,3] **Output:** false **Explanation:** It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false. **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i] <= 1000` * `nums.length == n`","completion":"def strictlyIncreasingArray(nums): for i in range(len(nums) - 1): nums[i] -= i if nums[i] >= nums[i + 1]: return False return True"},{"prompt":"Consider a function that implements an algorithm **similar** to [Binary Search](https://leetcode.com/explore/learn/card/binarysearch/). The function has two input parameters: `sequence` is a sequence of integers, and `target` is an integer value. The purpose of the function is to find if the `target` exists in the `sequence`. The pseudocode of the function is as follows: func(sequence, target) while sequence is not empty **randomly** choose an element from sequence as the pivot if pivot = target, return **true** else if pivot < target, remove pivot and all elements to its left from the sequence else, remove pivot and all elements to its right from the sequence end while return **false** When the `sequence` is sorted, the function works correctly for **all** values. When the `sequence` is not sorted, the function does not work for all values, but may still work for **some** values. Given an integer array `nums`, representing the `sequence`, that contains **unique** numbers and **may or may not be sorted**, return _the number of values that are **guaranteed** to be found using the function, for **every possible** pivot selection_. **Example 1:** **Input:** nums = [7] **Output:** 1 **Explanation**: Searching for value 7 is guaranteed to be found. Since the sequence has only one element, 7 will be chosen as the pivot. Because the pivot equals the target, the function will return true. **Example 2:** **Input:** nums = [1,5,2] **Output:** 1 **Explanation**: Searching for value 1 is guaranteed to be found. If 1 was chosen as the pivot, the function would return true. If 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only 1 and the function would return true. If 2 was chosen as the pivot, 2 would be removed. In the next loop, the sequence would have 1 and 5. No matter which number was chosen as the next pivot, the function would find 1 and return true. Searching for value 5 is NOT guaranteed to be found. If 2 was chosen as the pivot, 1, 5 and 2 would be removed. The sequence would be empty and the function would return false. Searching for value 2 is NOT guaranteed to be found. If 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only 1 and the function would return false. Because only 1 is guaranteed to be found, you should return 1. **Constraints:** * `1 <= nums.length <= 105` * `105 <= nums[i] <= 105` * All the values of `nums` are **unique**.","completion":"def maxFrequency(nums, k): nums.sort() max_freq, n, total = 1, len(nums), 0 i = 0 for j in range(n): total += nums[j] while total < nums[j] * (j - i + 1) - k: total -= nums[i] i += 1 max_freq = max(max_freq, j - i + 1) return max_freq"},{"prompt":"You are given two 2D integer arrays, `items1` and `items2`, representing two sets of items. Each array `items` has the following properties: * `items[i] = [valuei, weighti]` where `valuei` represents the **value** and `weighti` represents the **weight** of the `ith` item. * The value of each item in `items` is **unique**. Return _a 2D integer array_ `ret` _where_ `ret[i] = [valuei, weighti]`_,_ _with_ `weighti` _being the **sum of weights** of all items with value_ `valuei`. **Note:** `ret` should be returned in **ascending** order by value. **Example 1:** **Input:** items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] **Output:** [[1,6],[3,9],[4,5]] **Explanation:** The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6. The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9. The item with value = 4 occurs in items1 with weight = 5, total weight = 5. Therefore, we return [[1,6],[3,9],[4,5]]. **Example 2:** **Input:** items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]] **Output:** [[1,4],[2,4],[3,4]] **Explanation:** The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4. The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4. The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. Therefore, we return [[1,4],[2,4],[3,4]]. **Example 3:** **Input:** items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]] **Output:** [[1,7],[2,4],[7,1]] **Explanation:** The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. The item with value = 7 occurs in items2 with weight = 1, total weight = 1. Therefore, we return [[1,7],[2,4],[7,1]]. **Constraints:** * `1 <= items1.length, items2.length <= 1000` * `items1[i].length == items2[i].length == 2` * `1 <= valuei, weighti <= 1000` * Each `valuei` in `items1` is **unique**. * Each `valuei` in `items2` is **unique**.","completion":"def sum_weights(items1, items2): weight_sums = {} result = [] for value, weight in items1: weight_sums[value] = weight_sums.get(value, 0) + weight for value, weight in items2: weight_sums[value] = weight_sums.get(value, 0) + weight for value, weight in sorted(weight_sums.items()): result.append([value, weight]) return result"},{"prompt":"You are given two **2D** integer arrays `nums1` and `nums2.` * `nums1[i] = [idi, vali]` indicate that the number with the id `idi` has a value equal to `vali`. * `nums2[i] = [idi, vali]` indicate that the number with the id `idi` has a value equal to `vali`. Each array contains **unique** ids and is sorted in **ascending** order by id. Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions: * Only ids that appear in at least one of the two arrays should be included in the resulting array. * Each id should be included **only once** and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be `0`. Return _the resulting array_. The returned array must be sorted in ascending order by id. **Example 1:** **Input:** nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]] **Output:** [[1,6],[2,3],[3,2],[4,6]] **Explanation:** The resulting array contains the following: id = 1, the value of this id is 2 + 4 = 6. id = 2, the value of this id is 3. id = 3, the value of this id is 2. id = 4, the value of this id is 5 + 1 = 6. **Example 2:** **Input:** nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]] **Output:** [[1,3],[2,4],[3,6],[4,3],[5,5]] **Explanation:** There are no common ids, so we just include each id with its value in the resulting list. **Constraints:** * `1 <= nums1.length, nums2.length <= 200` * `nums1[i].length == nums2[j].length == 2` * `1 <= idi, vali <= 1000` * Both arrays contain unique ids. * Both arrays are in strictly ascending order by id.","completion":"def merge_nums(nums1, nums2): merged_map = {} merged = [] for id_val_pair in nums1: id_, val_ = id_val_pair if id_ not in merged_map: merged_map[id_] = val_ else: merged_map[id_] += val_ for id_val_pair in nums2: id_, val_ = id_val_pair if id_ not in merged_map: merged_map[id_] = val_ else: merged_map[id_] += val_ for id_, val_ in merged_map.items(): merged.append([id_, val_]) return merged"},{"prompt":"There is a function `signFunc(x)` that returns: * `1` if `x` is positive. * `1` if `x` is negative. * `0` if `x` is equal to `0`. You are given an integer array `nums`. Let `product` be the product of all values in the array `nums`. Return `signFunc(product)`. **Example 1:** **Input:** nums = [1,2,3,4,3,2,1] **Output:** 1 **Explanation:** The product of all values in the array is 144, and signFunc(144) = 1 **Example 2:** **Input:** nums = [1,5,0,2,3] **Output:** 0 **Explanation:** The product of all values in the array is 0, and signFunc(0) = 0 **Example 3:** **Input:** nums = [1,1,1,1,1] **Output:** 1 **Explanation:** The product of all values in the array is 1, and signFunc(1) = 1 **Constraints:** * `1 <= nums.length <= 1000` * `100 <= nums[i] <= 100`","completion":"def signFunc(x): if x > 0: return 1 elif x < 0: return -1 else: return 0 def arraySign(nums): product = 1 for num in nums: product *= signFunc(num) return product"},{"prompt":"Given a string `s` and a character `letter`, return _the **percentage** of characters in_ `s` _that equal_ `letter` _**rounded down** to the nearest whole percent._ **Example 1:** **Input:** s = foobar , letter = o **Output:** 33 **Explanation:** The percentage of characters in s that equal the letter \'o\' is 2 / 6 * 100% = 33% when rounded down, so we return 33. **Example 2:** **Input:** s = jjjj , letter = k **Output:** 0 **Explanation:** The percentage of characters in s that equal the letter \'k\' is 0%, so we return 0. **Constraints:** * `1 <= s.length <= 100` * `s` consists of lowercase English letters. * `letter` is a lowercase English letter.","completion":"def three_consecutive_integers(num): if num % 3 == 0: return [num // 3 - 1, num // 3, num // 3 + 1] elif num % 3 == 1: return [(num - 2) // 3, (num + 1) // 3, (num + 4) // 3] else: return []"},{"prompt":"Given a string `text`, you want to use the characters of `text` to form as many instances of the word **balloon ** as possible. You can use each character in `text` **at most once**. Return the maximum number of instances that can be formed. **Example 1:** **Input:** text = nlaebolko **Output:** 1 **Example 2:** **Input:** text = loonbalxballpoon **Output:** 2 **Example 3:** **Input:** text = leetcode **Output:** 0 **Constraints:** * `1 <= text.length <= 104` * `text` consists of lower case English letters only.","completion":"def max_number_of_balloons(text: str) -> int: letter_count = [0] * 5 for c in text: if c == \'b\': letter_count[0] += 1 if c == \'a\': letter_count[1] += 1 if c == \'l\': letter_count[2] += 1 if c == \'o\': letter_count[3] += 1 if c == \'n\': letter_count[4] += 1 letter_count[2] //= 2 letter_count[3] //= 2 return min(letter_count)"},{"prompt":"You are given an integer array `rolls` of length `n` and an integer `k`. You roll a `k` sided dice numbered from `1` to `k`, `n` times, where the result of the `ith` roll is `rolls[i]`. Return _the length of the **shortest** sequence of rolls that **cannot** be taken from_ `rolls`. A **sequence of rolls** of length `len` is the result of rolling a `k` sided dice `len` times. **Note** that the sequence taken does not have to be consecutive as long as it is in order. **Example 1:** **Input:** rolls = [4,2,1,2,3,3,2,4,1], k = 4 **Output:** 3 **Explanation:** Every sequence of rolls of length 1, [1], [2], [3], [4], can be taken from rolls. Every sequence of rolls of length 2, [1, 1], [1, 2], ..., [4, 4], can be taken from rolls. The sequence [1, 4, 2] cannot be taken from rolls, so we return 3. Note that there are other sequences that cannot be taken from rolls. **Example 2:** **Input:** rolls = [1,1,2,2], k = 2 **Output:** 2 **Explanation:** Every sequence of rolls of length 1, [1], [2], can be taken from rolls. The sequence [2, 1] cannot be taken from rolls, so we return 2. Note that there are other sequences that cannot be taken from rolls but [2, 1] is the shortest. **Example 3:** **Input:** rolls = [1,1,3,2,2,2,3,3], k = 4 **Output:** 1 **Explanation:** The sequence [4] cannot be taken from rolls, so we return 1. Note that there are other sequences that cannot be taken from rolls but [4] is the shortest. **Constraints:** * `n == rolls.length` * `1 <= n <= 105` * `1 <= rolls[i] <= k <= 105`","completion":"def shortest_unrollable_sequence(rolls, k): count = [0] * (k + 1) for roll in rolls: count[roll] += 1 len_ = 1 while True: max_subsequences = 1 for i in range(1, k + 1): max_subsequences *= count[i] + (1 if len_ == 1 else 0) if max_subsequences < len_ * len(rolls): return len_ len_ += 1"},{"prompt":"There is an **undirected** graph with `n` nodes, numbered from `0` to `n 1`. You are given a **0indexed** integer array `scores` of length `n` where `scores[i]` denotes the score of node `i`. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`. A node sequence is **valid** if it meets the following conditions: * There is an edge connecting every pair of **adjacent** nodes in the sequence. * No node appears more than once in the sequence. The score of a node sequence is defined as the **sum** of the scores of the nodes in the sequence. Return _the **maximum score** of a valid node sequence with a length of_ `4`_._ If no such sequence exists, return `1`. **Example 1:** **Input:** scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] **Output:** 24 **Explanation:** The figure above shows the graph and the chosen node sequence [0,1,2,3]. The score of the node sequence is 5 + 2 + 9 + 8 = 24. It can be shown that no other node sequence has a score of more than 24. Note that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24. The sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3. **Example 2:** **Input:** scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]] **Output:** 1 **Explanation:** The figure above shows the graph. There are no valid node sequences of length 4, so we return 1. **Constraints:** * `n == scores.length` * `4 <= n <= 5 * 104` * `1 <= scores[i] <= 108` * `0 <= edges.length <= 5 * 104` * `edges[i].length == 2` * `0 <= ai, bi <= n 1` * `ai != bi` * There are no duplicate edges.","completion":"def maxScore(scores, edges): adj_list = [[] for _ in range(len(scores))] result = -1 for edge in edges: adj_list[edge[0]].append(edge[1]) adj_list[edge[1]].append(edge[0]) for edge in edges: for neighbor in adj_list[edge[0]]: for next in adj_list[edge[1]]: if next != neighbor and next != edge[0]: result = max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next]) return result"},{"prompt":"You are given two **0indexed** integer arrays `nums1` and `nums2` of equal length `n` and a positive integer `k`. You must choose a **subsequence** of indices from `nums1` of length `k`. For chosen indices `i0`, `i1`, ..., `ik 1`, your **score** is defined as: * The sum of the selected elements from `nums1` multiplied with the **minimum** of the selected elements from `nums2`. * It can defined simply as: `(nums1[i0] + nums1[i1] +...+ nums1[ik 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik 1])`. Return _the **maximum** possible score._ A **subsequence** of indices of an array is a set that can be derived from the set `{0, 1, ..., n1}` by deleting some or no elements. **Example 1:** **Input:** nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3 **Output:** 12 **Explanation:** The four possible subsequence scores are: We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7. We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8. Therefore, we return the max score, which is 12. **Example 2:** **Input:** nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1 **Output:** 30 **Explanation:** Choosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score. **Constraints:** * `n == nums1.length == nums2.length` * `1 <= n <= 105` * `0 <= nums1[i], nums2[j] <= 105` * `1 <= k <= n`","completion":"def maxScore(nums1, nums2, k): n = len(nums1) res = 0 sum_n1 = 0 min_n2 = nums2[0] i, j = 0, 0 while j < n: sum_n1 += nums1[j] min_n2 = min(min_n2, nums2[j]) if j - i + 1 > k: sum_n1 -= nums1[i] i += 1 if j + 1 >= k: res = max(res, sum_n1 * min_n2) j += 1 return res"},{"prompt":"You are given a **0indexed** integer array `nums`. The **effective value** of three indices `i`, `j`, and `k` is defined as `((nums[i] | nums[j]) & nums[k])`. The **xorbeauty** of the array is the XORing of **the effective values of all the possible triplets** of indices `(i, j, k)` where `0 <= i, j, k < n`. Return _the xorbeauty of_ `nums`. **Note** that: * `val1 | val2` is bitwise OR of `val1` and `val2`. * `val1 & val2` is bitwise AND of `val1` and `val2`. **Example 1:** **Input:** nums = [1,4] **Output:** 5 **Explanation:** The triplets and their corresponding effective values are listed below: (0,0,0) with effective value ((1 | 1) & 1) = 1 (0,0,1) with effective value ((1 | 1) & 4) = 0 (0,1,0) with effective value ((1 | 4) & 1) = 1 (0,1,1) with effective value ((1 | 4) & 4) = 4 (1,0,0) with effective value ((4 | 1) & 1) = 1 (1,0,1) with effective value ((4 | 1) & 4) = 4 (1,1,0) with effective value ((4 | 4) & 1) = 0 (1,1,1) with effective value ((4 | 4) & 4) = 4 Xorbeauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5. **Example 2:** **Input:** nums = [15,45,20,2,34,35,5,44,32,30] **Output:** 34 **Explanation:** `The xorbeauty of the given array is 34.` **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109`","completion":"def xor_beauty(nums): n = len(nums) maxXOR = 1024 counter = [0] * maxXOR for num in nums: counter[num % maxXOR] += 1 xor_beauty = 0 for i in range(maxXOR): for j in range(i, maxXOR): k = (i | j) & (~(i ^ j)) if k < maxXOR and k >= j: count = counter[i] * counter[j] * (1 if i == j else 2) if k != i and k != j: count *= counter[k] xor_beauty ^= count return xor_beauty"},{"prompt":"an infinite binary tree where every node has two children, the nodes are labelled in row order. In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left. Given the `label` of a node in this tree, return the labels in the path from the root of the tree to the node with that `label`. **Example 1:** **Input:** label = 14 **Output:** [1,3,4,14] **Example 2:** **Input:** label = 26 **Output:** [1,2,6,10,26] **Constraints:** * `1 <= label <= 10^6`","completion":"def colorBorder(grid, row, col, color): def dfs(grid, row, col, current, color): if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != current: return grid[row][col] = color dfs(grid, row - 1, col, current, color) dfs(grid, row + 1, col, current, color) dfs(grid, row, col - 1, current, color) dfs(grid, row, col + 1, current, color) current = grid[row][col] if current == color: return grid dfs(grid, row, col, current, color + 1000) for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] > 1000: grid[i][j] -= 1000 return grid"},{"prompt":"You have a **browser** of one tab where you start on the `homepage` and you can visit another `url`, get back in the history number of `steps` or move forward in the history number of `steps`. Implement the `BrowserHistory` class: * `BrowserHistory(string homepage)` Initializes the object with the `homepage` of the browser. * `void visit(string url)` Visits `url` from the current page. It clears up all the forward history. * `string back(int steps)` Move `steps` back in history. If you can only return `x` steps in the history and `steps > x`, you will return only `x` steps. Return the current `url` after moving back in history **at most** `steps`. * `string forward(int steps)` Move `steps` forward in history. If you can only forward `x` steps in the history and `steps > x`, you will forward only `x` steps. Return the current `url` after forwarding in history **at most** `steps`. **Example:** **Input:** [ BrowserHistory , visit , visit , visit , back , back , forward , visit , forward , back , back ] [[ leetcode.com ],[ google.com ],[ facebook.com ],[ youtube.com ],[1],[1],[1],[ linkedin.com ],[2],[2],[7]] **Output:** [null,null,null,null, facebook.com , google.com , facebook.com ,null, linkedin.com , google.com , leetcode.com ] **Explanation:** BrowserHistory browserHistory = new BrowserHistory( leetcode.com ); browserHistory.visit( google.com ); // You are in leetcode.com . Visit google.com browserHistory.visit( facebook.com ); // You are in google.com . Visit facebook.com browserHistory.visit( youtube.com ); // You are in facebook.com . Visit youtube.com browserHistory.back(1); // You are in youtube.com , move back to facebook.com return facebook.com browserHistory.back(1); // You are in facebook.com , move back to google.com return google.com browserHistory.forward(1); // You are in google.com , move forward to facebook.com return facebook.com browserHistory.visit( linkedin.com ); // You are in facebook.com . Visit linkedin.com browserHistory.forward(2); // You are in linkedin.com , you cannot move forward any steps. browserHistory.back(2); // You are in linkedin.com , move back two steps to facebook.com then to google.com . return google.com browserHistory.back(7); // You are in google.com , you can move back only one step to leetcode.com . return leetcode.com **Constraints:** * `1 <= homepage.length <= 20` * `1 <= url.length <= 20` * `1 <= steps <= 100` * `homepage` and `url` consist of \'.\' or lower case English letters. * At most `5000` calls will be made to `visit`, `back`, and `forward`.","completion":"from collections import OrderedDict def sortString(s: str) -> str: freq_map = OrderedDict(sorted({c: s.count(c) for c in set(s)}.items())) result = [] while freq_map: for key in list(freq_map.keys()): result.append(key) freq_map[key] -= 1 if freq_map[key] == 0: del freq_map[key] for key in list(reversed(freq_map.keys())): result.append(key) freq_map[key] -= 1 if freq_map[key] == 0: del freq_map[key] return \\"\\".join(result)"},{"prompt":"Given an array `nums`. We define a running sum of an array as `runningSum[i] = sum(nums[0]...nums[i])`. Return the running sum of `nums`. **Example 1:** **Input:** nums = [1,2,3,4] **Output:** [1,3,6,10] **Explanation:** Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. **Example 2:** **Input:** nums = [1,1,1,1,1] **Output:** [1,2,3,4,5] **Explanation:** Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. **Example 3:** **Input:** nums = [3,1,2,10,1] **Output:** [3,4,6,16,17] **Constraints:** * `1 <= nums.length <= 1000` * `10^6 <= nums[i] <= 10^6`","completion":"def runningSum(nums): for i in range(1, len(nums)): nums[i] += nums[i - 1] return nums"},{"prompt":"You are given an array `points` representing integer coordinates of some points on a 2Dplane, where `points[i] = [xi, yi]`. The cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **manhattan distance** between them: `|xi xj| + |yi yj|`, where `|val|` denotes the absolute value of `val`. Return _the minimum cost to make all points connected._ All points are connected if there is **exactly one** simple path between any two points. **Example 1:** **Input:** points = [[0,0],[2,2],[3,10],[5,2],[7,0]] **Output:** 20 **Explanation:** We can connect the points as shown above to get the minimum cost of 20. Notice that there is a unique path between every pair of points. **Example 2:** **Input:** points = [[3,12],[2,5],[4,1]] **Output:** 18 **Constraints:** * `1 <= points.length <= 1000` * `106 <= xi, yi <= 106` * All pairs `(xi, yi)` are distinct.","completion":"def average(salary): min_salary = min(salary) max_salary = max(salary) sum_salaries = sum(salary) sum_salaries -= (min_salary + max_salary) return sum_salaries / (len(salary) - 2)"},{"prompt":"A dieter consumes `calories[i]` calories on the `i`th day. Given an integer `k`, for **every** consecutive sequence of `k` days (`calories[i], calories[i+1], ..., calories[i+k1]` for all `0 <= i <= nk`), they look at _T_, the total calories consumed during that sequence of `k` days (`calories[i] + calories[i+1] + ... + calories[i+k1]`): * If `T < lower`, they performed poorly on their diet and lose 1 point; * If `T > upper`, they performed well on their diet and gain 1 point; * Otherwise, they performed normally and there is no change in points. Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for `calories.length` days. Note that the total points can be negative. **Example 1:** **Input:** calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3 **Output:** 0 **Explanation**: Since k = 1, we consider each element of the array separately and compare it to lower and upper. calories[0] and calories[1] are less than lower so 2 points are lost. calories[3] and calories[4] are greater than upper so 2 points are gained. **Example 2:** **Input:** calories = [3,2], k = 2, lower = 0, upper = 1 **Output:** 1 **Explanation**: Since k = 2, we consider subarrays of length 2. calories[0] + calories[1] > upper so 1 point is gained. **Example 3:** **Input:** calories = [6,5,0,0], k = 2, lower = 1, upper = 5 **Output:** 0 **Explanation**: calories[0] + calories[1] > upper so 1 point is gained. lower <= calories[1] + calories[2] <= upper so no change in points. calories[2] + calories[3] < lower so 1 point is lost. **Constraints:** * `1 <= k <= calories.length <= 10^5` * `0 <= calories[i] <= 20000` * `0 <= lower <= upper`","completion":"def dietPlanPerformance(calories, k, lower, upper): points = 0 T = 0 for i in range(len(calories)): T += calories[i] if i >= k: T -= calories[i-k] if i >= k-1: if T < lower: points -= 1 if T > upper: points += 1 return points"},{"prompt":"You are given an integer `num`. You will apply the following steps exactly **two** times: * Pick a digit `x (0 <= x <= 9)`. * Pick another digit `y (0 <= y <= 9)`. The digit `y` can be equal to `x`. * Replace all the occurrences of `x` in the decimal representation of `num` by `y`. * The new integer **cannot** have any leading zeros, also the new integer **cannot** be 0. Let `a` and `b` be the results of applying the operations to `num` the first and second times, respectively. Return _the max difference_ between `a` and `b`. **Example 1:** **Input:** num = 555 **Output:** 888 **Explanation:** The first time pick x = 5 and y = 9 and store the new integer in a. The second time pick x = 5 and y = 1 and store the new integer in b. We have now a = 999 and b = 111 and max difference = 888 **Example 2:** **Input:** num = 9 **Output:** 8 **Explanation:** The first time pick x = 9 and y = 9 and store the new integer in a. The second time pick x = 9 and y = 1 and store the new integer in b. We have now a = 9 and b = 1 and max difference = 8 **Constraints:** * `1 <= num <= 10`8","completion":"def max_diff(num): a, b = -1, -1 num_str = str(num) for c in num_str: if a == -1 and c != \'9\': a = int(c) if b == -1 and c > \'1\': b = int(c) if a != -1 and b != -1: break result = 0 for c in num_str: if int(c) == a: result = result * 10 + 9 elif int(c) == b: result = result * 10 + (1 if c == num_str[0] else 0) else: result = result * 10 + int(c) return result - num"},{"prompt":"You are given a **0indexed** integer array `nums` of length `n`. A **split** at an index `i` where `0 <= i <= n 2` is called **valid** if the product of the first `i + 1` elements and the product of the remaining elements are coprime. * For example, if `nums = [2, 3, 3]`, then a split at the index `i = 0` is valid because `2` and `9` are coprime, while a split at the index `i = 1` is not valid because `6` and `3` are not coprime. A split at the index `i = 2` is not valid because `i == n 1`. Return _the smallest index_ `i` _at which the array can be split validly or_ `1` _if there is no such split_. Two values `val1` and `val2` are coprime if `gcd(val1, val2) == 1` where `gcd(val1, val2)` is the greatest common divisor of `val1` and `val2`. **Example 1:** **Input:** nums = [4,7,8,15,3,5] **Output:** 2 **Explanation:** The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i. The only valid split is at index 2. **Example 2:** **Input:** nums = [4,7,15,8,3,5] **Output:** 1 **Explanation:** The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i. There is no valid split. **Constraints:** * `n == nums.length` * `1 <= n <= 104` * `1 <= nums[i] <= 106`","completion":"def find_valid_split(nums): n = len(nums) prefix = [0] * n suffix = [0] * n prefix[0] = nums[0] suffix[-1] = nums[-1] for i in range(1, n): prefix[i] = prefix[i - 1] * nums[i] for i in range(n - 2, -1, -1): suffix[i] = suffix[i + 1] * nums[i] for i in range(n - 1): if gcd(prefix[i], suffix[i + 1]) == 1: return i return -1 def gcd(a, b): return a if b == 0 else gcd(b, a % b)"},{"prompt":"You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane. **Example 1:** **Input:** coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] **Output:** true **Example 2:** **Input:** coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] **Output:** false **Constraints:** * `2 <= coordinates.length <= 1000` * `coordinates[i].length == 2` * `10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4` * `coordinates` contains no duplicate point.","completion":"def findBestValue(arr, target): left = 0 right = max(arr) result = -1 min_diff = float(\'inf\') while left <= right: mid = left + (right - left) // 2 total_sum = sum(min(x, mid) for x in arr) if total_sum == target: return mid elif total_sum > target: right = mid - 1 else: left = mid + 1 if abs(target - total_sum) < min_diff or ( abs(target - total_sum) == min_diff and mid < result): min_diff = abs(target - total_sum) result = mid return result"},{"prompt":"You are given a stream of points on the XY plane. Design an algorithm that: * **Adds** new points from the stream into a data structure. **Duplicate** points are allowed and should be treated as different points. * Given a query point, **counts** the number of ways to choose three points from the data structure such that the three points and the query point form an **axisaligned square** with **positive area**. An **axisaligned square** is a square whose edges are all the same length and are either parallel or perpendicular to the xaxis and yaxis. Implement the `DetectSquares` class: * `DetectSquares()` Initializes the object with an empty data structure. * `void add(int[] point)` Adds a new point `point = [x, y]` to the data structure. * `int count(int[] point)` Counts the number of ways to form **axisaligned squares** with point `point = [x, y]` as described above. **Example 1:** **Input** [ DetectSquares , add , add , add , count , count , add , count ] [[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]] **Output** [null, null, null, null, 1, 0, null, 2] **Explanation** DetectSquares detectSquares = new DetectSquares(); detectSquares.add([3, 10]); detectSquares.add([11, 2]); detectSquares.add([3, 2]); detectSquares.count([11, 10]); // return 1. You can choose: // The first, second, and third points detectSquares.count([14, 8]); // return 0. The query point cannot form a square with any points in the data structure. detectSquares.add([11, 2]); // Adding duplicate points is allowed. detectSquares.count([11, 10]); // return 2. You can choose: // The first, second, and third points // The first, third, and fourth points **Constraints:** * `point.length == 2` * `0 <= x, y <= 1000` * At most `3000` calls **in total** will be made to `add` and `count`.","completion":"from math import ceil def min_skips(dist, speed, hours_before): n = len(dist) dp = [[1e6] * (n + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n + 1): dp[i][0] = ceil(dp[i - 1][0] + dist[i - 1] / speed) for i in range(1, n + 1): for skip in range(1, i + 1): dp[i][skip] = min(dp[i][skip], dp[i - 1][skip - 1] + dist[i - 1] / speed) dp[i][skip] = min(dp[i][skip], ceil(dp[i - 1][skip] + dist[i - 1] / speed)) for skip in range(n + 1): if dp[n][skip] <= hours_before: return skip return -1"},{"prompt":"You are given a string `s` and array `queries` where `queries[i] = [lefti, righti, ki]`. We may rearrange the substring `s[lefti...righti]` for each query and then choose up to `ki` of them to replace with any lowercase English letter. If the substring is possible to be a palindrome string after the operations above, the result of the query is `true`. Otherwise, the result is `false`. Return a boolean array `answer` where `answer[i]` is the result of the `ith` query `queries[i]`. Note that each letter is counted individually for replacement, so if, for example `s[lefti...righti] = aaa `, and `ki = 2`, we can only replace two of the letters. Also, note that no query modifies the initial string `s`. **Example :** **Input:** s = abcda , queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] **Output:** [true,false,false,true,true] **Explanation:** queries[0]: substring = d , is palidrome. queries[1]: substring = bc , is not palidrome. queries[2]: substring = abcd , is not palidrome after replacing only 1 character. queries[3]: substring = abcd , could be changed to abba which is palidrome. Also this can be changed to baab first rearrange it bacd then replace cd with ab . queries[4]: substring = abcda , could be changed to abcba which is palidrome. **Example 2:** **Input:** s = lyb , queries = [[0,1,0],[2,2,1]] **Output:** [false,true] **Constraints:** * `1 <= s.length, queries.length <= 105` * `0 <= lefti <= righti < s.length` * `0 <= ki <= s.length` * `s` consists of lowercase English letters.","completion":"def canMakePaliQueries(s, queries): answer = [] prefixSum = [0] * (len(s) + 1) for i in range(len(s)): prefixSum[i + 1] = prefixSum[i] ^ (1 << (ord(s[i]) - ord(\'a\'))) for query in queries: left, right, k = query diffCount = bin(prefixSum[right + 1] ^ prefixSum[left]).count(\'1\') answer.append((diffCount // 2) <= k) return answer"},{"prompt":"You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array `sweetness`. You want to share the chocolate with your `k` friends so you start cutting the chocolate bar into `k + 1` pieces using `k` cuts, each piece consists of some **consecutive** chunks. Being generous, you will eat the piece with the **minimum total sweetness** and give the other pieces to your friends. Find the **maximum total sweetness** of the piece you can get by cutting the chocolate bar optimally. **Example 1:** **Input:** sweetness = [1,2,3,4,5,6,7,8,9], k = 5 **Output:** 6 **Explanation:** You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9] **Example 2:** **Input:** sweetness = [5,6,7,8,9,1,2,3,4], k = 8 **Output:** 1 **Explanation:** There is only one way to cut the bar into 9 pieces. **Example 3:** **Input:** sweetness = [1,2,2,1,2,2,1,2,2], k = 2 **Output:** 5 **Explanation:** You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2] **Constraints:** * `0 <= k < sweetness.length <= 104` * `1 <= sweetness[i] <= 105`","completion":"def replaceElements(arr): n = len(arr) maxElement = -1 for i in range(n - 1, -1, -1): temp = arr[i] arr[i] = maxElement maxElement = max(maxElement, temp) return arr"},{"prompt":"Alice and Bob are traveling to Rome for separate business meetings. You are given 4 strings `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob`. Alice will be in the city from the dates `arriveAlice` to `leaveAlice` (**inclusive**), while Bob will be in the city from the dates `arriveBob` to `leaveBob` (**inclusive**). Each will be a 5character string in the format `MMDD `, corresponding to the month and day of the date. Return _the total number of days that Alice and Bob are in Rome together._ You can assume that all dates occur in the **same** calendar year, which is **not** a leap year. Note that the number of days per month can be represented as: `[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`. **Example 1:** **Input:** arriveAlice = 0815 , leaveAlice = 0818 , arriveBob = 0816 , leaveBob = 0819 **Output:** 3 **Explanation:** Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3. **Example 2:** **Input:** arriveAlice = 1001 , leaveAlice = 1031 , arriveBob = 1101 , leaveBob = 1231 **Output:** 0 **Explanation:** There is no day when Alice and Bob are in Rome together, so we return 0. **Constraints:** * All dates are provided in the format `MMDD `. * Alice and Bob\'s arrival dates are **earlier than or equal to** their leaving dates. * The given dates are valid dates of a **nonleap** year.","completion":"def days_together(arrive_alice, leave_alice, arrive_bob, leave_bob): days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] def date_to_days(date): month, day = map(int, date.split(\'-\')) return sum(days_in_month[:month]) + day arrive_days_alice = date_to_days(arrive_alice) leave_days_alice = date_to_days(leave_alice) arrive_days_bob = date_to_days(arrive_bob) leave_days_bob = date_to_days(leave_bob) common_start_date = max(arrive_days_alice, arrive_days_bob) common_end_date = min(leave_days_alice, leave_days_bob) return max(0, common_end_date - common_start_date + 1)"},{"prompt":"You are given a **0indexed** integer array `nums`. We say that an integer x is **expressible** from `nums` if there exist some integers `0 <= index1 < index2 < ... < indexk < nums.length` for which `nums[index1] | nums[index2] | ... | nums[indexk] = x`. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of `nums`. Return _the minimum **positive nonzero integer** that is not_ _expressible from_ `nums`. **Example 1:** **Input:** nums = [2,1] **Output:** 4 **Explanation:** 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4. **Example 2:** **Input:** nums = [5,3,2] **Output:** 1 **Explanation:** We can show that 1 is the smallest number that is not expressible. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109`","completion":"def min_non_expressible_integer(nums): result = 1 nums.sort() for num in nums: if num > result: break result += num return result"},{"prompt":"Given an array `arr` of positive integers, consider all binary trees such that: * Each node has either `0` or `2` children; * The values of `arr` correspond to the values of each **leaf** in an inorder traversal of the tree. * The value of each nonleaf node is equal to the product of the largest leaf value in its left and right subtree, respectively. Among all possible binary trees considered, return _the smallest possible sum of the values of each nonleaf node_. It is guaranteed this sum fits into a **32bit** integer. A node is a **leaf** if and only if it has zero children. **Example 1:** **Input:** arr = [6,2,4] **Output:** 32 **Explanation:** There are two possible trees shown. The first has a nonleaf node sum 36, and the second has nonleaf node sum 32. **Example 2:** **Input:** arr = [4,11] **Output:** 44 **Constraints:** * `2 <= arr.length <= 40` * `1 <= arr[i] <= 15` * It is guaranteed that the answer fits into a **32bit** signed integer (i.e., it is less than 231).","completion":"import heapq def lastStoneWeight(stones): stones = [-stone for stone in stones] heapq.heapify(stones) while len(stones) > 1: y = -heapq.heappop(stones) x = -heapq.heappop(stones) if x != y: heapq.heappush(stones, -(y - x)) return -stones[0] if stones else 0"},{"prompt":"You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`. A pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion. Return _the length longest chain which can be formed_. You do not need to use up all the given intervals. You can select pairs in any order. **Example 1:** **Input:** pairs = [[1,2],[2,3],[3,4]] **Output:** 2 **Explanation:** The longest chain is [1,2] > [3,4]. **Example 2:** **Input:** pairs = [[1,2],[7,8],[4,5]] **Output:** 3 **Explanation:** The longest chain is [1,2] > [4,5] > [7,8]. **Constraints:** * `n == pairs.length` * `1 <= n <= 1000` * `1000 <= lefti < righti <= 1000`","completion":"def findLongestChain(pairs): pairs.sort(key=lambda x: x[1]) max_chain_length = 0 last_right = float(\'-inf\') for pair in pairs: if pair[0] > last_right: last_right = pair[1] max_chain_length += 1 return max_chain_length"},{"prompt":"Given a string `date` representing a [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar) date formatted as `YYYYMMDD`, return _the day number of the year_. **Example 1:** **Input:** date = 20190109 **Output:** 9 **Explanation:** Given date is the 9th day of the year in 2019. **Example 2:** **Input:** date = 20190210 **Output:** 41 **Constraints:** * `date.length == 10` * `date[4] == date[7] == \'\'`, and all other `date[i]`\'s are digits * `date` represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019.","completion":"def is_leap_year(year: int) -> bool: return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) def day_of_year(date: str) -> int: days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] year, month, day = int(date[:4]), int(date[5:7]), int(date[8:]) if is_leap_year(year): days_in_month[1] = 29 return sum(days_in_month[:month-1]) + day"},{"prompt":"You are given a **binary string** `s`, and a **2D** integer array `queries` where `queries[i] = [firsti, secondi]`. For the `ith` query, find the **shortest substring** of `s` whose **decimal value**, `val`, yields `secondi` when **bitwise XORed** with `firsti`. In other words, `val ^ firsti == secondi`. The answer to the `ith` query is the endpoints (**0indexed**) of the substring `[lefti, righti]` or `[1, 1]` if no such substring exists. If there are multiple answers, choose the one with the **minimum** `lefti`. _Return an array_ `ans` _where_ `ans[i] = [lefti, righti]` _is the answer to the_ `ith` _query._ A **substring** is a contiguous nonempty sequence of characters within a string. **Example 1:** **Input:** s = 101101 , queries = [[0,5],[1,2]] **Output:** [[0,2],[2,3]] **Explanation:** For the first query the substring in range `[0,2]` is ** 101 ** which has a decimal value of **`5`**, and **`5 ^ 0 = 5`**, hence the answer to the first query is `[0,2]`. In the second query, the substring in range `[2,3]` is ** 11 ,** and has a decimal value of **3**, and **3 `^ 1 = 2`**. So, `[2,3]` is returned for the second query. **Example 2:** **Input:** s = 0101 , queries = [[12,8]] **Output:** [[1,1]] **Explanation:** In this example there is no substring that answers the query, hence `[1,1] is returned`. **Example 3:** **Input:** s = 1 , queries = [[4,5]] **Output:** [[0,0]] **Explanation:** For this example, the substring in range `[0,0]` has a decimal value of **`1`**, and **`1 ^ 4 = 5`**. So, the answer is `[0,0]`. **Constraints:** * `1 <= s.length <= 104` * `s[i]` is either `\'0\'` or `\'1\'`. * `1 <= queries.length <= 105` * `0 <= firsti, secondi <= 109`","completion":"from math import log2 def shortestSubstringQueries(s, queries): n = len(s) dp = {} val = 0 mask = 0 for i in range(n): mask |= 1 << int(s[i]) val = (val << 1) | int(s[i]) for j in range(10): if i + 1 - (1 << j) >= 0: newVal = val & ((1 << (j + 1)) - 1) if newVal not in dp: dp[newVal] = i + 1 - (1 << j) ans = [] for query in queries: target = query[0] ^ query[1] if target in dp: ans.append([dp[target], dp[target] + int(log2(target))]) else: ans.append([-1, -1]) return ans"},{"prompt":"You are given two integer arrays `nums1` and `nums2` of length `n`. The **XOR sum** of the two integer arrays is `(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n 1] XOR nums2[n 1])` (**0indexed**). * For example, the **XOR sum** of `[1,2,3]` and `[3,2,1]` is equal to `(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4`. Rearrange the elements of `nums2` such that the resulting **XOR sum** is **minimized**. Return _the **XOR sum** after the rearrangement_. **Example 1:** **Input:** nums1 = [1,2], nums2 = [2,3] **Output:** 2 **Explanation:** Rearrange `nums2` so that it becomes `[3,2]`. The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2. **Example 2:** **Input:** nums1 = [1,0,3], nums2 = [5,3,4] **Output:** 8 **Explanation:** Rearrange `nums2` so that it becomes `[5,4,3]`. The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8. **Constraints:** * `n == nums1.length` * `n == nums2.length` * `1 <= n <= 14` * `0 <= nums1[i], nums2[i] <= 107`","completion":"def max_score(a: int, b: int, c: int) -> int: return (a + b + c - max(a, b, c)) // 2"},{"prompt":"You are given a 2D integer array `trees` where `trees[i] = [xi, yi]` represents the location of the `ith` tree in the garden. You are asked to fence the entire garden using the minimum length of rope possible. The garden is wellfenced only if **all the trees are enclosed** and the rope used **forms a perfect circle**. A tree is considered enclosed if it is inside or on the border of the circle. More formally, you must form a circle using the rope with a center `(x, y)` and radius `r` where all trees lie inside or on the circle and `r` is **minimum**. Return _the center and radius of the circle as a length 3 array_ `[x, y, r]`_._ Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] **Output:** [2.00000,2.00000,2.00000] **Explanation:** The fence will have center = (2, 2) and radius = 2 **Example 2:** **Input:** trees = [[1,2],[2,2],[4,2]] **Output:** [2.50000,2.00000,1.50000] **Explanation:** The fence will have center = (2.5, 2) and radius = 1.5 **Constraints:** * `1 <= trees.length <= 3000` * `trees[i].length == 2` * `0 <= xi, yi <= 3000`","completion":"def max_happy_groups(batchSize, groups): remainders = [0] * batchSize for g in groups: remainders[g % batchSize] += 1 result = remainders[0] i, j = 1, batchSize - 1 while i < j: result += min(remainders[i], remainders[j]) i += 1 j -= 1 if i == j: result += remainders[i] // 2 return result"},{"prompt":"Given a valid (IPv4) IP `address`, return a defanged version of that IP address. A _defanged IP address_ replaces every period `. ` with `[.] `. **Example 1:** **Input:** address = 1.1.1.1 **Output:** 1[.]1[.]1[.]1 **Example 2:** **Input:** address = 255.100.50.0 **Output:** 255[.]100[.]50[.]0 **Constraints:** * The given `address` is a valid IPv4 address.","completion":"def defangIPaddr(address: str) -> str: return address.replace(\'.\', \'[.]\')"},{"prompt":"Given a binary tree `root` and an integer `target`, delete all the **leaf nodes** with value `target`. Note that once you delete a leaf node with value `target`**,** if its parent node becomes a leaf node and has the value `target`, it should also be deleted (you need to continue doing that until you cannot). **Example 1:** **Input:** root = [1,2,3,2,null,2,4], target = 2 **Output:** [1,null,3,null,4] **Explanation:** Leaf nodes in green with value (target = 2) are removed (Picture in left). After removing, new nodes become leaf nodes with value (target = 2) (Picture in center). **Example 2:** **Input:** root = [1,3,3,3,2], target = 3 **Output:** [1,3,null,null,2] **Example 3:** **Input:** root = [1,2,null,2,null,2], target = 2 **Output:** [1] **Explanation:** Leaf nodes in green with value (target = 2) are removed at each step. **Constraints:** * The number of nodes in the tree is in the range `[1, 3000]`. * `1 <= Node.val, target <= 1000`","completion":"from heapq import heappush, heappop def maxProbability(n, edges, succProb, start, end): graph = [[] for _ in range(n)] for i in range(len(edges)): a, b = edges[i] graph[a].append((b, succProb[i])) graph[b].append((a, succProb[i])) max_prob = [0] * n max_prob[start] = 1 pq = [(-1, start)] while pq: prob, node = heappop(pq) if node == end: return -prob if -prob < max_prob[node]: continue for neighbor, edge_prob in graph[node]: new_prob = -prob * edge_prob if new_prob > max_prob[neighbor]: max_prob[neighbor] = new_prob heappush(pq, (-new_prob, neighbor)) return 0"},{"prompt":"You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that: * `subtexti` is a **nonempty** string. * The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`). * `subtexti == subtextk i + 1` for all valid values of `i` (i.e., `1 <= i <= k`). Return the largest possible value of `k`. **Example 1:** **Input:** text = ghiabcdefhelloadamhelloabcdefghi **Output:** 7 **Explanation:** We can split the string on (ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi) . **Example 2:** **Input:** text = merchant **Output:** 1 **Explanation:** We can split the string on (merchant) . **Example 3:** **Input:** text = antaprezatepzapreanta **Output:** 11 **Explanation:** We can split the string on (a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a) . **Constraints:** * `1 <= text.length <= 1000` * `text` consists only of lowercase English characters.","completion":"from collections import defaultdict def maxEqualRowsAfterFlips(matrix): count = defaultdict(int) for row in matrix: row_str = \\"\\".join(str(row[0] ^ val) for val in row) count[row_str] += 1 return max(count.values())"},{"prompt":"There is a special keyboard with **all keys in a single row**. Given a string `keyboard` of length `26` indicating the layout of the keyboard (indexed from `0` to `25`). Initially, your finger is at index `0`. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index `i` to index `j` is `|i j|`. You want to type a string `word`. Write a function to calculate how much time it takes to type it with one finger. **Example 1:** **Input:** keyboard = abcdefghijklmnopqrstuvwxyz , word = cba **Output:** 4 **Explanation:** The index moves from 0 to 2 to write \'c\' then to 1 to write \'b\' then to 0 again to write \'a\'. Total time = 2 + 1 + 1 = 4. **Example 2:** **Input:** keyboard = pqrstuvwxyzabcdefghijklmno , word = leetcode **Output:** 73 **Constraints:** * `keyboard.length == 26` * `keyboard` contains each English lowercase letter exactly once in some order. * `1 <= word.length <= 104` * `word[i]` is an English lowercase letter.","completion":"def calculate_time(keyboard: str, word: str) -> int: time = 0 prev_index = 0 char_to_index = {char: i for i, char in enumerate(keyboard)} for c in word: time += abs(char_to_index[c] - prev_index) prev_index = char_to_index[c] return time"},{"prompt":"Given an integer `k`, _return the minimum number of Fibonacci numbers whose sum is equal to_ `k`. The same Fibonacci number can be used multiple times. The Fibonacci numbers are defined as: * `F1 = 1` * `F2 = 1` * `Fn = Fn1 + Fn2` for `n > 2.` It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to `k`. **Example 1:** **Input:** k = 7 **Output:** 2 **Explanation:** The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... For k = 7 we can use 2 + 5 = 7. **Example 2:** **Input:** k = 10 **Output:** 2 **Explanation:** For k = 10 we can use 2 + 8 = 10. **Example 3:** **Input:** k = 19 **Output:** 3 **Explanation:** For k = 19 we can use 1 + 5 + 13 = 19. **Constraints:** * `1 <= k <= 109`","completion":"from collections import deque def shortestPath(grid, k): m, n = len(grid), len(grid[0]) queue = deque([(0, 0, 0, k)]) visited = [[[False] * (k + 1) for _ in range(n)] for _ in range(m)] while queue: x, y, step, remaining_k = queue.popleft() if x == m - 1 and y == n - 1: return step if visited[x][y][remaining_k]: continue visited[x][y][remaining_k] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 1 and remaining_k > 0: queue.append((nx, ny, step + 1, remaining_k - 1)) elif grid[nx][ny] == 0: queue.append((nx, ny, step + 1, remaining_k)) return -1"},{"prompt":"You have `n` robots. You are given two **0indexed** integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`. The **total cost** of running `k` chosen robots is equal to `max(chargeTimes) + k * sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots. Return _the **maximum** number of **consecutive** robots you can run such that the total cost **does not** exceed_ `budget`. **Example 1:** **Input:** chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25 **Output:** 3 **Explanation:** It is possible to run all individual and consecutive pairs of robots within budget. To obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25. It can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3. **Example 2:** **Input:** chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19 **Output:** 0 **Explanation:** No robot can be run that does not exceed the budget, so we return 0. **Constraints:** * `chargeTimes.length == runningCosts.length == n` * `1 <= n <= 5 * 104` * `1 <= chargeTimes[i], runningCosts[i] <= 105` * `1 <= budget <= 1015`","completion":"def max_consecutive_robots(charge_times, running_costs, budget): n = len(charge_times) max_robots = 0 for i in range(n): max_charge = 0 running_sum = 0 for j in range(i, n): max_charge = max(max_charge, charge_times[j]) running_sum += running_costs[j] cost = max_charge + running_sum * (j - i + 1) if cost <= budget: max_robots = max(max_robots, j - i + 1) else: break return max_robots"},{"prompt":"Given an array of integers `arr` and an integer `k`. Find the _least number of unique integers_ after removing **exactly** `k` elements**.** **Example 1:** **Input:** arr = [5,5,4], k = 1 **Output:** 1 **Explanation**: Remove the single 4, only 5 is left. **Example 2:** **Input:** arr = [4,3,1,1,3,3,2], k = 3 **Output:** 2 **Explanation**: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left. **Constraints:** * `1 <= arr.length <= 10^5` * `1 <= arr[i] <= 10^9` * `0 <= k <= arr.length`","completion":"from collections import Counter import heapq def findLeastNumOfUniqueInts(arr, k): count = Counter(arr) pq = list(count.values()) heapq.heapify(pq) while k > 0: k -= heapq.heappop(pq) return len(pq) if k == 0 else len(pq) + 1"},{"prompt":"Given four integers `sx`, `sy`, `tx`, and `ty`, return `true` _if it is possible to convert the point_ `(sx, sy)` _to the point_ `(tx, ty)` _through some operations__, or_ `false` _otherwise_. The allowed operation on some point `(x, y)` is to convert it to either `(x, x + y)` or `(x + y, y)`. **Example 1:** **Input:** sx = 1, sy = 1, tx = 3, ty = 5 **Output:** true **Explanation:** One series of moves that transforms the starting point to the target is: (1, 1) > (1, 2) (1, 2) > (3, 2) (3, 2) > (3, 5) **Example 2:** **Input:** sx = 1, sy = 1, tx = 2, ty = 2 **Output:** false **Example 3:** **Input:** sx = 1, sy = 1, tx = 1, ty = 1 **Output:** true **Constraints:** * `1 <= sx, sy, tx, ty <= 109`","completion":"def max_chunks_to_sorted(arr): max_so_far, count = 0, 0 for i, val in enumerate(arr): max_so_far = max(max_so_far, val) if max_so_far == i: count += 1 return count"},{"prompt":"You are given a floatingpoint number `hour`, representing the amount of time you have to reach the office. To commute to the office, you must take `n` trains in sequential order. You are also given an integer array `dist` of length `n`, where `dist[i]` describes the distance (in kilometers) of the `ith` train ride. Each train can only depart at an integer hour, so you may need to wait in between each train ride. * For example, if the `1st` train ride takes `1.5` hours, you must wait for an additional `0.5` hours before you can depart on the `2nd` train ride at the 2 hour mark. Return _the **minimum positive integer** speed **(in kilometers per hour)** that all the trains must travel at for you to reach the office on time, or_ `1` _if it is impossible to be on time_. Tests are generated such that the answer will not exceed `107` and `hour` will have **at most two digits after the decimal point**. **Example 1:** **Input:** dist = [1,3,2], hour = 6 **Output:** 1 **Explanation:** At speed 1: The first train ride takes 1/1 = 1 hour. Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours. Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours. You will arrive at exactly the 6 hour mark. **Example 2:** **Input:** dist = [1,3,2], hour = 2.7 **Output:** 3 **Explanation:** At speed 3: The first train ride takes 1/3 = 0.33333 hours. Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour. Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours. You will arrive at the 2.66667 hour mark. **Example 3:** **Input:** dist = [1,3,2], hour = 1.9 **Output:** 1 **Explanation:** It is impossible because the earliest the third train can depart is at the 2 hour mark. **Constraints:** * `n == dist.length` * `1 <= n <= 105` * `1 <= dist[i] <= 105` * `1 <= hour <= 109` * There will be at most two digits after the decimal point in `hour`.","completion":"from math import ceil def minSpeedOnTime(dist, hour): max_time = hour - len(dist) + 1 lower, upper = 1.0, 1e7 while upper - lower >= 1e-9: mid = (lower + upper) / 2 time_taken = sum(ceil(d / mid) - (0 if i == len(dist) - 1 else 1) for i, d in enumerate(dist)) if time_taken <= max_time: upper = mid else: lower = mid return ceil(lower) if lower <= 1e7 else -1"},{"prompt":"You are given an integer array `nums` and two integers `limit` and `goal`. The array `nums` has an interesting property that `abs(nums[i]) <= limit`. Return _the minimum number of elements you need to add to make the sum of the array equal to_ `goal`. The array must maintain its property that `abs(nums[i]) <= limit`. Note that `abs(x)` equals `x` if `x >= 0`, and `x` otherwise. **Example 1:** **Input:** nums = [1,1,1], limit = 3, goal = 4 **Output:** 2 **Explanation:** You can add 2 and 3, then the sum of the array will be 1 1 + 1 2 3 = 4. **Example 2:** **Input:** nums = [1,10,9,1], limit = 100, goal = 0 **Output:** 1 **Constraints:** * `1 <= nums.length <= 105` * `1 <= limit <= 106` * `limit <= nums[i] <= limit` * `109 <= goal <= 109`","completion":"def minElements(nums, limit, goal): sum_nums = sum(nums) diff = abs(goal - sum_nums) return (diff + limit - 1) // limit"},{"prompt":"For two strings `s` and `t`, we say `t` divides `s` if and only if `s = t + ... + t` (i.e., `t` is concatenated with itself one or more times). Given two strings `str1` and `str2`, return _the largest string_ `x` _such that_ `x` _divides both_ `str1` _and_ `str2`. **Example 1:** **Input:** str1 = ABCABC , str2 = ABC **Output:** ABC **Example 2:** **Input:** str1 = ABABAB , str2 = ABAB **Output:** AB **Example 3:** **Input:** str1 = LEET , str2 = CODE **Output:** **Constraints:** * `1 <= str1.length, str2.length <= 1000` * `str1` and `str2` consist of English uppercase letters.","completion":"def prefixesDivBy5(nums): result = [] current = 0 for num in nums: current = ((current << 1) | num) % 5 result.append(current == 0) return result"},{"prompt":"You are given a string `s` that consists of the digits `\'1\'` to `\'9\'` and two integers `k` and `minLength`. A partition of `s` is called **beautiful** if: * `s` is partitioned into `k` nonintersecting substrings. * Each substring has a length of **at least** `minLength`. * Each substring starts with a **prime** digit and ends with a **nonprime** digit. Prime digits are `\'2\'`, `\'3\'`, `\'5\'`, and `\'7\'`, and the rest of the digits are nonprime. Return _the number of **beautiful** partitions of_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** **Input:** s = 23542185131 , k = 3, minLength = 2 **Output:** 3 **Explanation:** There exists three ways to create a beautiful partition: 2354 | 218 | 5131 2354 | 21851 | 31 2354218 | 51 | 31 **Example 2:** **Input:** s = 23542185131 , k = 3, minLength = 3 **Output:** 1 **Explanation:** There exists one way to create a beautiful partition: 2354 | 218 | 5131 . **Example 3:** **Input:** s = 3312958 , k = 3, minLength = 1 **Output:** 1 **Explanation:** There exists one way to create a beautiful partition: 331 | 29 | 58 . **Constraints:** * `1 <= k, minLength <= s.length <= 1000` * `s` consists of the digits `\'1\'` to `\'9\'`.","completion":"def numBeautifulPartitions(s: str, k: int, minLength: int) -> int: MOD = 10**9 + 7 primes = {\'2\', \'3\', \'5\', \'7\'} n = len(s) dp = [[0] * (k + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(1, k + 1): for l in range(minLength, i + 1): if i - l >= j - 1 and s[i - l] in primes and s[i - 1] not in primes: dp[i][j] += dp[i - l][j - 1] if dp[i][j] >= MOD: dp[i][j] -= MOD return dp[n][k]"},{"prompt":"You are given a 2D integer array `groups` of length `n`. You are also given an integer array `nums`. You are asked if you can choose `n` **disjoint** subarrays from the array `nums` such that the `ith` subarray is equal to `groups[i]` (**0indexed**), and if `i > 0`, the `(i1)th` subarray appears **before** the `ith` subarray in `nums` (i.e. the subarrays must be in the same order as `groups`). Return `true` _if you can do this task, and_ `false` _otherwise_. Note that the subarrays are **disjoint** if and only if there is no index `k` such that `nums[k]` belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array. **Example 1:** **Input:** groups = [[1,1,1],[3,2,0]], nums = [1,1,0,1,1,1,3,2,0] **Output:** true **Explanation:** You can choose the 0th subarray as [1,1,0,**1,1,1**,3,2,0] and the 1st one as [1,1,0,1,1,1,**3,2,0**]. These subarrays are disjoint as they share no common nums[k] element. **Example 2:** **Input:** groups = [[10,2],[1,2,3,4]], nums = [1,2,3,4,10,2] **Output:** false **Explanation:** Note that choosing the subarrays [**1,2,3,4**,10,2] and [1,2,3,4,**10,2**] is incorrect because they are not in the same order as in groups. [10,2] must come before [1,2,3,4]. **Example 3:** **Input:** groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7] **Output:** false **Explanation:** Note that choosing the subarrays [7,7,**1,2,3**,4,7,7] and [7,7,1,2,**3,4**,7,7] is invalid because they are not disjoint. They share a common elements nums[4] (0indexed). **Constraints:** * `groups.length == n` * `1 <= n <= 103` * `1 <= groups[i].length, sum(groups[i].length) <= 103` * `1 <= nums.length <= 103` * `107 <= groups[i][j], nums[k] <= 107`","completion":"def max_k_repeating(sequence, word): max_k = 0 seq_length = len(sequence) word_length = len(word) for i in range(seq_length - word_length + 1): k = 0 while sequence[i:i + word_length * (k + 1)] == word * (k + 1): k += 1 max_k = max(max_k, k) return max_k"},{"prompt":"You are given a binary string `s`. In one second, **all** occurrences of `01 ` are **simultaneously** replaced with `10 `. This process **repeats** until no occurrences of `01 ` exist. Return _the number of seconds needed to complete this process._ **Example 1:** **Input:** s = 0110101 **Output:** 4 **Explanation:** After one second, s becomes 1011010 . After another second, s becomes 1101100 . After the third second, s becomes 1110100 . After the fourth second, s becomes 1111000 . No occurrence of 01 exists any longer, and the process needed 4 seconds to complete, so we return 4. **Example 2:** **Input:** s = 11100 **Output:** 0 **Explanation:** No occurrence of 01 exists in s, and the processes needed 0 seconds to complete, so we return 0. **Constraints:** * `1 <= s.length <= 1000` * `s[i]` is either `\'0\'` or `\'1\'`.","completion":"def find_seconds_to_transform(s: str) -> int: cnt_0, cnt_1 = 0, 0 for c in s: if c == \'0\': cnt_0 += 1 else: cnt_1 += 1 return min(cnt_0, cnt_1)"},{"prompt":"There is only one character `\'A\'` on the screen of a notepad. You can perform one of two operations on this notepad for each step: * Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). * Paste: You can paste the characters which are copied last time. Given an integer `n`, return _the minimum number of operations to get the character_ `\'A\'` _exactly_ `n` _times on the screen_. **Example 1:** **Input:** n = 3 **Output:** 3 **Explanation:** Initially, we have one character \'A\'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get \'AA\'. In step 3, we use Paste operation to get \'AAA\'. **Example 2:** **Input:** n = 1 **Output:** 0 **Constraints:** * `1 <= n <= 1000`","completion":"def min_steps(n): result = 0 i = 2 while i <= n: while n % i == 0: result += i n //= i i += 1 return result"},{"prompt":"We run a preorder depthfirst search (DFS) on the `root` of a binary tree. At each node in this traversal, we output `D` dashes (where `D` is the depth of this node), then we output the value of this node. If the depth of a node is `D`, the depth of its immediate child is `D + 1`. The depth of the `root` node is `0`. If a node has only one child, that child is guaranteed to be **the left child**. Given the output `traversal` of this traversal, recover the tree and return _its_ `root`. **Example 1:** **Input:** traversal = 1234567 **Output:** [1,2,5,3,4,6,7] **Example 2:** **Input:** traversal = 1234567 **Output:** [1,2,5,3,null,6,null,4,null,7] **Example 3:** **Input:** traversal = 14013499088 **Output:** [1,401,null,349,88,90] **Constraints:** * The number of nodes in the original tree is in the range `[1, 1000]`. * `1 <= Node.val <= 109`","completion":"def interval_intersection(firstList, secondList): result = [] i, j = 0, 0 while i < len(firstList) and j < len(secondList): start = max(firstList[i][0], secondList[j][0]) end = min(firstList[i][1], secondList[j][1]) if start <= end: result.append([start, end]) if firstList[i][1] < secondList[j][1]: i += 1 else: j += 1 return result"},{"prompt":"We define the `lcp` matrix of any **0indexed** string `word` of `n` lowercase English letters as an `n x n` grid such that: * `lcp[i][j]` is equal to the length of the **longest common prefix** between the substrings `word[i,n1]` and `word[j,n1]`. Given an `n x n` matrix `lcp`, return the alphabetically smallest string `word` that corresponds to `lcp`. If there is no such string, return an empty string. A string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`. For example, `aabd ` is lexicographically smaller than `aaca ` because the first position they differ is at the third letter, and `\'b\'` comes before `\'c\'`. **Example 1:** **Input:** lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]] **Output:** abab **Explanation:** lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is abab . **Example 2:** **Input:** lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]] **Output:** aaaa **Explanation:** lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is aaaa . **Example 3:** **Input:** lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]] **Output:** **Explanation:** lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists. **Constraints:** * `1 <= n ==` `lcp.length ==` `lcp[i].length` `<= 1000` * `0 <= lcp[i][j] <= n`","completion":"def smallestWordForLCP(lcp): n = len(lcp) word = [\'a\'] * n for i in range(1, n): for j in range(1, n): if lcp[i][j] > min(lcp[i - 1][j], lcp[i][j - 1]): word[i + lcp[i][j] - 1] = max(word[i + lcp[i][j] - 1], chr(ord(word[i - 1]) + 1)) elif lcp[i][j] < min(lcp[i - 1][j], lcp[i][j - 1]): return \\"\\" return \\"\\".join(word)"},{"prompt":"There are `n` rooms labeled from `0` to `n 1` and all the rooms are locked except for room `0`. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key. When you visit a room, you may find a set of **distinct keys** in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms. Given an array `rooms` where `rooms[i]` is the set of keys that you can obtain if you visited room `i`, return `true` _if you can visit **all** the rooms, or_ `false` _otherwise_. **Example 1:** **Input:** rooms = [[1],[2],[3],[]] **Output:** true **Explanation:** We visit room 0 and pick up key 1. We then visit room 1 and pick up key 2. We then visit room 2 and pick up key 3. We then visit room 3. Since we were able to visit every room, we return true. **Example 2:** **Input:** rooms = [[1,3],[3,0,1],[2],[0]] **Output:** false **Explanation:** We can not enter room number 2 since the only key that unlocks it is in that room. **Constraints:** * `n == rooms.length` * `2 <= n <= 1000` * `0 <= rooms[i].length <= 1000` * `1 <= sum(rooms[i].length) <= 3000` * `0 <= rooms[i][j] < n` * All the values of `rooms[i]` are **unique**.","completion":"def shortestToChar(s, c): n = len(s) result = [n for _ in range(n)] pos = -n for i in range(n): if s[i] == c: pos = i result[i] = i - pos for i in range(pos - 1, -1, -1): if s[i] == c: pos = i result[i] = min(result[i], pos - i) return result"},{"prompt":"Given an integer `num`, find the closest two integers in absolute difference whose product equals `num + 1` or `num + 2`. Return the two integers in any order. **Example 1:** **Input:** num = 8 **Output:** [3,3] **Explanation:** For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen. **Example 2:** **Input:** num = 123 **Output:** [5,25] **Example 3:** **Input:** num = 999 **Output:** [40,25] **Constraints:** * `1 <= num <= 10^9`","completion":"def findClosestDivisors(num): for i in range(int((num + 2) ** 0.5), 0, -1): if (num + 1) % i == 0: return [i, (num + 1) // i] if (num + 2) % i == 0: return [i, (num + 2) // i] return []"},{"prompt":"A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large **circular** table, capable of seating **any number** of employees. The employees are numbered from `0` to `n 1`. Each employee has a **favorite** person and they will attend the meeting **only if** they can sit next to their favorite person at the table. The favorite person of an employee is **not** themself. Given a **0indexed** integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the **maximum number of employees** that can be invited to the meeting_. **Example 1:** **Input:** favorite = [2,2,1,2] **Output:** 3 **Explanation:** The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table. All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously. Note that the company can also invite employees 1, 2, and 3, and give them their desired seats. The maximum number of employees that can be invited to the meeting is 3. **Example 2:** **Input:** favorite = [1,2,0] **Output:** 3 **Explanation:** Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee. The seating arrangement will be the same as that in the figure given in example 1: Employee 0 will sit between employees 2 and 1. Employee 1 will sit between employees 0 and 2. Employee 2 will sit between employees 1 and 0. The maximum number of employees that can be invited to the meeting is 3. **Example 3:** **Input:** favorite = [3,0,1,4,1] **Output:** 4 **Explanation:** The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table. Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken. So the company leaves them out of the meeting. The maximum number of employees that can be invited to the meeting is 4. **Constraints:** * `n == favorite.length` * `2 <= n <= 105` * `0 <= favorite[i] <= n 1` * `favorite[i] != i`","completion":"def max_invited(favorite): in_degree = [0] * len(favorite) for fav in favorite: in_degree[fav] += 1 result = 0 for degree in in_degree: result += max(degree - 1, 0) return min(result + 2, len(favorite))"},{"prompt":"You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains **one less block** than the row beneath it and is centered on top. To make the pyramid aesthetically pleasing, there are only specific **triangular patterns** that are allowed. A triangular pattern consists of a **single block** stacked on top of **two blocks**. The patterns are given as a list of threeletter strings `allowed`, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block. * For example, `ABC ` represents a triangular pattern with a `\'C\'` block stacked on top of an `\'A\'` (left) and `\'B\'` (right) block. Note that this is different from `BAC ` where `\'B\'` is on the left bottom and `\'A\'` is on the right bottom. You start with a bottom row of blocks `bottom`, given as a single string, that you **must** use as the base of the pyramid. Given `bottom` and `allowed`, return `true` _if you can build the pyramid all the way to the top such that **every triangular pattern** in the pyramid is in_ `allowed`_, or_ `false` _otherwise_. **Example 1:** **Input:** bottom = BCD , allowed = [ BCC , CDE , CEA , FFF ] **Output:** true **Explanation:** The allowed triangular patterns are shown on the right. Starting from the bottom (level 3), we can build CE on level 2 and then build A on level 1. There are three triangular patterns in the pyramid, which are BCC , CDE , and CEA . All are allowed. **Example 2:** **Input:** bottom = AAAA , allowed = [ AAB , AAC , BCD , BBE , DEF ] **Output:** false **Explanation:** The allowed triangular patterns are shown on the right. Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1. **Constraints:** * `2 <= bottom.length <= 6` * `0 <= allowed.length <= 216` * `allowed[i].length == 3` * The letters in all input strings are from the set `{\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'}`. * All the values of `allowed` are **unique**.","completion":"def pyramid_transition(bottom, allowed): mapping = {} for s in allowed: key = s[:2] if key not in mapping: mapping[key] = [] mapping[key].append(s[2]) return pyramid_transition_helper(bottom, \\"\\", 0, mapping) def pyramid_transition_helper(bottom, top, idx, mapping): if len(bottom) == 1: return True if idx == len(bottom) - 1: return pyramid_transition_helper(top, \\"\\", 0, mapping) key = bottom[idx:idx + 2] if key not in mapping: return False for c in mapping[key]: if pyramid_transition_helper(bottom, top + c, idx + 1, mapping): return True return False"},{"prompt":"You are given an integer array of unique positive integers `nums`. Consider the following graph: * There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length 1]`, * There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`. Return _the size of the largest connected component in the graph_. **Example 1:** **Input:** nums = [4,6,15,35] **Output:** 4 **Example 2:** **Input:** nums = [20,50,9,63] **Output:** 2 **Example 3:** **Input:** nums = [2,3,6,7,4,12,21,39] **Output:** 8 **Constraints:** * `1 <= nums.length <= 2 * 104` * `1 <= nums[i] <= 105` * All the values of `nums` are **unique**.","completion":"from collections import Counter def word_subsets(words1, words2): max_chars = Counter() for word in words2: chars = Counter(word) for c, count in chars.items(): max_chars[c] = max(max_chars[c], count) result = [] for word in words1: word_chars = Counter(word) universal = all(word_chars[c] >= max_chars[c] for c in max_chars) if universal: result.append(word) return result"},{"prompt":"You are given a positive integer `n`, that is initially placed on a board. Every day, for `109` days, you perform the following procedure: * For each number `x` present on the board, find all numbers `1 <= i <= n` such that `x % i == 1`. * Then, place those numbers on the board. Return _the number of **distinct** integers present on the board after_ `109` _days have elapsed_. **Note:** * Once a number is placed on the board, it will remain on it until the end. * `%` stands for the modulo operation. For example, `14 % 3` is `2`. **Example 1:** **Input:** n = 5 **Output:** 4 **Explanation:** Initially, 5 is present on the board. The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. After that day, 3 will be added to the board because 4 % 3 == 1. At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. **Example 2:** **Input:** n = 3 **Output:** 2 **Explanation:** Since 3 % 2 == 1, 2 will be added to the board. After a billion days, the only two distinct numbers on the board are 2 and 3. **Constraints:** * `1 <= n <= 100`","completion":"def distinct_numbers(n): return n - 1"},{"prompt":"You are playing a game that contains multiple characters, and each of the characters has **two** main properties: **attack** and **defense**. You are given a 2D integer array `properties` where `properties[i] = [attacki, defensei]` represents the properties of the `ith` character in the game. A character is said to be **weak** if any other character has **both** attack and defense levels **strictly greater** than this character\'s attack and defense levels. More formally, a character `i` is said to be **weak** if there exists another character `j` where `attackj > attacki` and `defensej > defensei`. Return _the number of **weak** characters_. **Example 1:** **Input:** properties = [[5,5],[6,3],[3,6]] **Output:** 0 **Explanation:** No character has strictly greater attack and defense than the other. **Example 2:** **Input:** properties = [[2,2],[3,3]] **Output:** 1 **Explanation:** The first character is weak because the second character has a strictly greater attack and defense. **Example 3:** **Input:** properties = [[1,5],[10,4],[4,3]] **Output:** 1 **Explanation:** The third character is weak because the second character has a strictly greater attack and defense. **Constraints:** * `2 <= properties.length <= 105` * `properties[i].length == 2` * `1 <= attacki, defensei <= 105`","completion":"def numberOfSticks(n, k): MOD = 10**9 + 7 if n < k: return 0 dp = [[0] * (n+1) for _ in range(n+1)] for i in range(1, n+1): dp[i][1] = 1 for j in range(2, i+1): dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD return dp[n][k]"},{"prompt":"You are given an integer array `gifts` denoting the number of gifts in various piles. Every second, you do the following: * Choose the pile with the maximum number of gifts. * If there is more than one pile with the maximum number of gifts, choose any. * Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts. Return _the number of gifts remaining after_ `k` _seconds._ **Example 1:** **Input:** gifts = [25,64,9,4,100], k = 4 **Output:** 29 **Explanation:** The gifts are taken in the following way: In the first second, the last pile is chosen and 10 gifts are left behind. Then the second pile is chosen and 8 gifts are left behind. After that the first pile is chosen and 5 gifts are left behind. Finally, the last pile is chosen again and 3 gifts are left behind. The final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29. **Example 2:** **Input:** gifts = [1,1,1,1], k = 4 **Output:** 4 **Explanation:** In this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. That is, you can\'t take any pile with you. So, the total gifts remaining are 4. **Constraints:** * `1 <= gifts.length <= 103` * `1 <= gifts[i] <= 109` * `1 <= k <= 103`","completion":"import math def giftsRemaining(gifts, k): for i in range(k): gifts.sort() max_index = len(gifts) - 1 gifts[max_index] -= int(math.sqrt(gifts[max_index])) return sum(gifts)"},{"prompt":"You are given an array of strings `products` and a string `searchWord`. Design a system that suggests at most three product names from `products` after each character of `searchWord` is typed. Suggested products should have common prefix with `searchWord`. If there are more than three products with a common prefix return the three lexicographically minimums products. Return _a list of lists of the suggested products after each character of_ `searchWord` _is typed_. **Example 1:** **Input:** products = [ mobile , mouse , moneypot , monitor , mousepad ], searchWord = mouse **Output:** [[ mobile , moneypot , monitor ],[ mobile , moneypot , monitor ],[ mouse , mousepad ],[ mouse , mousepad ],[ mouse , mousepad ]] **Explanation:** products sorted lexicographically = [ mobile , moneypot , monitor , mouse , mousepad ]. After typing m and mo all products match and we show user [ mobile , moneypot , monitor ]. After typing mou, mous and mouse the system suggests [ mouse , mousepad ]. **Example 2:** **Input:** products = [ havana ], searchWord = havana **Output:** [[ havana ],[ havana ],[ havana ],[ havana ],[ havana ],[ havana ]] **Explanation:** The only word havana will be always suggested while typing the search word. **Constraints:** * `1 <= products.length <= 1000` * `1 <= products[i].length <= 3000` * `1 <= sum(products[i].length) <= 2 * 104` * All the strings of `products` are **unique**. * `products[i]` consists of lowercase English letters. * `1 <= searchWord.length <= 1000` * `searchWord` consists of lowercase English letters.","completion":"def suggestedProducts(products, searchWord): result = [] products.sort() for i in range(len(searchWord)): suggestions = [] for product in products: if len(product) > i and product[i] == searchWord[i]: suggestions.append(product) if len(suggestions) == 3: break result.append(suggestions) return result"},{"prompt":"You are given a string `s`. A split is called **good** if you can split `s` into two nonempty strings `sleft` and `sright` where their concatenation is equal to `s` (i.e., `sleft + sright = s`) and the number of distinct letters in `sleft` and `sright` is the same. Return _the number of **good splits** you can make in `s`_. **Example 1:** **Input:** s = aacaba **Output:** 2 **Explanation:** There are 5 ways to split ` aacaba ` and 2 of them are good. ( a , acaba ) Left string and right string contains 1 and 3 different letters respectively. ( aa , caba ) Left string and right string contains 1 and 3 different letters respectively. ( aac , aba ) Left string and right string contains 2 and 2 different letters respectively (good split). ( aaca , ba ) Left string and right string contains 2 and 2 different letters respectively (good split). ( aacab , a ) Left string and right string contains 3 and 1 different letters respectively. **Example 2:** **Input:** s = abcd **Output:** 1 **Explanation:** Split the string as follows ( ab , cd ). **Constraints:** * `1 <= s.length <= 105` * `s` consists of only lowercase English letters.","completion":"def process_queries(queries, m): nums = list(range(1, m+1)) result = [] for q in queries: pos = nums.index(q) result.append(pos) del nums[pos] nums.insert(0, q) return result"},{"prompt":"You are given an integer array `nums`. The adjacent integers in `nums` will perform the float division. * For example, for `nums = [2,3,4]`, we will evaluate the expression `2/3/4 `. However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum. Return _the corresponding expression that has the maximum value in string format_. **Note:** your expression should not contain redundant parenthesis. **Example 1:** **Input:** nums = [1000,100,10,2] **Output:** 1000/(100/10/2) **Explanation:** 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in 1000/(**(**100/10**)**/2) are redundant since they do not influence the operation priority. So you should return 1000/(100/10/2) . Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2 **Example 2:** **Input:** nums = [2,3,4] **Output:** 2/(3/4) **Explanation:** (2/(3/4)) = 8/3 = 2.667 It can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667 **Constraints:** * `1 <= nums.length <= 10` * `2 <= nums[i] <= 1000` * There is only one optimal division for the given input.","completion":"def optimal_division(nums): n = len(nums) if n == 1: return str(nums[0]) if n == 2: return str(nums[0]) + \'/\' + str(nums[1]) res = str(nums[0]) + \'/(\' for i in range(1, n - 1): res += str(nums[i]) + \'/\' res += str(nums[n - 1]) + \')\' return res"},{"prompt":"Given an integer array `nums` that **does not contain** any zeros, find **the largest positive** integer `k` such that `k` also exists in the array. Return _the positive integer_ `k`. If there is no such integer, return `1`. **Example 1:** **Input:** nums = [1,2,3,3] **Output:** 3 **Explanation:** 3 is the only valid k we can find in the array. **Example 2:** **Input:** nums = [1,10,6,7,7,1] **Output:** 7 **Explanation:** Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value. **Example 3:** **Input:** nums = [10,8,6,7,2,3] **Output:** 1 **Explanation:** There is no a single valid k, we return 1. **Constraints:** * `1 <= nums.length <= 1000` * `1000 <= nums[i] <= 1000` * `nums[i] != 0`","completion":"def find_K(nums): s = set(nums) k = -1 for num in nums: if -num in s: k = max(k, abs(num)) return k"},{"prompt":"You are given a string `s` of **even length** consisting of digits from `0` to `9`, and two integers `a` and `b`. You can apply either of the following two operations any number of times and in any order on `s`: * Add `a` to all odd indices of `s` **(0indexed)**. Digits post `9` are cycled back to `0`. For example, if `s = 3456 ` and `a = 5`, `s` becomes `3951 `. * Rotate `s` to the right by `b` positions. For example, if `s = 3456 ` and `b = 1`, `s` becomes `6345 `. Return _the **lexicographically smallest** string you can obtain by applying the above operations any number of times on_ `s`. A string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`. For example, `0158 ` is lexicographically smaller than `0190 ` because the first position they differ is at the third letter, and `\'5\'` comes before `\'9\'`. **Example 1:** **Input:** s = 5525 , a = 9, b = 2 **Output:** 2050 **Explanation:** We can apply the following operations: Start: 5525 Rotate: 2555 Add: 2454 Add: 2353 Rotate: 5323 Add: 5222 Add: 5121 Rotate: 2151 ​​​​​​​Add: 2050 ​​​​​​​​​​​​ There is no way to obtain a string that is lexicographically smaller then 2050 . **Example 2:** **Input:** s = 74 , a = 5, b = 1 **Output:** 24 **Explanation:** We can apply the following operations: Start: 74 Rotate: 47 ​​​​​​​Add: 42 ​​​​​​​Rotate: 24 ​​​​​​​​​​​​ There is no way to obtain a string that is lexicographically smaller then 24 . **Example 3:** **Input:** s = 0011 , a = 4, b = 2 **Output:** 0011 **Explanation:** There are no sequence of operations that will give us a lexicographically smaller string than 0011 . **Constraints:** * `2 <= s.length <= 100` * `s.length` is even. * `s` consists of digits from `0` to `9` only. * `1 <= a <= 9` * `1 <= b <= s.length 1`","completion":"def findLexSmallestString(s: str, a: int, b: int) -> str: def add_odd(s: str, a: int) -> str: return \'\'.join([str((int(ch) + a) % 10) if idx % 2 else ch for idx, ch in enumerate(s)]) def rotate(s: str, k: int) -> str: k %= len(s) return s[-k:] + s[:-k] smallest = s for _ in range(len(s)): for _ in range(10): rotated = rotate(s, b) temp = add_odd(rotated, a) smallest = min(smallest, temp) s = rotated s = add_odd(s, a) return smallest"},{"prompt":"You are given a circle represented as `(radius, xCenter, yCenter)` and an axisaligned rectangle represented as `(x1, y1, x2, y2)`, where `(x1, y1)` are the coordinates of the bottomleft corner, and `(x2, y2)` are the coordinates of the topright corner of the rectangle. Return `true` _if the circle and rectangle are overlapped otherwise return_ `false`. In other words, check if there is **any** point `(xi, yi)` that belongs to the circle and the rectangle at the same time. **Example 1:** **Input:** radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = 1, x2 = 3, y2 = 1 **Output:** true **Explanation:** Circle and rectangle share the point (1,0). **Example 2:** **Input:** radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = 3, x2 = 2, y2 = 1 **Output:** false **Example 3:** **Input:** radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = 0, x2 = 0, y2 = 1 **Output:** true **Constraints:** * `1 <= radius <= 2000` * `104 <= xCenter, yCenter <= 104` * `104 <= x1 < x2 <= 104` * `104 <= y1 < y2 <= 104`","completion":"def checkOverlap(radius, xCenter, yCenter, x1, y1, x2, y2): xClosest = max(x1, min(xCenter, x2)) yClosest = max(y1, min(yCenter, y2)) return (xCenter - xClosest) ** 2 + (yCenter - yClosest) ** 2 <= radius ** 2"},{"prompt":"a string composed of `\'L\'`, `\'R\'`, and `\'X\'` characters, like `RXXLRXRXL `, a move consists of either replacing one occurrence of `XL ` with `LX `, or replacing one occurrence of `RX ` with `XR `. Given the starting string `start` and the ending string `end`, return `True` if and only if there exists a sequence of moves to transform one string to the other. **Example 1:** **Input:** start = RXXLRXRXL , end = XRLXXRRLX **Output:** true **Explanation:** We can transform start to end following these steps: RXXLRXRXL > XRXLRXRXL > XRLXRXRXL > XRLXXRRXL > XRLXXRRLX **Example 2:** **Input:** start = X , end = L **Output:** false **Constraints:** * `1 <= start.length <= 104` * `start.length == end.length` * Both `start` and `end` will only consist of characters in `\'L\'`, `\'R\'`, and `\'X\'`.","completion":"def isToeplitzMatrix(matrix): rows = len(matrix) cols = len(matrix[0]) for i in range(rows - 1): for j in range(cols - 1): if matrix[i][j] != matrix[i+1][j+1]: return False return True"},{"prompt":"Given a list of `phrases`, generate a list of Before and After puzzles. A _phrase_ is a string that consists of lowercase English letters and spaces only. No space appears in the start or the end of a phrase. There are no consecutive spaces in a phrase. _Before and After puzzles_ are phrases that are formed by merging two phrases where the **last word of the first phrase** is the same as the **first word of the second phrase**. Return the Before and After puzzles that can be formed by every two phrases `phrases[i]` and `phrases[j]` where `i != j`. Note that the order of matching two phrases matters, we want to consider both orders. You should return a list of **distinct** strings **sorted lexicographically**. **Example 1:** **Input:** phrases = [ writing code , code rocks ] **Output:** [ writing code rocks ] **Example 2:** **Input:** phrases = [ mission statement , a quick bite to eat , a chip off the old block , chocolate bar , mission impossible , a man on a mission , block party , eat my words , bar of soap ] **Output:** [ a chip off the old block party , a man on a mission impossible , a man on a mission statement , a quick bite to eat my words , chocolate bar of soap ] **Example 3:** **Input:** phrases = [ a , b , a ] **Output:** [ a ] **Constraints:** * `1 <= phrases.length <= 100` * `1 <= phrases[i].length <= 100`","completion":"from collections import defaultdict def beforeAndAfterPuzzles(phrases): first_word_map = defaultdict(set) result = set() for phrase in phrases: first_word = phrase.split(\' \')[0] first_word_map[first_word].add(phrase) for phrase in phrases: last_word = phrase.split(\' \')[-1] if last_word in first_word_map: for cur_phrase in first_word_map[last_word]: if phrase != cur_phrase: result.add(phrase + cur_phrase[cur_phrase.index(\' \'):]) return sorted(list(result))"},{"prompt":"Given the array `queries` of positive integers between `1` and `m`, you have to process all `queries[i]` (from `i=0` to `i=queries.length1`) according to the following rules: * In the beginning, you have the permutation `P=[1,2,3,...,m]`. * For the current `i`, find the position of `queries[i]` in the permutation `P` (**indexing from 0**) and then move this at the beginning of the permutation `P.` Notice that the position of `queries[i]` in `P` is the result for `queries[i]`. Return an array containing the result for the given `queries`. **Example 1:** **Input:** queries = [3,1,2,1], m = 5 **Output:** [2,1,2,1] **Explanation:** The queries are processed as follow: For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is **2**, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is **1**, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is **2**, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is **1**, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. Therefore, the array containing the result is [2,1,2,1]. **Example 2:** **Input:** queries = [4,1,2,2], m = 4 **Output:** [3,1,2,0] **Example 3:** **Input:** queries = [7,5,5,8,3], m = 8 **Output:** [6,5,0,7,5] **Constraints:** * `1 <= m <= 10^3` * `1 <= queries.length <= m` * `1 <= queries[i] <= m`","completion":"from collections import deque def minNumberOfFlips(mat): m, n = len(mat), len(mat[0]) steps = 0 dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 0)] def encode(i, j): return i * n + j while True: flipped = 0 que = deque() for i in range(m): for j in range(n): if mat[i][j] == 1: que.append(encode(i, j)) while que: cur = que.popleft() cur_i, cur_j = divmod(cur, n) for dx, dy in dirs: ni, nj = cur_i + dx, cur_j + dy if 0 <= ni < m and 0 <= nj < n: mat[ni][nj] ^= 1 flipped += 1 if flipped == 0: break steps += flipped for row in mat: if any(cell == 1 for cell in row): return -1 return steps"},{"prompt":"The **numeric value** of a **lowercase character** is defined as its position `(1indexed)` in the alphabet, so the numeric value of `a` is `1`, the numeric value of `b` is `2`, the numeric value of `c` is `3`, and so on. The **numeric value** of a **string** consisting of lowercase characters is defined as the sum of its characters\' numeric values. For example, the numeric value of the string `abe ` is equal to `1 + 2 + 5 = 8`. You are given two integers `n` and `k`. Return _the **lexicographically smallest string** with **length** equal to `n` and **numeric value** equal to `k`._ Note that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order. **Example 1:** **Input:** n = 3, k = 27 **Output:** aay **Explanation:** The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3. **Example 2:** **Input:** n = 5, k = 73 **Output:** aaszz **Constraints:** * `1 <= n <= 105` * `n <= k <= 26 * n`","completion":"def contains_cycle(grid): def dfs(x, y, start_x, start_y, depth): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != grid[start_x][start_y]: return False grid[x][y] = \'*\' directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] for dx, dy in directions: new_x, new_y = x + dx, y + dy if new_x == start_x and new_y == start_y and depth >= 4: return True if dfs(new_x, new_y, start_x, start_y, depth + 1): return True grid[x][y] = grid[start_x][start_y] return False for i in range(len(grid)): for j in range(len(grid[0])): if dfs(i, j, i, j, 0): return True return False"},{"prompt":"You are given an integer array `nums` where the `ith` bag contains `nums[i]` balls. You are also given an integer `maxOperations`. You can perform the following operation at most `maxOperations` times: * Take any bag of balls and divide it into two new bags with a **positive** number of balls. * For example, a bag of `5` balls can become two new bags of `1` and `4` balls, or two new bags of `2` and `3` balls. Your penalty is the **maximum** number of balls in a bag. You want to **minimize** your penalty after the operations. Return _the minimum possible penalty after performing the operations_. **Example 1:** **Input:** nums = [9], maxOperations = 2 **Output:** 3 **Explanation:** Divide the bag with 9 balls into two bags of sizes 6 and 3. [**9**] > [6,3]. Divide the bag with 6 balls into two bags of sizes 3 and 3. [**6**,3] > [3,3,3]. The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3. **Example 2:** **Input:** nums = [2,4,8,2], maxOperations = 4 **Output:** 2 **Explanation:** Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,**8**,2] > [2,4,4,4,2]. Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,**4**,4,4,2] > [2,2,2,4,4,2]. Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,**4**,4,2] > [2,2,2,2,2,4,2]. Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,**4**,2] > [2,2,2,2,2,2,2,2]. The bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2. **Constraints:** * `1 <= nums.length <= 105` * `1 <= maxOperations, nums[i] <= 109`","completion":"def can_form_array(arr, pieces): piece_map = {piece[0]: piece for piece in pieces} i = 0 while i < len(arr): if arr[i] not in piece_map: return False for num in piece_map[arr[i]]: if arr[i] != num: return False i += 1 return True"},{"prompt":"You are given a **0indexed** integer array `candies`, where `candies[i]` represents the flavor of the `ith` candy. Your mom wants you to share these candies with your little sister by giving her `k` **consecutive** candies, but you want to keep as many flavors of candies as possible. Return _the **maximum** number of **unique** flavors of candy you can keep after sharing_ _with your sister._ **Example 1:** **Input:** candies = [1,2,2,3,4,3], k = 3 **Output:** 3 **Explanation:** Give the candies in the range [1, 3] (inclusive) with flavors [2,2,3]. You can eat candies with flavors [1,4,3]. There are 3 unique flavors, so return 3. **Example 2:** **Input:** candies = [2,2,2,2,3,3], k = 2 **Output:** 2 **Explanation:** Give the candies in the range [3, 4] (inclusive) with flavors [2,3]. You can eat candies with flavors [2,2,2,3]. There are 2 unique flavors, so return 2. Note that you can also share the candies with flavors [2,2] and eat the candies with flavors [2,2,3,3]. **Example 3:** **Input:** candies = [2,4,5], k = 0 **Output:** 3 **Explanation:** You do not have to give any candies. You can eat the candies with flavors [2,4,5]. There are 3 unique flavors, so return 3. **Constraints:** * `1 <= candies.length <= 105` * `1 <= candies[i] <= 105` * `0 <= k <= candies.length`","completion":"def find_different_binary_string(nums): return \\"\\".join(\\"1\\" if nums[i][i] == \\"0\\" else \\"0\\" for i in range(len(nums)))"},{"prompt":"You have `n` dice, and each die has `k` faces numbered from `1` to `k`. Given three integers `n`, `k`, and `target`, return _the number of possible ways (out of the_ `kn` _total ways)_ _to roll the dice, so the sum of the faceup numbers equals_ `target`. Since the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** **Input:** n = 1, k = 6, target = 3 **Output:** 1 **Explanation:** You throw one die with 6 faces. There is only one way to get a sum of 3. **Example 2:** **Input:** n = 2, k = 6, target = 7 **Output:** 6 **Explanation:** You throw two dice, each with 6 faces. There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1. **Example 3:** **Input:** n = 30, k = 30, target = 500 **Output:** 222616187 **Explanation:** The answer must be returned modulo 109 + 7. **Constraints:** * `1 <= n, k <= 30` * `1 <= target <= 1000`","completion":"def numRollsToTarget(n, k, target): MOD = 1000000007 dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(i, target + 1): for d in range(1, k + 1): if j - d >= 0: dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD return dp[n][target]"},{"prompt":"Given three integers, `k`, `digit1`, and `digit2`, you want to find the **smallest** integer that is: * **Larger** than `k`, * A **multiple** of `k`, and * Comprised of **only** the digits `digit1` and/or `digit2`. Return _the **smallest** such integer. If no such integer exists or the integer exceeds the limit of a signed 32bit integer (_`231 1`_), return_ `1`. **Example 1:** **Input:** k = 2, digit1 = 0, digit2 = 2 **Output:** 20 **Explanation:** 20 is the first integer larger than 2, a multiple of 2, and comprised of only the digits 0 and/or 2. **Example 2:** **Input:** k = 3, digit1 = 4, digit2 = 2 **Output:** 24 **Explanation:** 24 is the first integer larger than 3, a multiple of 3, and comprised of only the digits 4 and/or 2. **Example 3:** **Input:** k = 2, digit1 = 0, digit2 = 0 **Output:** 1 **Explanation:** No integer meets the requirements so return 1. **Constraints:** * `1 <= k <= 1000` * `0 <= digit1 <= 9` * `0 <= digit2 <= 9`","completion":"def checkZeroOnes(s: str) -> bool: longest_zero = longest_one = current_zero = current_one = 0 for c in s: if c == \'0\': current_zero += 1 longest_zero = max(longest_zero, current_zero) current_one = 0 else: current_one += 1 longest_one = max(longest_one, current_one) current_zero = 0 return longest_one > longest_zero"},{"prompt":"There is an `m x n` matrix that is initialized to all `0`\'s. There is also a 2D array `indices` where each `indices[i] = [ri, ci]` represents a **0indexed location** to perform some increment operations on the matrix. For each location `indices[i]`, do **both** of the following: 1. Increment **all** the cells on row `ri`. 2. Increment **all** the cells on column `ci`. Given `m`, `n`, and `indices`, return _the **number of oddvalued cells** in the matrix after applying the increment to all locations in_ `indices`. **Example 1:** **Input:** m = 2, n = 3, indices = [[0,1],[1,1]] **Output:** 6 **Explanation:** Initial matrix = [[0,0,0],[0,0,0]]. After applying first increment it becomes [[1,2,1],[0,1,0]]. The final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers. **Example 2:** **Input:** m = 2, n = 2, indices = [[1,1],[0,0]] **Output:** 0 **Explanation:** Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix. **Constraints:** * `1 <= m, n <= 50` * `1 <= indices.length <= 100` * `0 <= ri < m` * `0 <= ci < n`","completion":"def break_palindrome(palindrome: str) -> str: n = len(palindrome) if n < 2: return \\"\\" palindrome = list(palindrome) for i in range(n // 2): if palindrome[i] != \'a\': palindrome[i] = \'a\' return \\"\\".join(palindrome) palindrome[-1] = \'b\' return \\"\\".join(palindrome)"},{"prompt":"A sentence is a list of words that are separated by a single space with no leading or trailing spaces. For example, `Hello World `, `HELLO `, `hello world hello world ` are all sentences. Words consist of **only** uppercase and lowercase English letters. Two sentences `sentence1` and `sentence2` are **similar** if it is possible to insert an arbitrary sentence **(possibly empty)** inside one of these sentences such that the two sentences become equal. For example, `sentence1 = Hello my name is Jane ` and `sentence2 = Hello Jane ` can be made equal by inserting `my name is ` between `Hello ` and `Jane ` in `sentence2`. Given two sentences `sentence1` and `sentence2`, return `true` _if_ `sentence1` _and_ `sentence2` _are similar._ Otherwise, return `false`. **Example 1:** **Input:** sentence1 = My name is Haley , sentence2 = My Haley **Output:** true **Explanation:** sentence2 can be turned to sentence1 by inserting name is between My and Haley . **Example 2:** **Input:** sentence1 = of , sentence2 = A lot of words **Output:** false **Explanation:** No single sentence can be inserted inside one of the sentences to make it equal to the other. **Example 3:** **Input:** sentence1 = Eating right now , sentence2 = Eating **Output:** true **Explanation:** sentence2 can be turned to sentence1 by inserting right now at the end of the sentence. **Constraints:** * `1 <= sentence1.length, sentence2.length <= 100` * `sentence1` and `sentence2` consist of lowercase and uppercase English letters and spaces. * The words in `sentence1` and `sentence2` are separated by a single space.","completion":"def maximum_unique_subarray(nums): max_sum, current_sum, left = 0, 0, 0 elements = set() for right in range(len(nums)): while nums[right] in elements: elements.remove(nums[left]) current_sum -= nums[left] left += 1 elements.add(nums[right]) current_sum += nums[right] max_sum = max(max_sum, current_sum) return max_sum"},{"prompt":"You are given an array `arr` which consists of only zeros and ones, divide the array into **three nonempty parts** such that all of these parts represent the same binary value. If it is possible, return any `[i, j]` with `i + 1 < j`, such that: * `arr[0], arr[1], ..., arr[i]` is the first part, * `arr[i + 1], arr[i + 2], ..., arr[j 1]` is the second part, and * `arr[j], arr[j + 1], ..., arr[arr.length 1]` is the third part. * All three parts have equal binary values. If it is not possible, return `[1, 1]`. Note that the entire part is used when considering what binary value it represents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also, leading zeros **are allowed**, so `[0,1,1]` and `[1,1]` represent the same value. **Example 1:** **Input:** arr = [1,0,1,0,1] **Output:** [0,3] **Example 2:** **Input:** arr = [1,1,0,1,1] **Output:** [1,1] **Example 3:** **Input:** arr = [1,1,0,0,1] **Output:** [0,2] **Constraints:** * `3 <= arr.length <= 3 * 104` * `arr[i]` is `0` or `1`","completion":"def sum_of_widths(nums): MOD = 10**9 + 7 nums.sort() c, res = 1, 0 n = len(nums) for i in range(n): res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD c = c * 2 % MOD return res"},{"prompt":"You are given a **0indexed** integer array `nums`. The **concatenation** of two numbers is the number formed by concatenating their numerals. * For example, the concatenation of `15`, `49` is `1549`. The **concatenation value** of `nums` is initially equal to `0`. Perform this operation until `nums` becomes empty: * If there exists more than one number in `nums`, pick the first element and last element in `nums` respectively and add the value of their concatenation to the **concatenation value** of `nums`, then delete the first and last element from `nums`. * If one element exists, add its value to the **concatenation value** of `nums`, then delete it. Return _the concatenation value of the `nums`_. **Example 1:** **Input:** nums = [7,52,2,4] **Output:** 596 **Explanation:** Before performing any operation, nums is [7,52,2,4] and concatenation value is 0. In the first operation: We pick the first element, 7, and the last element, 4. Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74. Then we delete them from nums, so nums becomes equal to [52,2]. In the second operation: We pick the first element, 52, and the last element, 2. Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596. Then we delete them from the nums, so nums becomes empty. Since the concatenation value is 596 so the answer is 596. **Example 2:** **Input:** nums = [5,14,13,8,12] **Output:** 673 **Explanation:** Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0. In the first operation: We pick the first element, 5, and the last element, 12. Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512. Then we delete them from the nums, so nums becomes equal to [14,13,8]. In the second operation: We pick the first element, 14, and the last element, 8. Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660. Then we delete them from the nums, so nums becomes equal to [13]. In the third operation: nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673. Then we delete it from nums, so nums become empty. Since the concatenation value is 673 so the answer is 673. **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i] <= 104` .spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; fontsize:150%; fontweight: bold; color:#000000; backgroundcolor:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {webkittransition: all 0s ease;moztransition: margin 0s ease;otransition: all 0s ease;transition: margin 0s ease;} .spoilerbutton[value=Show Message] + .spoiler > div {margintop:500%;} .spoilerbutton[value=Hide Message] + .spoiler {padding:5px;}","completion":"def concatenationValue(nums): value = 0 while nums: n = len(nums) if n == 1: value += nums[0] nums.pop() else: value += int(str(nums[0]) + str(nums[-1])) nums.pop(0) nums.pop() return value"},{"prompt":"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`. You\'re given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range. If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`. **Example 1:** **Input:** startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] **Output:** 120 **Explanation:** The subset chosen is the first and fourth job. Time range [13]+[36] , we get profit of 120 = 50 + 70. **Example 2:** **Input:** startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] **Output:** 150 **Explanation:** The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60. **Example 3:** **Input:** startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] **Output:** 6 **Constraints:** * `1 <= startTime.length == endTime.length == profit.length <= 5 * 104` * `1 <= startTime[i] < endTime[i] <= 109` * `1 <= profit[i] <= 104`","completion":"from bisect import bisect_left def jobScheduling(startTime, endTime, profit): jobs = sorted(zip(endTime, startTime, profit)) dp = [jobs[0][2]] def latestNonConflict(index): startTimeToFind = jobs[index][1] index = bisect_left([job[0] for job in jobs], startTimeToFind) if index: return index - 1 return -1 for i in range(1, len(jobs)): L = latestNonConflict(i) dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2])) return dp[-1]"},{"prompt":"You are given a character array `keys` containing **unique** characters and a string array `values` containing strings of length 2. You are also given another string array `dictionary` that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a **0indexed** string. A string is **encrypted** with the following process: 1. For each character `c` in the string, we find the index `i` satisfying `keys[i] == c` in `keys`. 2. Replace `c` with `values[i]` in the string. Note that in case a character of the string is **not present** in `keys`, the encryption process cannot be carried out, and an empty string ` ` is returned. A string is **decrypted** with the following process: 1. For each substring `s` of length 2 occurring at an even index in the string, we find an `i` such that `values[i] == s`. If there are multiple valid `i`, we choose **any** one of them. This means a string could have multiple possible strings it can decrypt to. 2. Replace `s` with `keys[i]` in the string. Implement the `Encrypter` class: * `Encrypter(char[] keys, String[] values, String[] dictionary)` Initializes the `Encrypter` class with `keys, values`, and `dictionary`. * `String encrypt(String word1)` Encrypts `word1` with the encryption process described above and returns the encrypted string. * `int decrypt(String word2)` Returns the number of possible strings `word2` could decrypt to that also appear in `dictionary`. **Example 1:** **Input** [ Encrypter , encrypt , decrypt ] [[[\'a\', \'b\', \'c\', \'d\'], [ ei , zf , ei , am ], [ abcd , acbd , adbc , badc , dacb , cadb , cbda , abad ]], [ abcd ], [ eizfeiam ]] **Output** [null, eizfeiam , 2] **Explanation** Encrypter encrypter = new Encrypter([[\'a\', \'b\', \'c\', \'d\'], [ ei , zf , ei , am ], [ abcd , acbd , adbc , badc , dacb , cadb , cbda , abad ]); encrypter.encrypt( abcd ); // return eizfeiam . // \'a\' maps to ei , \'b\' maps to zf , \'c\' maps to ei , and \'d\' maps to am . encrypter.decrypt( eizfeiam ); // return 2. // ei can map to \'a\' or \'c\', zf maps to \'b\', and am maps to \'d\'. // Thus, the possible strings after decryption are abad , cbad , abcd , and cbcd . // 2 of those strings, abad and abcd , appear in dictionary, so the answer is 2. **Constraints:** * `1 <= keys.length == values.length <= 26` * `values[i].length == 2` * `1 <= dictionary.length <= 100` * `1 <= dictionary[i].length <= 100` * All `keys[i]` and `dictionary[i]` are **unique**. * `1 <= word1.length <= 2000` * `1 <= word2.length <= 200` * All `word1[i]` appear in `keys`. * `word2.length` is even. * `keys`, `values[i]`, `dictionary[i]`, `word1`, and `word2` only contain lowercase English letters. * At most `200` calls will be made to `encrypt` and `decrypt` **in total**.","completion":"def sum_of_subarray_ranges(nums): n = len(nums) ans = 0 for i in range(n): for j in range(i, n): ans += max(nums[i:j+1]) - min(nums[i:j+1]) return ans"},{"prompt":"Given an integer array `nums`, find the **maximum** possible **bitwise OR** of a subset of `nums` and return _the **number of different nonempty subsets** with the maximum bitwise OR_. An array `a` is a **subset** of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`. Two subsets are considered **different** if the indices of the elements chosen are different. The bitwise OR of an array `a` is equal to `a[0] **OR** a[1] **OR** ... **OR** a[a.length 1]` (**0indexed**). **Example 1:** **Input:** nums = [3,1] **Output:** 2 **Explanation:** The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3: [3] [3,1] **Example 2:** **Input:** nums = [2,2,2] **Output:** 7 **Explanation:** All nonempty subsets of [2,2,2] have a bitwise OR of 2. There are 23 1 = 7 total subsets. **Example 3:** **Input:** nums = [3,2,1,5] **Output:** 6 **Explanation:** The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7: [3,5] [3,1,5] [3,2,5] [3,2,1,5] [2,5] [2,1,5] **Constraints:** * `1 <= nums.length <= 16` * `1 <= nums[i] <= 105`","completion":"def wonderfulSubstrings(word: str) -> int: res = 0 mask = 0 count = {0: 1} for c in word: mask ^= 1 << (ord(c) - ord(\'a\')) res += count.get(mask, 0) for i in range(10): res += count.get(mask ^ (1 << i), 0) count[mask] = count.get(mask, 0) + 1 return res"},{"prompt":"This is an **interactive problem**. There is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size `m x n`, and each cell in the grid is either empty or blocked. It is **guaranteed** that the starting cell and the target cell are different, and neither of them is blocked. You want to find the minimum distance to the target cell. However, you **do not know** the grid\'s dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the `GridMaster` object. Thr `GridMaster` class has the following functions: * `boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`. * `void move(char direction)` Moves the robot in that direction. If this move would move the robot to a blocked cell or off the grid, the move will be **ignored**, and the robot will remain in the same position. * `boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`. Note that `direction` in the above functions should be a character from `{\'U\',\'D\',\'L\',\'R\'}`, representing the directions up, down, left, and right, respectively. Return _the **minimum distance** between the robot\'s initial starting cell and the target cell. If there is no valid path between the cells, return_ `1`. **Custom testing:** The test input is read as a 2D matrix `grid` of size `m x n` where: * `grid[i][j] == 1` indicates that the robot is in cell `(i, j)` (the starting cell). * `grid[i][j] == 0` indicates that the cell `(i, j)` is blocked. * `grid[i][j] == 1` indicates that the cell `(i, j)` is empty. * `grid[i][j] == 2` indicates that the cell `(i, j)` is the target cell. There is exactly one `1` and `2` in `grid`. Remember that you will **not** have this information in your code. **Example 1:** **Input:** grid = [[1,2],[1,0]] **Output:** 2 **Explanation:** One possible interaction is described below: The robot is initially standing on cell (1, 0), denoted by the 1. master.canMove(\'U\') returns true. master.canMove(\'D\') returns false. master.canMove(\'L\') returns false. master.canMove(\'R\') returns false. master.move(\'U\') moves the robot to the cell (0, 0). master.isTarget() returns false. master.canMove(\'U\') returns false. master.canMove(\'D\') returns true. master.canMove(\'L\') returns false. master.canMove(\'R\') returns true. master.move(\'R\') moves the robot to the cell (0, 1). master.isTarget() returns true. We now know that the target is the cell (0, 1), and the shortest path to the target cell is 2. **Example 2:** **Input:** grid = [[0,0,1],[1,1,1],[2,0,0]] **Output:** 4 **Explanation:** The minimum distance between the robot and the target cell is 4. **Example 3:** **Input:** grid = [[1,0],[0,2]] **Output:** 1 **Explanation:** There is no path from the robot to the target cell. **Constraints:** * `1 <= n, m <= 500` * `m == grid.length` * `n == grid[i].length` * `grid[i][j]` is either `1`, `0`, `1`, or `2`. * There is **exactly one** `1` in `grid`. * There is **exactly one** `2` in `grid`.","completion":"from functools import lru_cache def getMaxGridHappiness(m, n, introvertsCount, extrovertsCount): @lru_cache(None) def maxHappy(y, mask): if y == n: return 0 ans = 0 for x in range(m + 1): happiness = 0 if mask >> x & 1: happiness -= 30 if x > 0 and mask & 1: happiness -= 30 else: happiness += 20 ans = max(ans, happiness + maxHappy(y + 1, (mask | (1 << x)) >> 1)) return ans return maxHappy(0, 0)"},{"prompt":"An `n x n` matrix is **valid** if every row and every column contains **all** the integers from `1` to `n` (**inclusive**). Given an `n x n` integer matrix `matrix`, return `true` _if the matrix is **valid**._ Otherwise, return `false`. **Example 1:** **Input:** matrix = [[1,2,3],[3,1,2],[2,3,1]] **Output:** true **Explanation:** In this case, n = 3, and every row and column contains the numbers 1, 2, and 3. Hence, we return true. **Example 2:** **Input:** matrix = [[1,1,1],[1,2,3],[1,2,3]] **Output:** false **Explanation:** In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3. Hence, we return false. **Constraints:** * `n == matrix.length == matrix[i].length` * `1 <= n <= 100` * `1 <= matrix[i][j] <= n`","completion":"def count_pairs(nums, target): count = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target or nums[j] + nums[i] == target: count += 1 return count"},{"prompt":"You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of **any** color. The customer weirdly values the colored balls. Each colored ball\'s value is the number of balls **of that color** you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer). You are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls **in any order**. Return _the **maximum** total value that you can attain after selling_ `orders` _colored balls_. As the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** **Input:** inventory = [2,5], orders = 4 **Output:** 14 **Explanation:** Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3). The maximum total value is 2 + 5 + 4 + 3 = 14. **Example 2:** **Input:** inventory = [3,5], orders = 6 **Output:** 19 **Explanation:** Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2). The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19. **Constraints:** * `1 <= inventory.length <= 105` * `1 <= inventory[i] <= 109` * `1 <= orders <= min(sum(inventory[i]), 109)`","completion":"def minInsertions(s: str) -> int: ans, depth = 0, 0 for i in range(len(s)): if s[i] == \'(\': depth += 2 else: if s[i - 1] == \'(\': depth -= 1 else: depth -= 2 if depth < 0: ans -= depth depth = 0 return ans + depth"},{"prompt":"Given an integer array `arr`, count how many elements `x` there are, such that `x + 1` is also in `arr`. If there are duplicates in `arr`, count them separately. **Example 1:** **Input:** arr = [1,2,3] **Output:** 2 **Explanation:** 1 and 2 are counted cause 2 and 3 are in arr. **Example 2:** **Input:** arr = [1,1,3,3,5,5,7,7] **Output:** 0 **Explanation:** No numbers are counted, cause there is no 2, 4, 6, or 8 in arr. **Constraints:** * `1 <= arr.length <= 1000` * `0 <= arr[i] <= 1000`","completion":"def sum_zero(n): res = [] for i in range(1, (n // 2) + 1): res.append(i) res.append(-i) if n % 2 != 0: res.append(0) return res"},{"prompt":"the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a roundbased procedure. In each round, each senator can exercise **one** of the two rights: * **Ban one senator\'s right:** A senator can make another senator lose all his rights in this and all the following rounds. * **Announce the victory:** If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string `senate` representing each senator\'s party belonging. The character `\'R\'` and `\'D\'` represent the Radiant party and the Dire party. Then if there are `n` senators, the size of the given string will be `n`. The roundbased procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be `Radiant ` or `Dire `. **Example 1:** **Input:** senate = RD **Output:** Radiant **Explanation:** The first senator comes from Radiant and he can just ban the next senator\'s right in round 1. And the second senator can\'t exercise any rights anymore since his right has been banned. And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. **Example 2:** **Input:** senate = RDD **Output:** Dire **Explanation:** The first senator comes from Radiant and he can just ban the next senator\'s right in round 1. And the second senator can\'t exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator\'s right in round 1. And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote. **Constraints:** * `n == senate.length` * `1 <= n <= 104` * `senate[i]` is either `\'R\'` or `\'D\'`.","completion":"from collections import deque def predict_party_victory(senate: str) -> str: radiant = deque() dire = deque() n = len(senate) for i, s in enumerate(senate): if s == \'R\': radiant.append(i) else: dire.append(i) while radiant and dire: r = radiant.popleft() d = dire.popleft() if r < d: radiant.append(r + n) else: dire.append(d + n) return \\"Dire\\" if not radiant else \\"Radiant\\""},{"prompt":"A **fancy string** is a string where no **three** **consecutive** characters are equal. Given a string `s`, delete the **minimum** possible number of characters from `s` to make it **fancy**. Return _the final string after the deletion_. It can be shown that the answer will always be **unique**. **Example 1:** **Input:** s = leeetcode **Output:** leetcode **Explanation:** Remove an \'e\' from the first group of \'e\'s to create leetcode . No three consecutive characters are equal, so return leetcode . **Example 2:** **Input:** s = aaabaaaa **Output:** aabaa **Explanation:** Remove an \'a\' from the first group of \'a\'s to create aabaaaa . Remove two \'a\'s from the second group of \'a\'s to create aabaa . No three consecutive characters are equal, so return aabaa . **Example 3:** **Input:** s = aab **Output:** aab **Explanation:** No three consecutive characters are equal, so return aab . **Constraints:** * `1 <= s.length <= 105` * `s` consists only of lowercase English letters.","completion":"def smallest_difference_room(rooms, queries): n = len(rooms) k = len(queries) rooms.sort(key=lambda x: x[0]) results = [] for i in range(k): preferred, minSize = queries[i] diff = float(\\"inf\\") room_idx = -1 for j in range(n): if rooms[j][1] >= minSize: tmp_diff = abs(preferred - rooms[j][0]) if tmp_diff < diff: diff = tmp_diff room_idx = rooms[j][0] results.append(room_idx) return results"},{"prompt":"A **Fibonacci** tree is a binary tree created using the order function `order(n)`: * `order(0)` is the empty tree. * `order(1)` is a binary tree with only **one node**. * `order(n)` is a binary tree that consists of a root node with the left subtree as `order(n 2)` and the right subtree as `order(n 1)`. Alice and Bob are playing a game with a **Fibonacci** tree with Alice staring first. On each turn, a player selects a node and removes that node **and** its subtree. The player that is forced to delete `root` loses. Given the integer `n`, return `true` if Alice wins the game or `false` if Bob wins, assuming both players play optimally. A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node\'s descendants. The tree `tree` could also be considered as a subtree of itself. **Example 1:** **Input:** n = 3 **Output:** true **Explanation:** Alice takes the node 1 in the right subtree. Bob takes either the 1 in the left subtree or the 2 in the right subtree. Alice takes whichever node Bob doesn\'t take. Bob is forced to take the root node 3, so Bob will lose. Return true because Alice wins. **Example 2:** **Input:** n = 1 **Output:** false **Explanation:** Alice is forced to take the root node 1, so Alice will lose. Return false because Alice loses. **Example 3:** **Input:** n = 2 **Output:** true **Explanation:** Alice takes the node 1. Bob is forced to take the root node 2, so Bob will lose. Return true because Alice wins. **Constraints:** * `1 <= n <= 100`","completion":"def is_covered(ranges, left, right): for i in range(left, right + 1): is_covered = False for range_ in ranges: if i >= range_[0] and i <= range_[1]: is_covered = True break if not is_covered: return False return True"},{"prompt":"Design a stacklike data structure to push elements to the stack and pop the most frequent element from the stack. Implement the `FreqStack` class: * `FreqStack()` constructs an empty frequency stack. * `void push(int val)` pushes an integer `val` onto the top of the stack. * `int pop()` removes and returns the most frequent element in the stack. * If there is a tie for the most frequent element, the element closest to the stack\'s top is removed and returned. **Example 1:** **Input** [ FreqStack , push , push , push , push , push , push , pop , pop , pop , pop ] [[], [5], [7], [5], [7], [4], [5], [], [], [], []] **Output** [null, null, null, null, null, null, null, 5, 7, 5, 4] **Explanation** FreqStack freqStack = new FreqStack(); freqStack.push(5); // The stack is [5] freqStack.push(7); // The stack is [5,7] freqStack.push(5); // The stack is [5,7,5] freqStack.push(7); // The stack is [5,7,5,7] freqStack.push(4); // The stack is [5,7,5,7,4] freqStack.push(5); // The stack is [5,7,5,7,4,5] freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. freqStack.pop(); // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,4]. freqStack.pop(); // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. **Constraints:** * `0 <= val <= 109` * At most `2 * 104` calls will be made to `push` and `pop`. * It is guaranteed that there will be at least one element in the stack before calling `pop`.","completion":"from collections import deque def shortestPathAllKeys(grid): m, n, steps, k, x, y, mask = len(grid), len(grid[0]), 0, 0, -1, -1, 0 for i in range(m): for j in range(n): if grid[i][j] == \'@\': x, y = i, j elif \'a\' <= grid[i][j] <= \'f\': k = max(k, ord(grid[i][j]) - ord(\'a\') + 1) q = deque([(x, y, 0)]) visited = {(x, y, mask)} dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)] while q: qs = len(q) for sz in range(qs): x, y, mask = q.popleft() if mask == (1 << k) - 1: return steps for dx, dy in dirs: nx, ny, nmask = x + dx, y + dy, mask if 0 <= nx < m and 0 <= ny < n: c = grid[nx][ny] if \'A\' <= c <= \'F\' and not nmask & (1 << (ord(c) - ord(\'A\'))): continue if \'a\' <= c <= \'f\': nmask |= (1 << (ord(c) - ord(\'a\'))) if (nx, ny, nmask) in visited: continue visited.add((nx, ny, nmask)) q.append((nx, ny, nmask)) steps += 1 return -1"},{"prompt":"You are given `n`​​​​​​ tasks labeled from `0` to `n 1` represented by a 2D integer array `tasks`, where `tasks[i] = [enqueueTimei, processingTimei]` means that the `i​​​​​​th`​​​​ task will be available to process at `enqueueTimei` and will take `processingTimei` to finish processing. You have a singlethreaded CPU that can process **at most one** task at a time and will act in the following way: * If the CPU is idle and there are no available tasks to process, the CPU remains idle. * If the CPU is idle and there are available tasks, the CPU will choose the one with the **shortest processing time**. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index. * Once a task is started, the CPU will **process the entire task** without stopping. * The CPU can finish a task then start a new one instantly. Return _the order in which the CPU will process the tasks._ **Example 1:** **Input:** tasks = [[1,2],[2,4],[3,2],[4,1]] **Output:** [0,2,3,1] **Explanation:** The events go as follows: At time = 1, task 0 is available to process. Available tasks = {0}. Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}. At time = 2, task 1 is available to process. Available tasks = {1}. At time = 3, task 2 is available to process. Available tasks = {1, 2}. Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}. At time = 4, task 3 is available to process. Available tasks = {1, 3}. At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}. At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}. At time = 10, the CPU finishes task 1 and becomes idle. **Example 2:** **Input:** tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]] **Output:** [4,3,2,0,1] **Explanation****:** The events go as follows: At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}. Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}. At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}. At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}. At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}. At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}. At time = 40, the CPU finishes task 1 and becomes idle. **Constraints:** * `tasks.length == n` * `1 <= n <= 105` * `1 <= enqueueTimei, processingTimei <= 109`","completion":"def minimum_teachings(n, languages, friendships): language_users = {} unconnected_users = set() for u, v in friendships: can_communicate = any(lang in languages[v-1] for lang in languages[u-1]) if not can_communicate: unconnected_users.add(u) unconnected_users.add(v) res = len(unconnected_users) for i in range(1, n+1): cnt = sum(i not in languages[user-1] for user in unconnected_users) res = min(res, cnt) return res"},{"prompt":"mplement a SnapshotArray that supports the following interface: * `SnapshotArray(int length)` initializes an arraylike data structure with the given length. **Initially, each element equals 0**. * `void set(index, val)` sets the element at the given `index` to be equal to `val`. * `int snap()` takes a snapshot of the array and returns the `snap_id`: the total number of times we called `snap()` minus `1`. * `int get(index, snap_id)` returns the value at the given `index`, at the time we took the snapshot with the given `snap_id` **Example 1:** **Input:** [ SnapshotArray , set , snap , set , get ] [[3],[0,5],[],[0,6],[0,0]] **Output:** [null,null,0,null,5] **Explanation:** SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3 snapshotArr.set(0,5); // Set array[0] = 5 snapshotArr.snap(); // Take a snapshot, return snap_id = 0 snapshotArr.set(0,6); snapshotArr.get(0,0); // Get the value of array[0] with snap_id = 0, return 5 **Constraints:** * `1 <= length <= 5 * 104` * `0 <= index < length` * `0 <= val <= 109` * `0 <= snap_id <` (the total number of times we call `snap()`) * At most `5 * 104` calls will be made to `set`, `snap`, and `get`.","completion":"def gcd_of_strings(str1: str, str2: str) -> str: if str1 + str2 != str2 + str1: return \'\' def gcd(a, b): return a if not b else gcd(b, a % b) return str1[:gcd(len(str1), len(str2))]"},{"prompt":"Your music player contains `n` different songs. You want to listen to `goal` songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that: * Every song is played **at least once**. * A song can only be played again only if `k` other songs have been played. Given `n`, `goal`, and `k`, return _the number of possible playlists that you can create_. Since the answer can be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** n = 3, goal = 3, k = 1 **Output:** 6 **Explanation:** There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. **Example 2:** **Input:** n = 2, goal = 3, k = 0 **Output:** 6 **Explanation:** There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2]. **Example 3:** **Input:** n = 2, goal = 3, k = 1 **Output:** 2 **Explanation:** There are 2 possible playlists: [1, 2, 1] and [2, 1, 2]. **Constraints:** * `0 <= k < n <= goal <= 100`","completion":"def uncommon_from_sentences(s1, s2): word_count = {} for word in (s1 + \\" \\" + s2).split(): word_count[word] = word_count.get(word, 0) + 1 return [key for key, val in word_count.items() if val == 1]"},{"prompt":"A **sentence** is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of **only** uppercase and lowercase English letters (no punctuation). * For example, `Hello World `, `HELLO `, and `hello world hello world ` are all sentences. You are given a sentence `s`​​​​​​ and an integer `k`​​​​​​. You want to **truncate** `s`​​​​​​ such that it contains only the **first** `k`​​​​​​ words. Return `s`​​​​_​​ after **truncating** it._ **Example 1:** **Input:** s = Hello how are you Contestant , k = 4 **Output:** Hello how are you **Explanation:** The words in s are [ Hello , how are , you , Contestant ]. The first 4 words are [ Hello , how , are , you ]. Hence, you should return Hello how are you . **Example 2:** **Input:** s = What is the solution to this problem , k = 4 **Output:** What is the solution **Explanation:** The words in s are [ What , is the , solution , to , this , problem ]. The first 4 words are [ What , is , the , solution ]. Hence, you should return What is the solution . **Example 3:** **Input:** s = chopper is not a tanuki , k = 5 **Output:** chopper is not a tanuki **Constraints:** * `1 <= s.length <= 500` * `k` is in the range `[1, the number of words in s]`. * `s` consist of only lowercase and uppercase English letters and spaces. * The words in `s` are separated by a single space. * There are no leading or trailing spaces.","completion":"def truncateSentence(s: str, k: int) -> str: words = s.split() return \\" \\".join(words[:k])"},{"prompt":"Given an array of integers `nums`, you start with an initial **positive** value _startValue__._ In each iteration, you calculate the step by step sum of _startValue_ plus elements in `nums` (from left to right). Return the minimum **positive** value of _startValue_ such that the step by step sum is never less than 1. **Example 1:** **Input:** nums = [3,2,3,4,2] **Output:** 5 **Explanation:** If you choose startValue = 4, in the third iteration your step by step sum is less than 1. **step by step sum** **startValue = 4 | startValue = 5 | nums** (4 **3** ) = 1 | (5 **3** ) = 2 | 3 (1 **+2** ) = 3 | (2 **+2** ) = 4 | 2 (3 **3** ) = 0 | (4 **3** ) = 1 | 3 (0 **+4** ) = 4 | (1 **+4** ) = 5 | 4 (4 **+2** ) = 6 | (5 **+2** ) = 7 | 2 **Example 2:** **Input:** nums = [1,2] **Output:** 1 **Explanation:** Minimum start value should be positive. **Example 3:** **Input:** nums = [1,2,3] **Output:** 5 **Constraints:** * `1 <= nums.length <= 100` * `100 <= nums[i] <= 100`","completion":"def maxSideLength(mat, threshold): m, n = len(mat), len(mat[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] ans = 0 for i in range(1, m + 1): for j in range(1, n + 1): dp[i][j] = mat[i - 1][j - 1] + dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] k = ans + 1 if i >= k and j >= k and dp[i][j] - dp[i][j - k] - dp[i - k][j] + dp[i - k][j - k] <= threshold: ans += 1 return ans"},{"prompt":"You are given a string `s` that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should **not** contain any brackets. **Example 1:** **Input:** s = (abcd) **Output:** dcba **Example 2:** **Input:** s = (u(love)i) **Output:** iloveu **Explanation:** The substring love is reversed first, then the whole string is reversed. **Example 3:** **Input:** s = (ed(et(oc))el) **Output:** leetcode **Explanation:** First, we reverse the substring oc , then etco , and finally, the whole string. **Constraints:** * `1 <= s.length <= 2000` * `s` only contains lower case English characters and parentheses. * It is guaranteed that all parentheses are balanced.","completion":"def reverseParentheses(s: str) -> str: stack = [] for i, c in enumerate(s): if c == \'(\': stack.append(i) elif c == \')\': start, end = stack.pop(), i # reversal of the substring s = s[:start] + s[start+1:end][::-1] + s[end+1:] return \'\'.join(c for c in s if c.isalpha())"},{"prompt":"You are given two integers `memory1` and `memory2` representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second. At the `ith` second (starting from 1), `i` bits of memory are allocated to the stick with **more available memory** (or from the first memory stick if both have the same available memory). If neither stick has at least `i` bits of available memory, the program **crashes**. Return _an array containing_ `[crashTime, memory1crash, memory2crash]`_, where_ `crashTime` _is the time (in seconds) when the program crashed and_ `memory1crash` _and_ `memory2crash` _are the available bits of memory in the first and second sticks respectively_. **Example 1:** **Input:** memory1 = 2, memory2 = 2 **Output:** [3,1,0] **Explanation:** The memory is allocated as follows: At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory. At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory. At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively. **Example 2:** **Input:** memory1 = 8, memory2 = 11 **Output:** [6,0,4] **Explanation:** The memory is allocated as follows: At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory. At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory. At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory. At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory. At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory. At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively. **Constraints:** * `0 <= memory1, memory2 <= 231 1`","completion":"import heapq def kthLargestValue(matrix, k): m, n = len(matrix), len(matrix[0]) prefix_xor = [[0] * (n + 1) for _ in range(m + 1)] pq = [] for i in range(1, m + 1): for j in range(1, n + 1): prefix_xor[i][j] = matrix[i - 1][j - 1] ^ prefix_xor[i - 1][j] ^ prefix_xor[i][j - 1] ^ prefix_xor[i - 1][j - 1] heapq.heappush(pq, prefix_xor[i][j]) if len(pq) > k: heapq.heappop(pq) return pq[0]"},{"prompt":"There is a rectangular brick wall in front of you with `n` rows of bricks. The `ith` row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same. Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. Given the 2D array `wall` that contains the information about the wall, return _the minimum number of crossed bricks after drawing such a vertical line_. **Example 1:** **Input:** wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] **Output:** 2 **Example 2:** **Input:** wall = [[1],[1],[1]] **Output:** 3 **Constraints:** * `n == wall.length` * `1 <= n <= 104` * `1 <= wall[i].length <= 104` * `1 <= sum(wall[i].length) <= 2 * 104` * `sum(wall[i])` is the same for each row `i`. * `1 <= wall[i][j] <= 231 1`","completion":"from collections import defaultdict def least_bricks(wall): edge_count = defaultdict(int) max_count = 0 for row in wall: edge_position = 0 for i in range(len(row) - 1): edge_position += row[i] edge_count[edge_position] += 1 max_count = max(max_count, edge_count[edge_position]) return len(wall) - max_count"},{"prompt":"combinatorial mathematics, a **derangement** is a permutation of the elements of a set, such that no element appears in its original position. You are given an integer `n`. There is originally an array consisting of `n` integers from `1` to `n` in ascending order, return _the number of **derangements** it can generate_. Since the answer may be huge, return it **modulo** `109 + 7`. **Example 1:** **Input:** n = 3 **Output:** 2 **Explanation:** The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2]. **Example 2:** **Input:** n = 2 **Output:** 1 **Constraints:** * `1 <= n <= 106`","completion":"def findDerangement(n: int) -> int: MOD = 10**9 + 7 dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD return dp[n]"},{"prompt":"You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone. We are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is: * If `x == y`, both stones are destroyed, and * If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y x`. At the end of the game, there is **at most one** stone left. Return _the weight of the last remaining stone_. If there are no stones left, return `0`. **Example 1:** **Input:** stones = [2,7,4,1,8,1] **Output:** 1 **Explanation:** We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that\'s the value of the last stone. **Example 2:** **Input:** stones = [1] **Output:** 1 **Constraints:** * `1 <= stones.length <= 30` * `1 <= stones[i] <= 1000`","completion":"def longestOnes(nums, k): left, right, max_ones, zero_count = 0, 0, 0, 0 while right < len(nums): if nums[right] == 0: zero_count += 1 while zero_count > k: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) right += 1 return max_ones"},{"prompt":"You are given a **0indexed** binary string `s` which represents the types of buildings along a street where: * `s[i] = \'0\'` denotes that the `ith` building is an office and * `s[i] = \'1\'` denotes that the `ith` building is a restaurant. As a city official, you would like to **select** 3 buildings for random inspection. However, to ensure variety, **no two consecutive** buildings out of the **selected** buildings can be of the same type. * For example, given `s = 0**0**1**1**0**1** `, we cannot select the `1st`, `3rd`, and `5th` buildings as that would form `0**11** ` which is **not** allowed due to having two consecutive buildings of the same type. Return _the **number of valid ways** to select 3 buildings._ **Example 1:** **Input:** s = 001101 **Output:** 6 **Explanation:** The following sets of indices selected are valid: [0,2,4] from **0**0**1**1**0**1 forms 010 [0,3,4] from **0**01**10**1 forms 010 [1,2,4] from 0**01**1**0**1 forms 010 [1,3,4] from 0**0**1**10**1 forms 010 [2,4,5] from 00**1**1**01** forms 101 [3,4,5] from 001**101** forms 101 No other selection is valid. Thus, there are 6 total ways. **Example 2:** **Input:** s = 11100 **Output:** 0 **Explanation:** It can be shown that there are no valid selections. **Constraints:** * `3 <= s.length <= 105` * `s[i]` is either `\'0\'` or `\'1\'`.","completion":"def abbreviated_product(left: int, right: int) -> str: product = 1 for i in range(left, right + 1): product *= i return str(product)"},{"prompt":"Given an integer `n`, return `true` _if_ `n` _has **exactly three positive divisors**. Otherwise, return_ `false`. An integer `m` is a **divisor** of `n` if there exists an integer `k` such that `n = k * m`. **Example 1:** **Input:** n = 2 **Output:** false **Explantion:** 2 has only two divisors: 1 and 2. **Example 2:** **Input:** n = 4 **Output:** true **Explantion:** 4 has three divisors: 1, 2, and 4. **Constraints:** * `1 <= n <= 104`","completion":"def minSideJumps(obstacles): n = len(obstacles) dp = [[n] * 3 for _ in range(n)] dp[0][1] = 0 dp[0][0] = dp[0][2] = 1 for i in range(1, n): if obstacles[i] != 1: dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1) if obstacles[i] != 2: dp[i][1] = min(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1) if obstacles[i] != 3: dp[i][2] = min(dp[i - 1][2], dp[i - 1][0] + 1, dp[i - 1][1] + 1) return min(dp[-1])"},{"prompt":"an **infinite** chess board with coordinates from `infinity` to `+infinity`, you have a **knight** at square `[0, 0]`. A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction. Return _the minimum number of steps needed to move the knight to the square_ `[x, y]`. It is guaranteed the answer exists. **Example 1:** **Input:** x = 2, y = 1 **Output:** 1 **Explanation:** [0, 0] > [2, 1] **Example 2:** **Input:** x = 5, y = 5 **Output:** 4 **Explanation:** [0, 0] > [2, 1] > [4, 2] > [3, 4] > [5, 5] **Constraints:** * `300 <= x, y <= 300` * `0 <= |x| + |y| <= 300` t, evaluating to True; f, evaluating to False; !(expression), evaluating to the logical NOT of the expression inside the parentheses; &(expression1,expression2,...), evaluating to the logical AND of 2 or more expressions; |(expression1,expression2,...), evaluating to the logical OR of 2 or more expressions.","completion":"def parse_bool_expr(expression, pos=None): if pos is None: pos = [0] current = expression[pos[0]] pos[0] += 1 if current == \'t\': return True if current == \'f\': return False if current == \'!\': pos[0] += 1 return not parse_bool_expr(expression, pos) if current == \'&\': pos[0] += 1 result = True while expression[pos[0]] != \')\': result &= parse_bool_expr(expression, pos) if expression[pos[0]] == \',\': pos[0] += 1 elif current == \'|\': pos[0] += 1 result = False while expression[pos[0]] != \')\': result |= parse_bool_expr(expression, pos) if expression[pos[0]] == \',\': pos[0] += 1 pos[0] += 1 return result"},{"prompt":"Given two integers `num1` and `num2`, return _the **sum** of the two integers_. **Example 1:** **Input:** num1 = 12, num2 = 5 **Output:** 17 **Explanation:** num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned. **Example 2:** **Input:** num1 = 10, num2 = 4 **Output:** 6 **Explanation:** num1 + num2 = 6, so 6 is returned. **Constraints:** * `100 <= num1, num2 <= 100`","completion":"def capitalize_title(title): return \' \'.join([word.capitalize() for word in title.split(\' \')])"},{"prompt":"The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given `n`, return the value of Tn. **Example 1:** **Input:** n = 4 **Output:** 4 **Explanation:** T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 **Example 2:** **Input:** n = 25 **Output:** 1389537 **Constraints:** * `0 <= n <= 37` * The answer is guaranteed to fit within a 32bit integer, ie. `answer <= 2^31 1`.","completion":"def height_checker(heights): expected = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != expected[i]: count += 1 return count"},{"prompt":"There are `n` houses evenly lined up on the street, and each house is beautifully painted. You are given a **0indexed** integer array `colors` of length `n`, where `colors[i]` represents the color of the `ith` house. Return _the **maximum** distance between **two** houses with **different** colors_. The distance between the `ith` and `jth` houses is `abs(i j)`, where `abs(x)` is the **absolute value** of `x`. **Example 1:** **Input:** colors = [**1**,1,1,**6**,1,1,1] **Output:** 3 **Explanation:** In the above image, color 1 is blue, and color 6 is red. The furthest two houses with different colors are house 0 and house 3. House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 3) = 3. Note that houses 3 and 6 can also produce the optimal answer. **Example 2:** **Input:** colors = [**1**,8,3,8,**3**] **Output:** 4 **Explanation:** In the above image, color 1 is blue, color 8 is yellow, and color 3 is green. The furthest two houses with different colors are house 0 and house 4. House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 4) = 4. **Example 3:** **Input:** colors = [**0**,**1**] **Output:** 1 **Explanation:** The furthest two houses with different colors are house 0 and house 1. House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 1) = 1. **Constraints:** * `n == colors.length` * `2 <= n <= 100` * `0 <= colors[i] <= 100` * Test data are generated such that **at least** two houses have different colors.","completion":"from itertools import permutations def maxCompatibilitySum(students, mentors): ans = 0 for mentors_perm in permutations(mentors): cur_sum = sum(sum(a == b for a, b in zip(student, mentor)) for student, mentor in zip(students, mentors_perm)) ans = max(ans, cur_sum) return ans"},{"prompt":"You are given an integer array `arr` of length `n` that represents a permutation of the integers in the range `[0, n 1]`. We split `arr` into some number of **chunks** (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return _the largest number of chunks we can make to sort the array_. **Example 1:** **Input:** arr = [4,3,2,1,0] **Output:** 1 **Explanation:** Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn\'t sorted. **Example 2:** **Input:** arr = [1,0,2,3,4] **Output:** 4 **Explanation:** We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. **Constraints:** * `n == arr.length` * `1 <= n <= 10` * `0 <= arr[i] < n` * All the elements of `arr` are **unique**.","completion":"def orderOfLargestPlusSign(n, mines): grid = [[1] * n for _ in range(n)] for mine in mines: grid[mine[0]][mine[1]] = 0 left, right, up, down = [list(grid) for _ in range(4)] for i in range(n): for j in range(n): if grid[i][j]: left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0) up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0) ans = 0 for i in range(n - 1, -1, -1): for j in range(n - 1, -1, -1): if grid[i][j]: right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0) down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0) ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]])) return ans"},{"prompt":"You are given an array `nums` consisting of positive integers. Split the array into **one or more** disjoint subarrays such that: * Each element of the array belongs to **exactly one** subarray, and * The **GCD** of the elements of each subarray is strictly greater than `1`. Return _the minimum number of subarrays that can be obtained after the split_. **Note** that: * The **GCD** of a subarray is the largest positive integer that evenly divides all the elements of the subarray. * A **subarray** is a contiguous part of the array. **Example 1:** **Input:** nums = [12,6,3,14,8] **Output:** 2 **Explanation:** We can split the array into the subarrays: [12,6,3] and [14,8]. The GCD of 12, 6 and 3 is 3, which is strictly greater than 1. The GCD of 14 and 8 is 2, which is strictly greater than 1. It can be shown that splitting the array into one subarray will make the GCD = 1. **Example 2:** **Input:** nums = [4,12,6,14] **Output:** 1 **Explanation:** We can split the array into only one subarray, which is the whole array. **Constraints:** * `1 <= nums.length <= 2000` * `2 <= nums[i] <= 109`","completion":"def min_arrays(nums): def gcd(a, b): return a if b == 0 else gcd(b, a % b) total_gcd = nums[0] for num in nums[1:]: total_gcd = gcd(total_gcd, num) return 2 if total_gcd == 1 else 1"},{"prompt":"Given a positive integer `n`, return the number of the integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones. **Example 1:** **Input:** n = 5 **Output:** 5 **Explanation:** Here are the nonnegative integers <= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. **Example 2:** **Input:** n = 1 **Output:** 2 **Example 3:** **Input:** n = 2 **Output:** 3 **Constraints:** * `1 <= n <= 109`","completion":"def findIntegers(n: int) -> int: dp = [[0, 0] for _ in range(32)] dp[0][0], dp[0][1] = 1, 1 for i in range(1, 32): dp[i][0] = dp[i - 1][0] + dp[i - 1][1] dp[i][1] = dp[i - 1][0] ans = 0 prev_bit = 0 for i in range(30, -1, -1): if n & (1 << i): ans += dp[i][0] if prev_bit: break prev_bit = 1 else: prev_bit = 0 return ans + 1"},{"prompt":"Given an integer array `nums` of size `n`, return _the number with the value **closest** to_ `0` _in_ `nums`. If there are multiple answers, return _the number with the **largest** value_. **Example 1:** **Input:** nums = [4,2,1,4,8] **Output:** 1 **Explanation:** The distance from 4 to 0 is |4| = 4. The distance from 2 to 0 is |2| = 2. The distance from 1 to 0 is |1| = 1. The distance from 4 to 0 is |4| = 4. The distance from 8 to 0 is |8| = 8. Thus, the closest number to 0 in the array is 1. **Example 2:** **Input:** nums = [2,1,1] **Output:** 1 **Explanation:** 1 and 1 are both the closest numbers to 0, so 1 being larger is returned. **Constraints:** * `1 <= n <= 1000` * `105 <= nums[i] <= 105`","completion":"def robot_instructions(n: int, start_pos: list, s: str) -> list: answer = [0] * len(s) for idx in range(len(s)): row, col = start_pos for i in range(idx, len(s)): move = s[i] if move == \'L\': col -= 1 elif move == \'R\': col += 1 elif move == \'U\': row -= 1 elif move == \'D\': row += 1 if row < 0 or row >= n or col < 0 or col >= n: break answer[idx] += 1 return answer"},{"prompt":"You are given an **even** integer `n`​​​​​​. You initially have a permutation `perm` of size `n`​​ where `perm[i] == i`​ **(0indexed)**​​​​. In one operation, you will create a new array `arr`, and for each `i`: * If `i % 2 == 0`, then `arr[i] = perm[i / 2]`. * If `i % 2 == 1`, then `arr[i] = perm[n / 2 + (i 1) / 2]`. You will then assign `arr`​​​​ to `perm`. Return _the minimum **nonzero** number of operations you need to perform on_ `perm` _to return the permutation to its initial value._ **Example 1:** **Input:** n = 2 **Output:** 1 **Explanation:** perm = [0,1] initially. After the 1st operation, perm = [0,1] So it takes only 1 operation. **Example 2:** **Input:** n = 4 **Output:** 2 **Explanation:** perm = [0,1,2,3] initially. After the 1st operation, perm = [0,2,1,3] After the 2nd operation, perm = [0,1,2,3] So it takes only 2 operations. **Example 3:** **Input:** n = 6 **Output:** 4 **Constraints:** * `2 <= n <= 1000` * `n`​​​​​​ is even.","completion":"def numberOfMatches(n): return n - 1"},{"prompt":"You are given an array of unique strings `words` where `words[i]` is six letters long. One word of `words` was chosen as a secret word. You are also given the helper object `Master`. You may call `Master.guess(word)` where `word` is a sixletterlong string, and it must be from `words`. `Master.guess(word)` returns: * `1` if `word` is not from `words`, or * an integer representing the number of exact matches (value and position) of your guess to the secret word. There is a parameter `allowedGuesses` for each test case where `allowedGuesses` is the maximum number of times you can call `Master.guess(word)`. For each test case, you should call `Master.guess` with the secret word without exceeding the maximum number of allowed guesses. You will get: * **`Either you took too many guesses, or you did not find the secret word. `** if you called `Master.guess` more than `allowedGuesses` times or if you did not call `Master.guess` with the secret word, or * **`You guessed the secret word correctly. `** if you called `Master.guess` with the secret word with the number of calls to `Master.guess` less than or equal to `allowedGuesses`. The test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method). **Example 1:** **Input:** secret = acckzz , words = [ acckzz , ccbazz , eiowzz , abcczz ], allowedGuesses = 10 **Output:** You guessed the secret word correctly. **Explanation:** master.guess( aaaaaa ) returns 1, because aaaaaa is not in wordlist. master.guess( acckzz ) returns 6, because acckzz is secret and has all 6 matches. master.guess( ccbazz ) returns 3, because ccbazz has 3 matches. master.guess( eiowzz ) returns 2, because eiowzz has 2 matches. master.guess( abcczz ) returns 4, because abcczz has 4 matches. We made 5 calls to master.guess, and one of them was the secret, so we pass the test case. **Example 2:** **Input:** secret = hamada , words = [ hamada , khaled ], allowedGuesses = 10 **Output:** You guessed the secret word correctly. **Explanation:** Since there are two words, you can guess both. **Constraints:** * `1 <= words.length <= 100` * `words[i].length == 6` * `words[i]` consist of lowercase English letters. * All the strings of `wordlist` are **unique**. * `secret` exists in `words`. * `10 <= allowedGuesses <= 30`","completion":"def numFactoredBinaryTrees(arr): MOD = 10**9 + 7 n = len(arr) arr.sort() dp = {} for i, x in enumerate(arr): dp[x] = 1 for y in arr[:i]: if x % y == 0 and x // y in dp: dp[x] = (dp[x] + dp[y] * dp[x // y]) % MOD return sum(dp.values()) % MOD"},{"prompt":"Given an array of positive integers `nums`, return the _maximum possible sum of an **ascending** subarray in_ `nums`. A subarray is defined as a contiguous sequence of numbers in an array. A subarray `[numsl, numsl+1, ..., numsr1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**. **Example 1:** **Input:** nums = [10,20,30,5,10,50] **Output:** 65 **Explanation:** [5,10,50] is the ascending subarray with the maximum sum of 65. **Example 2:** **Input:** nums = [10,20,30,40,50] **Output:** 150 **Explanation:** [10,20,30,40,50] is the ascending subarray with the maximum sum of 150. **Example 3:** **Input:** nums = [12,17,15,13,10,11,12] **Output:** 33 **Explanation:** [10,11,12] is the ascending subarray with the maximum sum of 33. **Constraints:** * `1 <= nums.length <= 100` * `1 <= nums[i] <= 100`","completion":"def concatenated_binary(n: int) -> int: result = 0 mod = 1000000007 for i in range(1, n + 1): length = len(bin(i)) - 2 result = ((result << length) % mod + i) % mod return result"},{"prompt":"You are given a **0indexed** array of strings `words`. Each string consists of **lowercase English letters** only. No letter occurs more than once in any string of `words`. Two strings `s1` and `s2` are said to be **connected** if the set of letters of `s2` can be obtained from the set of letters of `s1` by any **one** of the following operations: * Adding exactly one letter to the set of the letters of `s1`. * Deleting exactly one letter from the set of the letters of `s1`. * Replacing exactly one letter from the set of the letters of `s1` with any letter, **including** itself. The array `words` can be divided into one or more nonintersecting **groups**. A string belongs to a group if any **one** of the following is true: * It is connected to **at least one** other string of the group. * It is the **only** string present in the group. Note that the strings in `words` should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique. Return _an array_ `ans` _of size_ `2` _where:_ * `ans[0]` _is the **maximum number** of groups_ `words` _can be divided into, and_ * `ans[1]` _is the **size of the largest** group_. **Example 1:** **Input:** words = [ a , b , ab , cde ] **Output:** [2,3] **Explanation:** words[0] can be used to obtain words[1] (by replacing \'a\' with \'b\'), and words[2] (by adding \'b\'). So words[0] is connected to words[1] and words[2]. words[1] can be used to obtain words[0] (by replacing \'b\' with \'a\'), and words[2] (by adding \'a\'). So words[1] is connected to words[0] and words[2]. words[2] can be used to obtain words[0] (by deleting \'b\'), and words[1] (by deleting \'a\'). So words[2] is connected to words[0] and words[1]. words[3] is not connected to any string in words. Thus, words can be divided into 2 groups [ a , b , ab ] and [ cde ]. The size of the largest group is 3. **Example 2:** **Input:** words = [ a , ab , abc ] **Output:** [1,3] **Explanation:** words[0] is connected to words[1]. words[1] is connected to words[0] and words[2]. words[2] is connected to words[1]. Since all strings are connected to each other, they should be grouped together. Thus, the size of the largest group is 3. **Constraints:** * `1 <= words.length <= 2 * 104` * `1 <= words[i].length <= 26` * `words[i]` consists of lowercase English letters only. * No letter occurs more than once in `words[i]`.","completion":"from heapq import heappop, heappush def smallest_subsequence(s, k, letter, repetition): result = [] letter_count = s.count(letter) pq = [] for c in s: if c <= letter or letter_count > repetition: while pq and pq[0] > c: if heappop(pq) == letter: letter_count -= 1 heappush(pq, c) if len(pq) > k: heappop(pq) if k - len(pq) == repetition: letter_count -= 1 repetition = max(0, repetition) return \\"\\".join(pq)"},{"prompt":"Given an integer array `arr` and a target value `target`, return the integer `value` such that when we change all the integers larger than `value` in the given array to be equal to `value`, the sum of the array gets as close as possible (in absolute difference) to `target`. In case of a tie, return the minimum such integer. Notice that the answer is not neccesarilly a number from `arr`. **Example 1:** **Input:** arr = [4,9,3], target = 10 **Output:** 3 **Explanation:** When using 3 arr converts to [3, 3, 3] which sums 9 and that\'s the optimal answer. **Example 2:** **Input:** arr = [2,3,5], target = 10 **Output:** 5 **Example 3:** **Input:** arr = [60864,25176,27249,21296,20204], target = 56803 **Output:** 11361 **Constraints:** * `1 <= arr.length <= 104` * `1 <= arr[i], target <= 105`","completion":"from collections import defaultdict def criticalConnections(n, connections): graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) ans = [] low, disc = [-1] * n, [-1] * n time = [0] def dfs(u, parent): low[u] = disc[u] = time[0] time[0] += 1 for v in graph[u]: if v == parent: continue if disc[v] == -1: dfs(v, u) low[u] = min(low[u], low[v]) if low[v] > disc[u]: ans.append([u, v]) else: low[u] = min(low[u], disc[v]) dfs(0, -1) return ans"},{"prompt":"Given an array `nums` and an integer `target`, return _the maximum number of **nonempty** **nonoverlapping** subarrays such that the sum of values in each subarray is equal to_ `target`. **Example 1:** **Input:** nums = [1,1,1,1,1], target = 2 **Output:** 2 **Explanation:** There are 2 nonoverlapping subarrays [**1,1**,1,**1,1**] with sum equals to target(2). **Example 2:** **Input:** nums = [1,3,5,1,4,2,9], target = 6 **Output:** 2 **Explanation:** There are 3 subarrays with sum equal to 6. ([5,1], [4,2], [3,5,1,4,2,9]) but only the first 2 are nonoverlapping. **Constraints:** * `1 <= nums.length <= 105` * `104 <= nums[i] <= 104` * `0 <= target <= 106`","completion":"def maxNonOverlapping(nums, target): prefix_sum = {0: 0} sum, count = 0, 0 for num in nums: sum += num if sum - target in prefix_sum: count = max(count, 1 + prefix_sum[sum - target]) prefix_sum[sum] = count return count"},{"prompt":"You are given a string `s` and an integer `k`. You can choose one of the first `k` letters of `s` and append it at the end of the string.. Return _the lexicographically smallest string you could have after applying the mentioned step any number of moves_. **Example 1:** **Input:** s = cba , k = 1 **Output:** acb **Explanation:** In the first move, we move the 1st character \'c\' to the end, obtaining the string bac . In the second move, we move the 1st character \'b\' to the end, obtaining the final result acb . **Example 2:** **Input:** s = baaca , k = 3 **Output:** aaabc **Explanation:** In the first move, we move the 1st character \'b\' to the end, obtaining the string aacab . In the second move, we move the 3rd character \'c\' to the end, obtaining the final result aaabc . **Constraints:** * `1 <= k <= s.length <= 1000` * `s` consist of lowercase English letters.","completion":"def longest_distance(n): last = -1 longest = 0 i = 0 while n: if n & 1: if last >= 0: longest = max(longest, i - last) last = i n >>= 1 i += 1 return longest"},{"prompt":"You are given a string `s` and an integer `k`, a `k` **duplicate removal** consists of choosing `k` adjacent and equal letters from `s` and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make `k` **duplicate removals** on `s` until we no longer can. Return _the final string after all such duplicate removals have been made_. It is guaranteed that the answer is **unique**. **Example 1:** **Input:** s = abcd , k = 2 **Output:** abcd **Explanation:** There\'s nothing to delete. **Example 2:** **Input:** s = deeedbbcccbdaa , k = 3 **Output:** aa **Explanation:** First delete eee and ccc , get ddbbbdaa Then delete bbb , get dddaa Finally delete ddd , get aa **Example 3:** **Input:** s = pbbcggttciiippooaais , k = 2 **Output:** ps **Constraints:** * `1 <= s.length <= 105` * `2 <= k <= 104` * `s` only contains lowercase English letters.","completion":"def removeDuplicates(s: str, k: int) -> str: stack = [] for c in s: if not stack or stack[-1][0] != c: stack.append((c, 1)) elif stack[-1][1] + 1 != k: stack[-1] = (c, stack[-1][1] + 1) else: stack.pop() return \'\'.join(c * count for c, count in stack)"},{"prompt":"We distribute some number of `candies`, to a row of **`n = num_people`** people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give `n` candies to the last person. Then, we go back to the start of the row, giving `n + 1` candies to the first person, `n + 2` candies to the second person, and so on until we give `2 * n` candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length `num_people` and sum `candies`) that represents the final distribution of candies. **Example 1:** **Input:** candies = 7, num_people = 4 **Output:** [1,2,3,1] **Explanation:** On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1]. **Example 2:** **Input:** candies = 10, num_people = 3 **Output:** [5,2,3] **Explanation:** On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. **Constraints:** * 1 <= candies <= 10^9 * 1 <= num_people <= 1000","completion":"def distribute_candies(candies, num_people): result = [0] * num_people i = 0 count = 1 while candies > 0: result[i % num_people] += min(candies, count) candies -= count count += 1 i += 1 return result"},{"prompt":"An `n x n` grid is composed of `1 x 1` squares where each `1 x 1` square consists of a `\'/\'`, `\'\'`, or blank space `\' \'`. These characters divide the square into contiguous regions. Given the grid `grid` represented as a string array, return _the number of regions_. Note that backslash characters are escaped, so a `\'\'` is represented as `\'\'`. **Example 1:** **Input:** grid = [ / , / ] **Output:** 2 **Example 2:** **Input:** grid = [ / , ] **Output:** 1 **Example 3:** **Input:** grid = [ / , / ] **Output:** 5 **Explanation:** Recall that because characters are escaped, / refers to /, and / refers to /. **Constraints:** * `n == grid.length == grid[i].length` * `1 <= n <= 30` * `grid[i][j]` is either `\'/\'`, `\'\'`, or `\' \'`.","completion":"def threeSumMulti(arr, target): MOD = 1000000007 ans = 0 arr.sort() n = len(arr) for i in range(n - 2): j, k = i + 1, n - 1 while j < k: s = arr[i] + arr[j] + arr[k] if s > target: k -= 1 elif s < target: j += 1 else: if arr[j] != arr[k]: left_count = right_count = 1 while j < n - 1 and arr[j] == arr[j + 1]: left_count += 1 j += 1 while k > 0 and arr[k] == arr[k - 1]: right_count += 1 k -= 1 ans += left_count * right_count ans %= MOD j += 1 k -= 1 else: ans += (k - j + 1) * (k - j) // 2 ans %= MOD break return ans"},{"prompt":"a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: 1. The town judge trusts nobody. 2. Everybody (except for the town judge) trusts the town judge. 3. There is exactly one person that satisfies properties **1** and **2**. You are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`. If a trust relationship does not exist in `trust` array, then such a trust relationship does not exist. Return _the label of the town judge if the town judge exists and can be identified, or return_ `1` _otherwise_. **Example 1:** **Input:** n = 2, trust = [[1,2]] **Output:** 2 **Example 2:** **Input:** n = 3, trust = [[1,3],[2,3]] **Output:** 3 **Example 3:** **Input:** n = 3, trust = [[1,3],[2,3],[3,1]] **Output:** 1 **Constraints:** * `1 <= n <= 1000` * `0 <= trust.length <= 104` * `trust[i].length == 2` * All the pairs of `trust` are **unique**. * `ai != bi` * `1 <= ai, bi <= n`","completion":"def findJudge(n, trust): trust_counts = [0] * (n + 1) for a, b in trust: trust_counts[a] -= 1 trust_counts[b] += 1 for i in range(1, n + 1): if trust_counts[i] == n - 1: return i return -1"},{"prompt":"You are given a 2D integer array `items` where `items[i] = [pricei, beautyi]` denotes the **price** and **beauty** of an item respectively. You are also given a **0indexed** integer array `queries`. For each `queries[j]`, you want to determine the **maximum beauty** of an item whose **price** is **less than or equal** to `queries[j]`. If no such item exists, then the answer to this query is `0`. Return _an array_ `answer` _of the same length as_ `queries` _where_ `answer[j]` _is the answer to the_ `jth` _query_. **Example 1:** **Input:** items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6] **Output:** [2,4,5,5,6,6] **Explanation:** For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2. For queries[1]=2, the items which can be considered are [1,2] and [2,4]. The maximum beauty among them is 4. For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5]. The maximum beauty among them is 5. For queries[4]=5 and queries[5]=6, all items can be considered. Hence, the answer for them is the maximum beauty of all items, i.e., 6. **Example 2:** **Input:** items = [[1,2],[1,2],[1,3],[1,4]], queries = [1] **Output:** [4] **Explanation:** The price of every item is equal to 1, so we choose the item with the maximum beauty 4. Note that multiple items can have the same price and/or beauty. **Example 3:** **Input:** items = [[10,1000]], queries = [5] **Output:** [0] **Explanation:** No item has a price less than or equal to 5, so no item can be chosen. Hence, the answer to the query is 0. **Constraints:** * `1 <= items.length, queries.length <= 105` * `items[i].length == 2` * `1 <= pricei, beautyi, queries[j] <= 109`","completion":"from bisect import bisect_right def maxPrices(items, queries): answer = [] sorted_items = [item[0] for item in items] sorted_items.sort() max_beauty = 0 for i, price in enumerate(sorted_items): max_beauty = max(max_beauty, items[i][1]) sorted_items[i] = max_beauty for query in queries: idx = bisect_right(sorted_items, query) - 1 answer.append(sorted_items[idx] if idx >= 0 else 0) return answer"},{"prompt":"There is a directed graph of `n` nodes with each node labeled from `0` to `n 1`. The graph is represented by a **0indexed** 2D integer array `graph` where `graph[i]` is an integer array of nodes adjacent to node `i`, meaning there is an edge from node `i` to each node in `graph[i]`. A node is a **terminal node** if there are no outgoing edges. A node is a **safe node** if every possible path starting from that node leads to a **terminal node** (or another safe node). Return _an array containing all the **safe nodes** of the graph_. The answer should be sorted in **ascending** order. **Example 1:** **Input:** graph = [[1,2],[2,3],[5],[0],[5],[],[]] **Output:** [2,4,5,6] **Explanation:** The given graph is shown above. Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them. Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6. **Example 2:** **Input:** graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] **Output:** [4] **Explanation:** Only node 4 is a terminal node, and every path starting at node 4 leads to node 4. **Constraints:** * `n == graph.length` * `1 <= n <= 104` * `0 <= graph[i].length <= n` * `0 <= graph[i][j] <= n 1` * `graph[i]` is sorted in a strictly increasing order. * The graph may contain selfloops. * The number of edges in the graph will be in the range `[1, 4 * 104]`.","completion":"import heapq def kthSmallestPrimeFraction(arr, k): pq = [(-arr[i] / arr[-1], i, len(arr) - 1) for i in range(len(arr) - 1)] heapq.heapify(pq) for _ in range(k - 1): frac, i, j = heapq.heappop(pq) j -= 1 if i < j: heapq.heappush(pq, (-arr[i] / arr[j], i, j)) frac, i, j = heapq.heappop(pq) return [arr[i], arr[j]]"},{"prompt":"Given the `root` of an Nary tree of unique values, and two nodes of the tree `p` and `q`. You should move the subtree of the node `p` to become a direct child of node `q`. If `p` is already a direct child of `q`, do not change anything. Node `p` **must be** the last child in the children list of node `q`. Return _the root of the tree_ after adjusting it. There are 3 cases for nodes `p` and `q`: 1. Node `q` is in the subtree of node `p`. 2. Node `p` is in the subtree of node `q`. 3. Neither node `p` is in the subtree of node `q` nor node `q` is in the subtree of node `p`. In cases 2 and 3, you just need to move `p` (with its subtree) to be a child of `q`, but in case 1 the tree may be disconnected, thus you need to reconnect the tree again. **Please read the examples carefully before solving this problem.** _NaryTree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples)._ For example, the above tree is serialized as `[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`. **Example 1:** **Input:** root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1 **Output:** [1,null,2,3,4,null,5,null,6,null,7,8] **Explanation:** This example follows the second case as node p is in the subtree of node q. We move node p with its subtree to be a direct child of node q. Notice that node 4 is the last child of node 1. **Example 2:** **Input:** root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4 **Output:** [1,null,2,3,null,4,5,null,6,null,7,8] **Explanation:** Node 7 is already a direct child of node 4. We don\'t change anything. **Example 3:** **Input:** root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8 **Output:** [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6] **Explanation:** This example follows case 3 because node p is not in the subtree of node q and viceversa. We can move node 3 with its subtree and make it as node 8\'s child. **Constraints:** * The total number of nodes is between `[2, 1000]`. * Each node has a **unique** value. * `p != null` * `q != null` * `p` and `q` are two different nodes (i.e. `p != q`).","completion":"def get_happy_string(n, k): def dfs(s, prev): if len(s) == n: happy_strings.append(s) return for c in \'abc\': if c != prev: dfs(s + c, c) happy_strings = [] dfs(\\"\\", \' \') return happy_strings[k - 1] if k <= len(happy_strings) else \\"\\""},{"prompt":"We can use runlength encoding (i.e., **RLE**) to encode a sequence of integers. In a runlength encoded array of even length `encoding` (**0indexed**), for all even `i`, `encoding[i]` tells us the number of times that the nonnegative integer value `encoding[i + 1]` is repeated in the sequence. * For example, the sequence `arr = [8,8,8,5,5]` can be encoded to be `encoding = [3,8,2,5]`. `encoding = [3,8,0,9,2,5]` and `encoding = [2,8,1,8,2,5]` are also valid **RLE** of `arr`. Given a runlength encoded array, design an iterator that iterates through it. Implement the `RLEIterator` class: * `RLEIterator(int[] encoded)` Initializes the object with the encoded array `encoded`. * `int next(int n)` Exhausts the next `n` elements and returns the last element exhausted in this way. If there is no element left to exhaust, return `1` instead. **Example 1:** **Input** [ RLEIterator , next , next , next , next ] [[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]] **Output** [null, 8, 8, 5, 1] **Explanation** RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5]. rLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5]. rLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5]. rLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5]. rLEIterator.next(2); // exhausts 2 terms, returning 1. This is because the first term exhausted was 5, but the second term did not exist. Since the last term exhausted does not exist, we return 1. **Constraints:** * `2 <= encoding.length <= 1000` * `encoding.length` is even. * `0 <= encoding[i] <= 109` * `1 <= n <= 109` * At most `1000` calls will be made to `next`.","completion":"from itertools import permutations as perm def reorderedPowerOf2(n): for p in set(perm(str(n))): if p[0] != \'0\' and (bin(int(\'\'.join(p))).count(\'1\') == 1): return True return False"},{"prompt":"Given a string `s` consisting only of characters _a_, _b_ and _c_. Return the number of substrings containing **at least** one occurrence of all these characters _a_, _b_ and _c_. **Example 1:** **Input:** s = abcabc **Output:** 10 **Explanation:** The substrings containing at least one occurrence of the characters _a_, _b_ and _c are _abc _, _abca _, _abcab _, _abcabc _, _bca _, _bcab _, _bcabc _, _cab _, _cabc __ and __abc __ (**again**)_._ **Example 2:** **Input:** s = aaacb **Output:** 3 **Explanation:** The substrings containing at least one occurrence of the characters _a_, _b_ and _c are _aaacb _, _aacb __ and __acb _._ **Example 3:** **Input:** s = abc **Output:** 1 **Constraints:** * `3 <= s.length <= 5 x 10^4` * `s` only consists of _a_, _b_ or _c_ characters.","completion":"def find_pairs(z): pairs = [] def f(x, y): return x + y for x in range(1, z+1): for y in range(1, z+1): if f(x, y) == z: pairs.append((x, y)) return pairs"},{"prompt":"**HTML entity parser** is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself. The special characters and their entities for HTML are: * **Quotation Mark:** the entity is `&quot;` and symbol character is ``. * **Single Quote Mark:** the entity is `&apos;` and symbol character is `\'`. * **Ampersand:** the entity is `&amp;` and symbol character is `&`. * **Greater Than Sign:** the entity is `&gt;` and symbol character is `>`. * **Less Than Sign:** the entity is `&lt;` and symbol character is `<`. * **Slash:** the entity is `&frasl;` and symbol character is `/`. Given the input `text` string to the HTML parser, you have to implement the entity parser. Return _the text after replacing the entities by the special characters_. **Example 1:** **Input:** text = &amp; is an HTML entity but &ambassador; is not. **Output:** & is an HTML entity but &ambassador; is not. **Explanation:** The parser will replace the &amp; entity by & **Example 2:** **Input:** text = and I quote: &quot;...&quot; **Output:** and I quote: ... **Constraints:** * `1 <= text.length <= 105` * The string may contain any possible characters out of all the 256 ASCII characters.","completion":"def entity_parser(text: str) -> str: entities = { \\"&quot;\\": \\"\\"\\", \\"&apos;\\": \\"\'\\", \\"&amp;\\": \\"&\\", \\"&gt;\\": \\">\\", \\"&lt;\\": \\"<\\", \\"&frasl;\\": \\"/\\", } result = [] current_entity = [] in_entity = False for c in text: if in_entity: current_entity.append(c) if c == \';\': entity = \'\'.join(current_entity) if entity in entities: result.append(entities[entity]) else: result.extend(current_entity) in_entity = False current_entity.clear() else: if c == \'&\': in_entity = True current_entity.append(c) else: result.append(c) return \'\'.join(result)"},{"prompt":"Given a string `formula` representing a chemical formula, return _the count of each atom_. The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. One or more digits representing that element\'s count may follow if the count is greater than `1`. If the count is `1`, no digits will follow. * For example, `H2O ` and `H2O2 ` are possible, but `H1O2 ` is impossible. Two formulas are concatenated together to produce another formula. * For example, `H2O2He3Mg4 ` is also a formula. A formula placed in parentheses, and a count (optionally added) is also a formula. * For example, `(H2O2) ` and `(H2O2)3 ` are formulas. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than `1`), followed by the second name (in sorted order), followed by its count (if that count is more than `1`), and so on. The test cases are generated so that all the values in the output fit in a **32bit** integer. **Example 1:** **Input:** formula = H2O **Output:** H2O **Explanation:** The count of elements are {\'H\': 2, \'O\': 1}. **Example 2:** **Input:** formula = Mg(OH)2 **Output:** H2MgO2 **Explanation:** The count of elements are {\'H\': 2, \'Mg\': 1, \'O\': 2}. **Example 3:** **Input:** formula = K4(ON(SO3)2)2 **Output:** K4N2O14S4 **Explanation:** The count of elements are {\'K\': 4, \'N\': 2, \'O\': 14, \'S\': 4}. **Constraints:** * `1 <= formula.length <= 1000` * `formula` consists of English letters, digits, `\'(\'`, and `\')\'`. * `formula` is always valid.","completion":"from collections import Counter def parse(formula, i): counts = Counter() while i[0] < len(formula): if formula[i[0]] == \'(\': i[0] += 1 temp = parse(formula, i) count = 0 while i[0] < len(formula) and formula[i[0]].isdigit(): count = count * 10 + int(formula[i[0]]) i[0] += 1 if count == 0: count = 1 for name, c in temp.items(): counts[name] += c * count elif formula[i[0]] == \')\': i[0] += 1 return counts else: name = formula[i[0]] i[0] += 1 while i[0] < len(formula) and formula[i[0]].islower(): name += formula[i[0]] i[0] += 1 count = 0 while i[0] < len(formula) and formula[i[0]].isdigit(): count = count * 10 + int(formula[i[0]]) i[0] += 1 if count == 0: count = 1 counts[name] += count return counts def countOfAtoms(formula): i = [0] counts = parse(formula, i) ans = [] for name, count in counts.items(): ans.append(name) if count > 1: ans.append(str(count)) return \'\'.join(ans)"},{"prompt":"Given the array `nums`, obtain a subsequence of the array whose sum of elements is **strictly greater** than the sum of the non included elements in such subsequence. If there are multiple solutions, return the subsequence with **minimum size** and if there still exist multiple solutions, return the subsequence with the **maximum total sum** of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. Note that the solution with the given constraints is guaranteed to be **unique**. Also return the answer sorted in **nonincreasing** order. **Example 1:** **Input:** nums = [4,3,10,9,8] **Output:** [10,9] **Explanation:** The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements. **Example 2:** **Input:** nums = [4,4,7,6,7] **Output:** [7,7,6] **Explanation:** The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in nondecreasing order. **Constraints:** * `1 <= nums.length <= 500` * `1 <= nums[i] <= 100`","completion":"def min_changes_to_divide_string(s, k): n = len(s) if n % k != 0: return -1 chunk_count = n // k res = 0 for i in range(k): counts = [0] * 26 for j in range(i, n, k): counts[ord(s[j]) - ord(\'a\')] += 1 max_count = max(counts) res += chunk_count - max_count return res"},{"prompt":"For an integer array `nums`, an **inverse pair** is a pair of integers `[i, j]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`. Given two integers n and k, return the number of different arrays consist of numbers from `1` to `n` such that there are exactly `k` **inverse pairs**. Since the answer can be huge, return it **modulo** `109 + 7`. **Example 1:** **Input:** n = 3, k = 0 **Output:** 1 **Explanation:** Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. **Example 2:** **Input:** n = 3, k = 1 **Output:** 2 **Explanation:** The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. **Constraints:** * `1 <= n <= 1000` * `0 <= k <= 1000`","completion":"def kInversePairs(n: int, k: int) -> int: mod = 10**9 + 7 dp = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): dp[i][0] = 1 for j in range(1, k + 1): dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod if j - i >= 0: dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod return dp[n][k]"},{"prompt":"Given an integer array `nums` sorted in **nondecreasing** order, return _an array of **the squares of each number** sorted in nondecreasing order_. **Example 1:** **Input:** nums = [4,1,0,3,10] **Output:** [0,1,9,16,100] **Explanation:** After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. **Example 2:** **Input:** nums = [7,3,2,3,11] **Output:** [4,9,9,49,121] **Constraints:** * `1 <= nums.length <= 104` * `104 <= nums[i] <= 104` * `nums` is sorted in **nondecreasing** order.","completion":"def distinctSubseqII(s): mod = 10**9 + 7 n = len(s) dp = [0] * (n + 1) dp[0] = 1 last = [-1] * 26 for i in range(1, n + 1): dp[i] = (dp[i - 1] * 2) % mod if last[ord(s[i - 1]) - ord(\'a\')] != -1: dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord(\'a\')]] + mod) % mod last[ord(s[i - 1]) - ord(\'a\')] = i - 1 dp[n] = (dp[n] - 1 + mod) % mod return dp[n]"},{"prompt":"Bob is standing at cell `(0, 0)`, and he wants to reach `destination`: `(row, column)`. He can only travel **right** and **down**. You are going to help Bob by providing **instructions** for him to reach `destination`. The **instructions** are represented as a string, where each character is either: * `\'H\'`, meaning move horizontally (go **right**), or * `\'V\'`, meaning move vertically (go **down**). Multiple **instructions** will lead Bob to `destination`. For example, if `destination` is `(2, 3)`, both `HHHVV ` and `HVHVH ` are valid **instructions**. However, Bob is very picky. Bob has a lucky number `k`, and he wants the `kth` **lexicographically smallest instructions** that will lead him to `destination`. `k` is **1indexed**. Given an integer array `destination` and an integer `k`, return _the_ `kth` _**lexicographically smallest instructions** that will take Bob to_ `destination`. **Example 1:** **Input:** destination = [2,3], k = 1 **Output:** HHHVV **Explanation:** All the instructions that reach (2, 3) in lexicographic order are as follows: [ HHHVV , HHVHV , HHVVH , HVHHV , HVHVH , HVVHH , VHHHV , VHHVH , VHVHH , VVHHH ]. **Example 2:** **Input:** destination = [2,3], k = 2 **Output:** HHVHV **Example 3:** **Input:** destination = [2,3], k = 3 **Output:** HHVVH **Constraints:** * `destination.length == 2` * `1 <= row, column <= 15` * `1 <= k <= nCr(row + column, row)`, where `nCr(a, b)` denotes `a` choose `b`​​​​​.","completion":"from collections import defaultdict def dfs(node, tree, labels, ans, count): prev_count = count[labels[node]] count[labels[node]] += 1 ans[node] = count[labels[node]] - prev_count for child in tree[node]: dfs(child, tree, labels, ans, count) count[labels[node]] = prev_count def countSubTrees(n, edges, labels): tree = defaultdict(list) for edge in edges: tree[edge[1]].append(edge[0]) ans = [0] * n count = defaultdict(int) dfs(0, tree, labels, ans, count) return ans"},{"prompt":"Given a string `s`. Return all the words vertically in the same order in which they appear in `s`. Words are returned as a list of strings, complete with spaces when is necessary. (Trailing spaces are not allowed). Each word would be put on only one column and that in one column there will be only one word. **Example 1:** **Input:** s = HOW ARE YOU **Output:** [ HAY , ORO , WEU ] **Explanation:** Each word is printed vertically. HAY ORO WEU **Example 2:** **Input:** s = TO BE OR NOT TO BE **Output:** [ TBONTB , OEROOE , T ] **Explanation:** Trailing spaces is not allowed. TBONTB OEROOE T **Example 3:** **Input:** s = CONTEST IS COMING **Output:** [ CIC , OSO , N M , T I , E N , S G , T ] **Constraints:** * `1 <= s.length <= 200` * `s` contains only upper case English letters. * It\'s guaranteed that there is only one space between 2 words.","completion":"def findBall(grid): m, n = len(grid), len(grid[0]) result = [-1] * n for i in range(n): x, y = 0, i while x < m: nx, ny = x + 1, y + grid[x][y] if ny < 0 or ny >= n or grid[x][ny] != grid[x][y]: break x, y = nx, ny if x == m: result[i] = y return result"},{"prompt":"You are given an array of strings `names`, and an array `heights` that consists of **distinct** positive integers. Both arrays are of length `n`. For each index `i`, `names[i]` and `heights[i]` denote the name and height of the `ith` person. Return `names` _sorted in **descending** order by the people\'s heights_. **Example 1:** **Input:** names = [ Mary , John , Emma ], heights = [180,165,170] **Output:** [ Mary , Emma , John ] **Explanation:** Mary is the tallest, followed by Emma and John. **Example 2:** **Input:** names = [ Alice , Bob , Bob ], heights = [155,185,150] **Output:** [ Bob , Alice , Bob ] **Explanation:** The first Bob is the tallest, followed by Alice and the second Bob. **Constraints:** * `n == names.length == heights.length` * `1 <= n <= 103` * `1 <= names[i].length <= 20` * `1 <= heights[i] <= 105` * `names[i]` consists of lower and upper case English letters. * All the values of `heights` are distinct.","completion":"def sort_names_by_height(names, heights): name_height_pairs = sorted(zip(heights, names), reverse=True) sorted_names = [pair[1] for pair in name_height_pairs] return sorted_names"},{"prompt":"**Special binary strings** are binary strings with the following two properties: * The number of `0`\'s is equal to the number of `1`\'s. * Every prefix of the binary string has at least as many `1`\'s as `0`\'s. You are given a **special binary** string `s`. A move consists of choosing two consecutive, nonempty, special substrings of `s`, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string. Return _the lexicographically largest resulting string possible after applying the mentioned operations on the string_. **Example 1:** **Input:** s = 11011000 **Output:** 11100100 **Explanation:** The strings 10 [occuring at s[1]] and 1100 [at s[3]] are swapped. This is the lexicographically largest string possible after some number of swaps. **Example 2:** **Input:** s = 10 **Output:** 10 **Constraints:** * `1 <= s.length <= 50` * `s[i]` is either `\'0\'` or `\'1\'`. * `s` is a special binary string.","completion":"def makeLargestSpecial(s: str) -> str: count, i = 0, 0 subs = [] for j in range(len(s)): if s[j] == \'1\': count += 1 else: count -= 1 if count == 0: subs.append(\\"1\\" + makeLargestSpecial(s[i+1:j]) + \\"0\\") i = j + 1 subs.sort(reverse=True) return \\"\\".join(subs)"},{"prompt":"On an alphabet board, we start at position `(0, 0)`, corresponding to character `board[0][0]`. Here, `board = [ abcde , fghij , klmno , pqrst , uvwxy , z ]`, as shown in the diagram below. We may make the following moves: * `\'U\'` moves our position up one row, if the position exists on the board; * `\'D\'` moves our position down one row, if the position exists on the board; * `\'L\'` moves our position left one column, if the position exists on the board; * `\'R\'` moves our position right one column, if the position exists on the board; * `\'!\'` adds the character `board[r][c]` at our current position `(r, c)` to the answer. (Here, the only positions that exist on the board are positions with letters on them.) Return a sequence of moves that makes our answer equal to `target` in the minimum number of moves. You may return any path that does so. **Example 1:** **Input:** target = leet **Output:** DDR!UURRR!!DDD! **Example 2:** **Input:** target = code **Output:** RR!DDRR!UUL!R! **Constraints:** * `1 <= target.length <= 100` * `target` consists only of English lowercase letters.","completion":"def maxSatisfied(customers, grumpy, minutes): total, max_increase, window_increase = 0, 0, 0 i, j = 0, 0 while i < len(customers): if i - j == minutes: window_increase -= customers[j] * grumpy[j] j += 1 window_increase += customers[i] * grumpy[i] total += customers[i] * (1 - grumpy[i]) max_increase = max(max_increase, window_increase) i += 1 return total + max_increase"},{"prompt":"You are given a **0indexed** string `s` consisting of only lowercase English letters. Return _the number of **substrings** in_ `s` _that begin and end with the **same** character._ A **substring** is a contiguous nonempty sequence of characters within a string. **Example 1:** **Input:** s = abcba **Output:** 7 **Explanation:** The substrings of length 1 that start and end with the same letter are: a , b , c , b , and a . The substring of length 3 that starts and ends with the same letter is: bcb . The substring of length 5 that starts and ends with the same letter is: abcba . **Example 2:** **Input:** s = abacad **Output:** 9 **Explanation:** The substrings of length 1 that start and end with the same letter are: a , b , a , c , a , and d . The substrings of length 3 that start and end with the same letter are: aba and aca . The substring of length 5 that starts and ends with the same letter is: abaca . **Example 3:** **Input:** s = a **Output:** 1 **Explanation:** The substring of length 1 that starts and ends with the same letter is: a . **Constraints:** * `1 <= s.length <= 105` * `s` consists only of lowercase English letters.","completion":"def has_three_divisors(n): count = 0 for i in range(1, int(n**0.5) + 1): if n % i == 0: if n // i == i: count += 1 else: count += 2 if count > 3: break return count == 3"},{"prompt":"The **variance** of a string is defined as the largest difference between the number of occurrences of **any** `2` characters present in the string. Note the two characters may or may not be the same. Given a string `s` consisting of lowercase English letters only, return _the **largest variance** possible among all **substrings** of_ `s`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** **Input:** s = aababbb **Output:** 3 **Explanation:** All possible variances along with their respective substrings are listed below: Variance 0 for substrings a , aa , ab , abab , aababb , ba , b , bb , and bbb . Variance 1 for substrings aab , aba , abb , aabab , ababb , aababbb , and bab . Variance 2 for substrings aaba , ababbb , abbb , and babb . Variance 3 for substring babbb . Since the largest possible variance is 3, we return it. **Example 2:** **Input:** s = abcde **Output:** 0 **Explanation:** No letter occurs more than once in s, so the variance of every substring is 0. **Constraints:** * `1 <= s.length <= 104` * `s` consists of lowercase English letters.","completion":"def maximum_good_people(statements): n = len(statements) count_good = 0 for i in range(n): is_good = True for j in range(n): if statements[j][i] == 1 and statements[i][j] == 0: is_good = False break if is_good: count_good += 1 return count_good"},{"prompt":"An array is **squareful** if the sum of every pair of adjacent elements is a **perfect square**. Given an integer array nums, return _the number of permutations of_ `nums` _that are **squareful**_. Two permutations `perm1` and `perm2` are different if there is some index `i` such that `perm1[i] != perm2[i]`. **Example 1:** **Input:** nums = [1,17,8] **Output:** 2 **Explanation:** [1,8,17] and [17,8,1] are the valid permutations. **Example 2:** **Input:** nums = [2,2,2] **Output:** 1 **Constraints:** * `1 <= nums.length <= 12` * `0 <= nums[i] <= 109`","completion":"from collections import Counter def numSquarefulPerms(nums): def is_square(n): return int(n ** 0.5) ** 2 == n def dfs(idx): if idx == len(nums): return 1 count = 0 for key in counter.keys(): if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)): counter[key] -= 1 nums[idx] = key count += dfs(idx + 1) counter[key] += 1 return count key_set, counter = set(nums), Counter(nums) return dfs(0)"},{"prompt":"You are given an integer array `nums`. In one operation, you can replace **any** element in `nums` with **any** integer. `nums` is considered **continuous** if both of the following conditions are fulfilled: * All elements in `nums` are **unique**. * The difference between the **maximum** element and the **minimum** element in `nums` equals `nums.length 1`. For example, `nums = [4, 2, 5, 3]` is **continuous**, but `nums = [1, 2, 3, 5, 6]` is **not continuous**. Return _the **minimum** number of operations to make_ `nums` **_continuous_**. **Example 1:** **Input:** nums = [4,2,5,3] **Output:** 0 **Explanation:** nums is already continuous. **Example 2:** **Input:** nums = [1,2,3,5,6] **Output:** 1 **Explanation:** One possible solution is to change the last element to 4. The resulting array is [1,2,3,5,4], which is continuous. **Example 3:** **Input:** nums = [1,10,100,1000] **Output:** 3 **Explanation:** One possible solution is to: Change the second element to 2. Change the third element to 3. Change the fourth element to 4. The resulting array is [1,2,3,4], which is continuous. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109`","completion":"def min_operations(nums): n = len(nums) s = sorted(set(nums)) res = float(\'inf\') j = 0 for i in range(len(s)): while j < len(s) and s[j] <= s[i] + n - 1: j += 1 res = min(res, n - (j - i)) return res"},{"prompt":"There is a knight on an `n x n` chessboard. In a valid configuration, the knight starts **at the topleft cell** of the board and visits every cell on the board **exactly once**. You are given an `n x n` integer matrix `grid` consisting of distinct integers from the range `[0, n * n 1]` where `grid[row][col]` indicates that the cell `(row, col)` is the `grid[row][col]th` cell that the knight visited. The moves are **0indexed**. Return `true` _if_ `grid` _represents a valid configuration of the knight\'s movements or_ `false` _otherwise_. **Note** that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell. **Example 1:** **Input:** grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]] **Output:** true **Explanation:** The above diagram represents the grid. It can be shown that it is a valid configuration. **Example 2:** **Input:** grid = [[0,3,6],[5,8,1],[2,7,4]] **Output:** false **Explanation:** The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move. **Constraints:** * `n == grid.length == grid[i].length` * `3 <= n <= 7` * `0 <= grid[row][col] < n * n` * All integers in `grid` are **unique**.","completion":"def isValidMove(i, j, k, n): return (i + 1 < n and j + 2 < n and k == n * (i + 1) + (j + 2)) or (i + 1 < n and j - 2 >= 0 and k == n * (i + 1) + (j - 2)) or (i + 2 < n and j + 1 < n and k == n * (i + 2) + (j + 1)) or (i + 2 < n and j - 1 >= 0 and k == n * (i + 2) + (j - 1)) def validPath(grid): n = len(grid) for i in range(n): for j in range(n): k = grid[i][j] if k != n * n - 1 and not isValidMove(i, j, k + 1, n): return False return True"},{"prompt":"_(This problem is an **interactive problem**.)_ You may recall that an array `arr` is a **mountain array** if and only if: * `arr.length >= 3` * There exists some `i` with `0 < i < arr.length 1` such that: * `arr[0] < arr[1] < ... < arr[i 1] < arr[i]` * `arr[i] > arr[i + 1] > ... > arr[arr.length 1]` Given a mountain array `mountainArr`, return the **minimum** `index` such that `mountainArr.get(index) == target`. If such an `index` does not exist, return `1`. **You cannot access the mountain array directly.** You may only access the array using a `MountainArray` interface: * `MountainArray.get(k)` returns the element of the array at index `k` (0indexed). * `MountainArray.length()` returns the length of the array. Submissions making more than `100` calls to `MountainArray.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification. **Example 1:** **Input:** array = [1,2,3,4,5,3,1], target = 3 **Output:** 2 **Explanation:** 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. **Example 2:** **Input:** array = [0,1,2,4,2,1], target = 3 **Output:** 1 **Explanation:** 3 does not exist in `the array,` so we return 1. **Constraints:** * `3 <= mountain_arr.length() <= 104` * `0 <= target <= 109` * `0 <= mountain_arr.get(index) <= 109`","completion":"def twoCitySchedCost(costs): costs.sort(key=lambda x: x[0] - x[1]) totalCost = 0 n = len(costs) // 2 for i in range(n): totalCost += costs[i][0] + costs[i + n][1] return totalCost"},{"prompt":"There is a special typewriter with lowercase English letters `\'a\'` to `\'z\'` arranged in a **circle** with a **pointer**. A character can **only** be typed if the pointer is pointing to that character. The pointer is **initially** pointing to the character `\'a\'`. Each second, you may perform one of the following operations: * Move the pointer one character **counterclockwise** or **clockwise**. * Type the character the pointer is **currently** on. Given a string `word`, return the **minimum** number of seconds to type out the characters in `word`. **Example 1:** **Input:** word = abc **Output:** 5 **Explanation:** The characters are printed as follows: Type the character \'a\' in 1 second since the pointer is initially on \'a\'. Move the pointer clockwise to \'b\' in 1 second. Type the character \'b\' in 1 second. Move the pointer clockwise to \'c\' in 1 second. Type the character \'c\' in 1 second. **Example 2:** **Input:** word = bza **Output:** 7 **Explanation:** The characters are printed as follows: Move the pointer clockwise to \'b\' in 1 second. Type the character \'b\' in 1 second. Move the pointer counterclockwise to \'z\' in 2 seconds. Type the character \'z\' in 1 second. Move the pointer clockwise to \'a\' in 1 second. Type the character \'a\' in 1 second. **Example 3:** **Input:** word = zjpc **Output:** 34 **Explanation:** The characters are printed as follows: Move the pointer counterclockwise to \'z\' in 1 second. Type the character \'z\' in 1 second. Move the pointer clockwise to \'j\' in 10 seconds. Type the character \'j\' in 1 second. Move the pointer clockwise to \'p\' in 6 seconds. Type the character \'p\' in 1 second. Move the pointer counterclockwise to \'c\' in 13 seconds. Type the character \'c\' in 1 second. **Constraints:** * `1 <= word.length <= 100` * `word` consists of lowercase English letters.","completion":"def minTimeToType(word: str) -> int: time = 0 position = 0 for c in word: next_position = ord(c) - ord(\'a\') diff = abs(next_position - position) time += min(diff, 26 - diff) + 1 position = next_position return time"},{"prompt":"There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered `0`, `1`, and `2`. The square room has walls of length `p` and a laser ray from the southwest corner first meets the east wall at a distance `q` from the `0th` receptor. Given the two integers `p` and `q`, return _the number of the receptor that the ray meets first_. The test cases are guaranteed so that the ray will meet a receptor eventually. **Example 1:** **Input:** p = 2, q = 1 **Output:** 2 **Explanation:** The ray meets receptor 2 the first time it gets reflected back to the left wall. **Example 2:** **Input:** p = 3, q = 1 **Output:** 1 **Constraints:** * `1 <= q <= p <= 1000`","completion":"def mask_information(s: str) -> str: if \'@\' in s: s = s.lower() return s[0] + \\"*****\\" + s[s.index(\'@\') - 1:] else: digits = \\"\\".join(filter(str.isdigit, s)) if len(digits) == 10: return \\"***-***-\\" + digits[-4:] prefix = \\"*\\" * (len(digits) - 10) + \\"-\\" return \\"+\\" + prefix + \\"***-***-\\" + digits[-4:]"},{"prompt":"You are given an integer array `nums`. The **absolute sum** of a subarray `[numsl, numsl+1, ..., numsr1, numsr]` is `abs(numsl + numsl+1 + ... + numsr1 + numsr)`. Return _the **maximum** absolute sum of any **(possibly empty)** subarray of_ `nums`. Note that `abs(x)` is defined as follows: * If `x` is a negative integer, then `abs(x) = x`. * If `x` is a nonnegative integer, then `abs(x) = x`. **Example 1:** **Input:** nums = [1,3,2,3,4] **Output:** 5 **Explanation:** The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5. **Example 2:** **Input:** nums = [2,5,1,4,3,2] **Output:** 8 **Explanation:** The subarray [5,1,4] has absolute sum = abs(5+14) = abs(8) = 8. **Constraints:** * `1 <= nums.length <= 105` * `104 <= nums[i] <= 104`","completion":"def maxAbsoluteSum(nums): max_sum = max_end = min_sum = min_end = 0 for num in nums: max_end = max(max_end + num, num) min_end = min(min_end + num, num) max_sum = max(max_sum, max_end) min_sum = min(min_sum, min_end) return max(max_sum, -min_sum)"},{"prompt":"You are given a **0indexed** integer array `nums`. Initially on minute `0`, the array is unchanged. Every minute, the **leftmost** element in `nums` is removed until no elements remain. Then, every minute, one element is appended to the **end** of `nums`, in the order they were removed in, until the original array is restored. This process repeats indefinitely. * For example, the array `[0,1,2]` would change as follows: `[0,1,2] > [1,2] > [2] > [] > [0] > [0,1] > [0,1,2] > [1,2] > [2] > [] > [0] > [0,1] > [0,1,2] > ...` You are also given a 2D integer array `queries` of size `n` where `queries[j] = [timej, indexj]`. The answer to the `jth` query is: * `nums[indexj]` if `indexj < nums.length` at minute `timej` * `1` if `indexj >= nums.length` at minute `timej` Return _an integer array `ans` of size_ `n` _where_ `ans[j]` _is the answer to the_ `jth` _query_. **Example 1:** **Input:** nums = [0,1,2], queries = [[0,2],[2,0],[3,2],[5,0]] **Output:** [2,2,1,0] **Explanation:** Minute 0: [0,1,2] All elements are in the nums. Minute 1: [1,2] The leftmost element, 0, is removed. Minute 2: [2] The leftmost element, 1, is removed. Minute 3: [] The leftmost element, 2, is removed. Minute 4: [0] 0 is added to the end of nums. Minute 5: [0,1] 1 is added to the end of nums. At minute 0, nums[2] is 2. At minute 2, nums[0] is 2. At minute 3, nums[2] does not exist. At minute 5, nums[0] is 0. **Example 2:** **Input:** nums = [2], queries = [[0,0],[1,0],[2,0],[3,0]] **Output:** [2,1,2,1] Minute 0: [2] All elements are in the nums. Minute 1: [] The leftmost element, 2, is removed. Minute 2: [2] 2 is added to the end of nums. Minute 3: [] The leftmost element, 2, is removed. At minute 0, nums[0] is 2. At minute 1, nums[0] does not exist. At minute 2, nums[0] is 2. At minute 3, nums[0] does not exist. **Constraints:** * `1 <= nums.length <= 100` * `0 <= nums[i] <= 100` * `n == queries.length` * `1 <= n <= 105` * `queries[j].length == 2` * `0 <= timej <= 105` * `0 <= indexj < nums.length`","completion":"def kthLargestNumber(nums, k): nums.sort(key=lambda x: (len(x), x)) return nums[-k]"},{"prompt":"There are `8` prison cells in a row and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: * If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. * Otherwise, it becomes vacant. **Note** that because the prison is a row, the first and the last cells in the row can\'t have two adjacent neighbors. You are given an integer array `cells` where `cells[i] == 1` if the `ith` cell is occupied and `cells[i] == 0` if the `ith` cell is vacant, and you are given an integer `n`. Return the state of the prison after `n` days (i.e., `n` such changes described above). **Example 1:** **Input:** cells = [0,1,0,1,1,0,0,1], n = 7 **Output:** [0,0,1,1,0,0,0,0] **Explanation:** The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0] **Example 2:** **Input:** cells = [1,0,0,1,0,0,1,0], n = 1000000000 **Output:** [0,0,1,1,1,1,1,0] **Constraints:** * `cells.length == 8` * `cells[i]` is either `0` or `1`. * `1 <= n <= 109`","completion":"def minAddToMakeValid(s: str) -> int: result = balance = 0 for c in s: balance += 1 if c == \'(\' else -1 if balance == -1: result += 1 balance += 1 return result + balance"},{"prompt":"Given a sentence `text` (A _sentence_ is a string of spaceseparated words) in the following format: * First letter is in upper case. * Each word in `text` are separated by a single space. Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above. **Example 1:** **Input:** text = Leetcode is cool **Output:** Is cool leetcode **Explanation:** There are 3 words, Leetcode of length 8, is of length 2 and cool of length 4. Output is ordered by length and the new first word starts with capital letter. **Example 2:** **Input:** text = Keep calm and code on **Output:** On and keep calm code **Explanation:** Output is ordered as follows: On 2 letters. and 3 letters. keep 4 letters in case of tie order by position in original text. calm 4 letters. code 4 letters. **Example 3:** **Input:** text = To be or not to be **Output:** To be or to be not **Constraints:** * `text` begins with a capital letter and then contains lowercase letters and single space between words. * `1 <= text.length <= 10^5`","completion":"def min_taps(n, ranges): intervals = [0] * (n + 1) for i in range(n + 1): left = max(0, i - ranges[i]) right = min(n, i + ranges[i]) intervals[left] = max(intervals[left], right - left) position, total_taps, max_reach = 0, 0, 0 while position < n: max_reach = max(max_reach, position + intervals[position]) if max_reach == position: return -1 position = max_reach total_taps += 1 return total_taps"},{"prompt":"A teacher is writing a test with `n` true/false questions, with `\'T\'` denoting true and `\'F\'` denoting false. He wants to confuse the students by **maximizing** the number of **consecutive** questions with the **same** answer (multiple trues or multiple falses in a row). You are given a string `answerKey`, where `answerKey[i]` is the original answer to the `ith` question. In addition, you are given an integer `k`, the maximum number of times you may perform the following operation: * Change the answer key for any question to `\'T\'` or `\'F\'` (i.e., set `answerKey[i]` to `\'T\'` or `\'F\'`). Return _the **maximum** number of consecutive_ `\'T\'`s or `\'F\'`s _in the answer key after performing the operation at most_ `k` _times_. **Example 1:** **Input:** answerKey = TTFF , k = 2 **Output:** 4 **Explanation:** We can replace both the \'F\'s with \'T\'s to make answerKey = TTTT . There are four consecutive \'T\'s. **Example 2:** **Input:** answerKey = TFFT , k = 1 **Output:** 3 **Explanation:** We can replace the first \'T\' with an \'F\' to make answerKey = FFFT . Alternatively, we can replace the second \'T\' with an \'F\' to make answerKey = TFFF . In both cases, there are three consecutive \'F\'s. **Example 3:** **Input:** answerKey = TTFTTFTT , k = 1 **Output:** 5 **Explanation:** We can replace the first \'F\' to make answerKey = TTTTTFTT Alternatively, we can replace the second \'F\' to make answerKey = TTFTTTTT . In both cases, there are five consecutive \'T\'s. **Constraints:** * `n == answerKey.length` * `1 <= n <= 5 * 104` * `answerKey[i]` is either `\'T\'` or `\'F\'` * `1 <= k <= n`","completion":"def max_consecutive_answers(answer_key: str, k: int) -> int: max_len, left, T_cnt, F_cnt = 0, 0, 0, 0 for right, c in enumerate(answer_key): if c == \'T\': T_cnt += 1 else: F_cnt += 1 if min(T_cnt, F_cnt) > k: if answer_key[left] == \'T\': T_cnt -= 1 else: F_cnt -= 1 left += 1 else: max_len = max(max_len, T_cnt + F_cnt) return max_len"},{"prompt":"You are given a **0indexed** 2D integer array `brackets` where `brackets[i] = [upperi, percenti]` means that the `ith` tax bracket has an upper bound of `upperi` and is taxed at a rate of `percenti`. The brackets are **sorted** by upper bound (i.e. `upperi1 < upperi` for `0 < i < brackets.length`). Tax is calculated as follows: * The first `upper0` dollars earned are taxed at a rate of `percent0`. * The next `upper1 upper0` dollars earned are taxed at a rate of `percent1`. * The next `upper2 upper1` dollars earned are taxed at a rate of `percent2`. * And so on. You are given an integer `income` representing the amount of money you earned. Return _the amount of money that you have to pay in taxes._ Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** brackets = [[3,50],[7,10],[12,25]], income = 10 **Output:** 2.65000 **Explanation:** Based on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket. The tax rate for the three tax brackets is 50%, 10%, and 25%, respectively. In total, you pay 3 * 50% + 4 * 10% + 3 * 25% = 2.65 in taxes. **Example 2:** **Input:** brackets = [[1,0],[4,25],[5,50]], income = 2 **Output:** 0.25000 **Explanation:** Based on your income, you have 1 dollar in the 1st tax bracket and 1 dollar in the 2nd tax bracket. The tax rate for the two tax brackets is 0% and 25%, respectively. In total, you pay 1 * 0% + 1 * 25% = 0.25 in taxes. **Example 3:** **Input:** brackets = [[2,50]], income = 0 **Output:** 0.00000 **Explanation:** You have no income to tax, so you have to pay a total of 0 in taxes. **Constraints:** * `1 <= brackets.length <= 100` * `1 <= upperi <= 1000` * `0 <= percenti <= 100` * `0 <= income <= 1000` * `upperi` is sorted in ascending order. * All the values of `upperi` are **unique**. * The upper bound of the last tax bracket is greater than or equal to `income`.","completion":"def tax_amount(brackets, income): tax = 0 prev_upper = 0 for upper, percent in brackets: tax += (min(upper, income) - prev_upper) * (percent / 100) prev_upper = upper if income <= upper: break return tax"},{"prompt":"You are given an integer array `digits`, where each element is a digit. The array may contain duplicates. You need to find **all** the **unique** integers that follow the given requirements: * The integer consists of the **concatenation** of **three** elements from `digits` in **any** arbitrary order. * The integer does not have **leading zeros**. * The integer is **even**. For example, if the given `digits` were `[1, 2, 3]`, integers `132` and `312` follow the requirements. Return _a **sorted** array of the unique integers._ **Example 1:** **Input:** digits = [2,1,3,0] **Output:** [102,120,130,132,210,230,302,310,312,320] **Explanation:** All the possible integers that follow the requirements are in the output array. Notice that there are no **odd** integers or integers with **leading zeros**. **Example 2:** **Input:** digits = [2,2,8,8,2] **Output:** [222,228,282,288,822,828,882] **Explanation:** The same digit can be used as many times as it appears in digits. In this example, the digit 8 is used twice each time in 288, 828, and 882. **Example 3:** **Input:** digits = [3,7,5] **Output:** [] **Explanation:** No **even** integers can be formed using the given digits. **Constraints:** * `3 <= digits.length <= 100` * `0 <= digits[i] <= 9`","completion":"def min_stones_remaining(piles, k): for _ in range(k): max_pile_index = piles.index(max(piles)) piles[max_pile_index] -= piles[max_pile_index] // 2 return sum(piles)"},{"prompt":"You are given a **0indexed** integer array `costs` where `costs[i]` is the cost of hiring the `ith` worker. You are also given two integers `k` and `candidates`. We want to hire exactly `k` workers according to the following rules: * You will run `k` sessions and hire exactly one worker in each session. * In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index. * For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,**1**,2]`. * In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,**2**,7,7,2]`. Please note that the indexing may be changed in the process. * If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. * A worker can only be chosen once. Return _the total cost to hire exactly_ `k` _workers._ **Example 1:** **Input:** costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 **Output:** 11 **Explanation:** We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers. The total hiring cost is 11. **Example 2:** **Input:** costs = [1,2,4,1], k = 3, candidates = 3 **Output:** 4 **Explanation:** We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4. The total hiring cost is 4. **Constraints:** * `1 <= costs.length <= 105` * `1 <= costs[i] <= 105` * `1 <= k, candidates <= costs.length`","completion":"def hireWorkers(costs, k, candidates): n = len(costs) workers = sorted([(cost, i) for i, cost in enumerate(costs)]) cost = 0 for i in range(k): if min(workers[i][1], n - workers[i][1] - 1) < candidates: cost += workers[i][0] return cost"},{"prompt":"You are given an `m x n` `grid` where each cell can have one of three values: * `0` representing an empty cell, * `1` representing a fresh orange, or * `2` representing a rotten orange. Every minute, any fresh orange that is **4directionally adjacent** to a rotten orange becomes rotten. Return _the minimum number of minutes that must elapse until no cell has a fresh orange_. If _this is impossible, return_ `1`. **Example 1:** **Input:** grid = [[2,1,1],[1,1,0],[0,1,1]] **Output:** 4 **Example 2:** **Input:** grid = [[2,1,1],[0,1,1],[1,0,1]] **Output:** 1 **Explanation:** The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4directionally. **Example 3:** **Input:** grid = [[0,2]] **Output:** 0 **Explanation:** Since there are already no fresh oranges at minute 0, the answer is just 0. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 10` * `grid[i][j]` is `0`, `1`, or `2`.","completion":"def prisonAfterNDays(cells, n): n = n % 14 if n % 14 != 0 else 14 # Pattern repeats every 14 days for _ in range(n): temp = [0] * 8 for i in range(1, 7): temp[i] = int(cells[i - 1] == cells[i + 1]) cells = temp return cells"},{"prompt":"Given an array of positive integers `arr` (not necessarily distinct), return _the_ _lexicographically_ _largest permutation that is smaller than_ `arr`, that can be **made with exactly one swap**. If it cannot be done, then return the same array. **Note** that a _swap_ exchanges the positions of two numbers `arr[i]` and `arr[j]` **Example 1:** **Input:** arr = [3,2,1] **Output:** [3,1,2] **Explanation:** Swapping 2 and 1. **Example 2:** **Input:** arr = [1,1,5] **Output:** [1,1,5] **Explanation:** This is already the smallest permutation. **Example 3:** **Input:** arr = [1,9,4,6,7] **Output:** [1,7,4,6,9] **Explanation:** Swapping 9 and 7. **Constraints:** * `1 <= arr.length <= 104` * `1 <= arr[i] <= 104`","completion":"def prevPermOpt1(arr): n = len(arr) for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: j = i + 1 while j < n and arr[j] < arr[i]: j += 1 arr[i], arr[j - 1] = arr[j - 1], arr[i] break return arr"},{"prompt":"Given two integer arrays `pushed` and `popped` each with distinct values, return `true` _if this could have been the result of a sequence of push and pop operations on an initially empty stack, or_ `false` _otherwise._ **Example 1:** **Input:** pushed = [1,2,3,4,5], popped = [4,5,3,2,1] **Output:** true **Explanation:** We might do the following sequence: push(1), push(2), push(3), push(4), pop() > 4, push(5), pop() > 5, pop() > 3, pop() > 2, pop() > 1 **Example 2:** **Input:** pushed = [1,2,3,4,5], popped = [4,3,5,1,2] **Output:** false **Explanation:** 1 cannot be popped before 2. **Constraints:** * `1 <= pushed.length <= 1000` * `0 <= pushed[i] <= 1000` * All the elements of `pushed` are **unique**. * `popped.length == pushed.length` * `popped` is a permutation of `pushed`.","completion":"def minimum_score(nums, k): nums.sort() n = len(nums) res = nums[n - 1] - nums[0] for i in range(n - 1): high = max(nums[i] + k, nums[n - 1] - k) low = min(nums[i + 1] - k, nums[0] + k) res = min(res, high - low) return res"},{"prompt":"You are given a very large integer `n`, represented as a string,​​​​​​ and an integer digit `x`. The digits in `n` and the digit `x` are in the **inclusive** range `[1, 9]`, and `n` may represent a **negative** number. You want to **maximize** `n`**\'s numerical value** by inserting `x` anywhere in the decimal representation of `n`​​​​​​. You **cannot** insert `x` to the left of the negative sign. * For example, if `n = 73` and `x = 6`, it would be best to insert it between `7` and `3`, making `n = 763`. * If `n = 55` and `x = 2`, it would be best to insert it before the first `5`, making `n = 255`. Return _a string representing the **maximum** value of_ `n`_​​​​​​ after the insertion_. **Example 1:** **Input:** n = 99 , x = 9 **Output:** 999 **Explanation:** The result is the same regardless of where you insert 9. **Example 2:** **Input:** n = 13 , x = 2 **Output:** 123 **Explanation:** You can make n one of {213, 123, 132}, and the largest of those three is 123. **Constraints:** * `1 <= n.length <= 105` * `1 <= x <= 9` * The digits in `n`​​​ are in the range `[1, 9]`. * `n` is a valid representation of an integer. * In the case of a negative `n`,​​​​​​ it will begin with `\'\'`.","completion":"from itertools import combinations def minAbsDifference(nums, goal): n = len(nums) left = nums[:n//2] right = nums[n//2:] sums_left = set() for i in range(len(left) + 1): for comb in combinations(left, i): sums_left.add(sum(comb)) ans = abs(goal) for i in range(len(right) + 1): for comb in combinations(right, i): sum_r = sum(comb) sum_goal = goal - sum_r sum_l = min(sums_left, key=lambda x: abs(x - sum_goal)) ans = min(ans, abs(sum_l + sum_r - goal)) return ans"},{"prompt":"For a string `sequence`, a string `word` is **`k`repeating** if `word` concatenated `k` times is a substring of `sequence`. The `word`\'s **maximum `k`repeating value** is the highest value `k` where `word` is `k`repeating in `sequence`. If `word` is not a substring of `sequence`, `word`\'s maximum `k`repeating value is `0`. Given strings `sequence` and `word`, return _the **maximum `k`repeating value** of `word` in `sequence`_. **Example 1:** **Input:** sequence = ababc , word = ab **Output:** 2 **Explanation: ** abab is a substring in ababc . **Example 2:** **Input:** sequence = ababc , word = ba **Output:** 1 **Explanation: ** ba is a substring in ababc . baba is not a substring in ababc . **Example 3:** **Input:** sequence = ababc , word = ac **Output:** 0 **Explanation: ** ac is not a substring in ababc . **Constraints:** * `1 <= sequence.length <= 100` * `1 <= word.length <= 100` * `sequence` and `word` contains only lowercase English letters.","completion":"def longestAwesomeSubstring(s): n = len(s) maxLen = 0 for i in range(n): for j in range(i + 1, n + 1): substr = s[i:j] if isAwesome(substr): maxLen = max(maxLen, j - i) return maxLen def isAwesome(s): odd_count = 0 freq = [0] * 26 for c in s: freq[ord(c) - ord(\'a\')] += 1 for i in range(26): if freq[i] % 2 == 1: odd_count += 1 return odd_count <= 1"},{"prompt":"Given an array `nums` of integers, a _move_ consists of choosing any element and **decreasing it by 1**. An array `A` is a _zigzag array_ if either: * Every evenindexed element is greater than adjacent elements, ie. `A[0] > A[1] < A[2] > A[3] < A[4] > ...` * OR, every oddindexed element is greater than adjacent elements, ie. `A[0] < A[1] > A[2] < A[3] > A[4] < ...` Return the minimum number of moves to transform the given array `nums` into a zigzag array. **Example 1:** **Input:** nums = [1,2,3] **Output:** 2 **Explanation:** We can decrease 2 to 0 or 3 to 1. **Example 2:** **Input:** nums = [9,6,1,6,2] **Output:** 4 **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i] <= 1000`","completion":"def movesToMakeZigzag(nums): even_moves, odd_moves = 0, 0 for i in range(len(nums)): left = nums[i - 1] if i > 0 else 1001 right = nums[i + 1] if i < len(nums) - 1 else 1001 min_value = min(left, right) if nums[i] >= min_value: if i % 2 == 0: even_moves += nums[i] - min_value + 1 else: odd_moves += nums[i] - min_value + 1 return min(even_moves, odd_moves)"},{"prompt":"Given a binary array `data`, return the minimum number of swaps required to group all `1`\'s present in the array together in **any place** in the array. **Example 1:** **Input:** data = [1,0,1,0,1] **Output:** 1 **Explanation:** There are 3 ways to group all 1\'s together: [1,1,1,0,0] using 1 swap. [0,1,1,1,0] using 2 swaps. [0,0,1,1,1] using 1 swap. The minimum is 1. **Example 2:** **Input:** data = [0,0,0,1,0] **Output:** 0 **Explanation:** Since there is only one 1 in the array, no swaps are needed. **Example 3:** **Input:** data = [1,0,1,0,1,0,0,1,1,0,1] **Output:** 3 **Explanation:** One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1]. **Constraints:** * `1 <= data.length <= 105` * `data[i]` is either `0` or `1`.","completion":"def minSwaps(data): ones = sum(data) cur_ones, max_ones = 0, 0 for i, d in enumerate(data): cur_ones += d if i >= ones: cur_ones -= data[i - ones] max_ones = max(max_ones, cur_ones) return ones - max_ones"},{"prompt":"You are given two strings `firstString` and `secondString` that are **0indexed** and consist only of lowercase English letters. Count the number of index quadruples `(i,j,a,b)` that satisfy the following conditions: * `0 <= i <= j < firstString.length` * `0 <= a <= b < secondString.length` * The substring of `firstString` that starts at the `ith` character and ends at the `jth` character (inclusive) is **equal** to the substring of `secondString` that starts at the `ath` character and ends at the `bth` character (inclusive). * `j a` is the **minimum** possible value among all quadruples that satisfy the previous conditions. Return _the **number** of such quadruples_. **Example 1:** **Input:** firstString = abcd , secondString = bccda **Output:** 1 **Explanation:** The quadruple (0,0,4,4) is the only one that satisfies all the conditions and minimizes j a. **Example 2:** **Input:** firstString = ab , secondString = cd **Output:** 0 **Explanation:** There are no quadruples satisfying all the conditions. **Constraints:** * `1 <= firstString.length, secondString.length <= 2 * 105` * Both strings consist only of lowercase English letters.","completion":"import heapq def minimum_deviation(nums): pq = [] min_val = float(\\"inf\\") for num in nums: if num % 2 == 0: heapq.heappush(pq, -num) else: heapq.heappush(pq, -(num * 2)) min_val = min(min_val, num) result = float(\\"inf\\") while True: top = -heapq.heappop(pq) result = min(result, top - min_val) if top % 2 == 1: break heapq.heappush(pq, -(top // 2)) min_val = min(min_val, top // 2) return result"},{"prompt":"The redgreenblue color `#AABBCC ` can be written as `#ABC ` in shorthand. * For example, `#15c ` is shorthand for the color `#1155cc `. The similarity between the two colors `#ABCDEF ` and `#UVWXYZ ` is `(AB UV)2 (CD WX)2 (EF YZ)2`. Given a string `color` that follows the format `#ABCDEF `, return a string represents the color that is most similar to the given color and has a shorthand (i.e., it can be represented as some `#XYZ `). **Any answer** which has the same highest similarity as the best answer will be accepted. **Example 1:** **Input:** color = #09f166 **Output:** #11ee66 **Explanation:** The similarity is (0x09 0x11)2 (0xf1 0xee)2 (0x66 0x66)2 = 64 9 0 = 73. This is the highest among any shorthand color. **Example 2:** **Input:** color = #4e3fe1 **Output:** #5544dd **Constraints:** * `color.length == 7` * `color[0] == \'#\'` * `color[i]` is either digit or character in the range `[\'a\', \'f\']` for `i > 0`.","completion":"def letterCasePermutation(s): def backtrack(index): if index == len(s): result.append(\\"\\".join(s)) return backtrack(index + 1) if s[index].isalpha(): s[index] = s[index].swapcase() backtrack(index + 1) s[index] = s[index].swapcase() result = [] s = list(s) backtrack(0) return result"},{"prompt":"You are given a **strictly increasing** integer array `rungs` that represents the **height** of rungs on a ladder. You are currently on the **floor** at height `0`, and you want to reach the last rung. You are also given an integer `dist`. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is **at most** `dist`. You are able to insert rungs at any positive **integer** height if a rung is not already there. Return _the **minimum** number of rungs that must be added to the ladder in order for you to climb to the last rung._ **Example 1:** **Input:** rungs = [1,3,5,10], dist = 2 **Output:** 2 **Explanation:** You currently cannot reach the last rung. Add rungs at heights 7 and 8 to climb this ladder. The ladder will now have rungs at [1,3,5,7,8,10]. **Example 2:** **Input:** rungs = [3,6,8,10], dist = 3 **Output:** 0 **Explanation:** This ladder can be climbed without adding additional rungs. **Example 3:** **Input:** rungs = [3,4,6,7], dist = 2 **Output:** 1 **Explanation:** You currently cannot reach the first rung from the ground. Add a rung at height 1 to climb this ladder. The ladder will now have rungs at [1,3,4,6,7]. **Constraints:** * `1 <= rungs.length <= 105` * `1 <= rungs[i] <= 109` * `1 <= dist <= 109` * `rungs` is **strictly increasing**.","completion":"def numberOfNiceDivisors(primeFactors): MOD = 1000000007 result = 1 p = 2 while p <= primeFactors: if primeFactors % p == 0: count = 0 while primeFactors % p == 0: primeFactors //= p count += 1 result = (result * (count * 2 + 1)) % MOD p += 1 return result"},{"prompt":"Given `n` orders, each order consist in pickup and delivery services. Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). Since the answer may be too large, return it modulo 10^9 + 7. **Example 1:** **Input:** n = 1 **Output:** 1 **Explanation:** Unique order (P1, D1), Delivery 1 always is after of Pickup 1. **Example 2:** **Input:** n = 2 **Output:** 6 **Explanation:** All possible orders: (P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1). This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2. **Example 3:** **Input:** n = 3 **Output:** 90 **Constraints:** * `1 <= n <= 500` Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n 1) such that : p[0] = start, p[i] and p[i+1] differ by only one bit for all 0 <= i < 2^n 1.","completion":"def circular_permutation(n, start): result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)] return result"},{"prompt":"Given two strings `first` and `second`, consider occurrences in some text of the form `first second third `, where `second` comes immediately after `first`, and `third` comes immediately after `second`. Return _an array of all the words_ `third` _for each occurrence of_ `first second third `. **Example 1:** **Input:** text = alice is a good girl she is a good student, first = a, second = good **Output:** [girl,student] **Example 2:** **Input:** text = we will we will rock you, first = we, second = will **Output:** [we,rock] **Constraints:** * `1 <= text.length <= 1000` * `text` consists of lowercase English letters and spaces. * All the words in `text` a separated by **a single space**. * `1 <= first.length, second.length <= 10` * `first` and `second` consist of lowercase English letters.","completion":"def remove_outer_parentheses(s: str) -> str: result = [] opened = 0 for c in s: if c == \'(\': if opened > 0: result.append(c) opened += 1 elif c == \')\': if opened > 1: result.append(c) opened -= 1 return \'\'.join(result)"},{"prompt":"You are given a **0indexed** integer array `piles`, where `piles[i]` represents the number of stones in the `ith` pile, and an integer `k`. You should apply the following operation **exactly** `k` times: * Choose any `piles[i]` and **remove** `floor(piles[i] / 2)` stones from it. **Notice** that you can apply the operation on the **same** pile more than once. Return _the **minimum** possible total number of stones remaining after applying the_ `k` _operations_. `floor(x)` is the **greatest** integer that is **smaller** than or **equal** to `x` (i.e., rounds `x` down). **Example 1:** **Input:** piles = [5,4,9], k = 2 **Output:** 12 **Explanation:** Steps of a possible scenario are: Apply the operation on pile 2. The resulting piles are [5,4,5]. Apply the operation on pile 0. The resulting piles are [3,4,5]. The total number of stones in [3,4,5] is 12. **Example 2:** **Input:** piles = [4,3,6,7], k = 3 **Output:** 12 **Explanation:** Steps of a possible scenario are: Apply the operation on pile 2. The resulting piles are [4,3,3,7]. Apply the operation on pile 3. The resulting piles are [4,3,3,4]. Apply the operation on pile 0. The resulting piles are [2,3,3,4]. The total number of stones in [2,3,3,4] is 12. **Constraints:** * `1 <= piles.length <= 105` * `1 <= piles[i] <= 104` * `1 <= k <= 105`","completion":"from queue import PriorityQueue def getOrder(tasks): task_indices = sorted(range(len(tasks)), key=lambda i: tasks[i][0]) min_heap = PriorityQueue() time = 0 task_idx = 0 result = [] while task_indices: while task_idx < len(task_indices) and tasks[task_indices[task_idx]][0] <= time: idx = task_indices[task_idx] min_heap.put((tasks[idx][1], idx)) task_idx += 1 if not min_heap.empty(): processing_time, index = min_heap.get() time += processing_time result.append(index) task_indices.remove(index) elif task_idx < len(task_indices): time = max(time, tasks[task_indices[task_idx]][0]) return result"},{"prompt":"You are given a list of blocks, where `blocks[i] = t` means that the `i`th block needs `t` units of time to be built. A block can only be built by exactly one worker. A worker can either split into two workers (number of workers increases by one) or build a block then go home. Both decisions cost some time. The time cost of spliting one worker into two workers is given as an integer `split`. Note that if two workers split at the same time, they split in parallel so the cost would be `split`. Output the minimum time needed to build all blocks. Initially, there is only **one** worker. **Example 1:** **Input:** blocks = [1], split = 1 **Output:** 1 **Explanation:** We use 1 worker to build 1 block in 1 time unit. **Example 2:** **Input:** blocks = [1,2], split = 5 **Output:** 7 **Explanation:** We split the worker into 2 workers in 5 time units then assign each of them to a block so the cost is 5 + max(1, 2) = 7. **Example 3:** **Input:** blocks = [1,2,3], split = 1 **Output:** 4 **Explanation:** Split 1 worker into 2, then assign the first worker to the last block and split the second worker into 2. Then, use the two unassigned workers to build the first two blocks. The cost is 1 + max(3, 1 + max(1, 2)) = 4. **Constraints:** * `1 <= blocks.length <= 1000` * `1 <= blocks[i] <= 10^5` * `1 <= split <= 100`","completion":"import heapq def min_build_time(blocks, split): heapq.heapify(blocks) while len(blocks) > 1: a = heapq.heappop(blocks) b = heapq.heappop(blocks) heapq.heappush(blocks, b + split) return blocks[0]"},{"prompt":"We have a wooden plank of the length `n` **units**. Some ants are walking on the plank, each ant moves with a speed of **1 unit per second**. Some of the ants move to the **left**, the other move to the **right**. When two ants moving in two **different** directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time. When an ant reaches **one end** of the plank at a time `t`, it falls out of the plank immediately. Given an integer `n` and two integer arrays `left` and `right`, the positions of the ants moving to the left and the right, return _the moment when the last ant(s) fall out of the plank_. **Example 1:** **Input:** n = 4, left = [4,3], right = [0,1] **Output:** 4 **Explanation:** In the image above: The ant at index 0 is named A and going to the right. The ant at index 1 is named B and going to the right. The ant at index 3 is named C and going to the left. The ant at index 4 is named D and going to the left. The last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank). **Example 2:** **Input:** n = 7, left = [], right = [0,1,2,3,4,5,6,7] **Output:** 7 **Explanation:** All ants are going to the right, the ant at index 0 needs 7 seconds to fall. **Example 3:** **Input:** n = 7, left = [0,1,2,3,4,5,6,7], right = [] **Output:** 7 **Explanation:** All ants are going to the left, the ant at index 7 needs 7 seconds to fall. **Constraints:** * `1 <= n <= 104` * `0 <= left.length <= n + 1` * `0 <= left[i] <= n` * `0 <= right.length <= n + 1` * `0 <= right[i] <= n` * `1 <= left.length + right.length <= n + 1` * All values of `left` and `right` are unique, and each value can appear **only in one** of the two arrays.","completion":"def max_satisfaction(satisfaction): satisfaction.sort(reverse=True) ans = total = sum = 0 for i in satisfaction: total += i if total > 0: sum += total ans = max(ans, sum) return ans"},{"prompt":"You are given an integer `n` indicating the number of people in a network. Each person is labeled from `0` to `n 1`. You are also given a **0indexed** 2D integer array `restrictions`, where `restrictions[i] = [xi, yi]` means that person `xi` and person `yi` **cannot** become **friends**, either **directly** or **indirectly** through other people. Initially, no one is friends with each other. You are given a list of friend requests as a **0indexed** 2D integer array `requests`, where `requests[j] = [uj, vj]` is a friend request between person `uj` and person `vj`. A friend request is **successful** if `uj` and `vj` can be **friends**. Each friend request is processed in the given order (i.e., `requests[j]` occurs before `requests[j + 1]`), and upon a successful request, `uj` and `vj` **become direct friends** for all future friend requests. Return _a **boolean array**_ `result`, _where each_ `result[j]` _is_ `true` _if the_ `jth` _friend request is **successful** or_ `false` _if it is not_. **Note:** If `uj` and `vj` are already direct friends, the request is still **successful**. **Example 1:** **Input:** n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]] **Output:** [true,false] **Explanation:** Request 0: Person 0 and person 2 can be friends, so they become direct friends. Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (120). **Example 2:** **Input:** n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]] **Output:** [true,false] **Explanation:** Request 0: Person 1 and person 2 can be friends, so they become direct friends. Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (021). **Example 3:** **Input:** n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]] **Output:** [true,false,true,false] **Explanation:** Request 0: Person 0 and person 4 can be friends, so they become direct friends. Request 1: Person 1 and person 2 cannot be friends since they are directly restricted. Request 2: Person 3 and person 1 can be friends, so they become direct friends. Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0431). **Constraints:** * `2 <= n <= 1000` * `0 <= restrictions.length <= 1000` * `restrictions[i].length == 2` * `0 <= xi, yi <= n 1` * `xi != yi` * `1 <= requests.length <= 1000` * `requests[j].length == 2` * `0 <= uj, vj <= n 1` * `uj != vj`","completion":"def alphabet_position_sum(s, k): sum = 0 for c in s: sum += ord(c) - ord(\'a\') + 1 for _ in range(k): new_sum = 0 while sum > 0: new_sum += sum % 10 sum //= 10 sum = new_sum return sum"},{"prompt":"You are given a string `s` representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: * `\'A\'`: Absent. * `\'L\'`: Late. * `\'P\'`: Present. The student is eligible for an attendance award if they meet **both** of the following criteria: * The student was absent (`\'A\'`) for **strictly** fewer than 2 days **total**. * The student was **never** late (`\'L\'`) for 3 or more **consecutive** days. Return `true` _if the student is eligible for an attendance award, or_ `false` _otherwise_. **Example 1:** **Input:** s = PPALLP **Output:** true **Explanation:** The student has fewer than 2 absences and was never late 3 or more consecutive days. **Example 2:** **Input:** s = PPALLL **Output:** false **Explanation:** The student was late 3 consecutive days in the last 3 days, so is not eligible for the award. **Constraints:** * `1 <= s.length <= 1000` * `s[i]` is either `\'A\'`, `\'L\'`, or `\'P\'`.","completion":"def checkRecord(s: str) -> bool: late, absent = 0, 0 for c in s: if c == \'A\': absent += 1 late = 0 elif c == \'L\': late += 1 else: late = 0 if absent >= 2 or late >= 3: return False return True"},{"prompt":"You are given the strings `key` and `message`, which represent a cipher key and a secret message, respectively. The steps to decode `message` are as follows: 1. Use the **first** appearance of all 26 lowercase English letters in `key` as the **order** of the substitution table. 2. Align the substitution table with the regular English alphabet. 3. Each letter in `message` is then **substituted** using the table. 4. Spaces `\' \'` are transformed to themselves. * For example, given `key = **hap**p**y** **bo**y ` (actual key would have **at least one** instance of each letter in the alphabet), we have the partial substitution table of (`\'h\' > \'a\'`, `\'a\' > \'b\'`, `\'p\' > \'c\'`, `\'y\' > \'d\'`, `\'b\' > \'e\'`, `\'o\' > \'f\'`). Return _the decoded message_. **Example 1:** **Input:** key = the quick brown fox jumps over the lazy dog , message = vkbs bs t suepuv **Output:** this is a secret **Explanation:** The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in **the** **quick** **brown** **f**o**x** **j**u**mps** o**v**er the **lazy** **d**o**g** . **Example 2:** **Input:** key = eljuxhpwnyrdgtqkviszcfmabo , message = zwx hnfx lqantp mnoeius ycgk vcnjrdb **Output:** the five boxing wizards jump quickly **Explanation:** The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in **eljuxhpwnyrdgtqkviszcfmabo** . **Constraints:** * `26 <= key.length <= 2000` * `key` consists of lowercase English letters and `\' \'`. * `key` contains every letter in the English alphabet (`\'a\'` to `\'z\'`) **at least once**. * `1 <= message.length <= 2000` * `message` consists of lowercase English letters and `\' \'`.","completion":"def valid_selections(s: str) -> int: res = 0 for i in range(1, len(s) - 1): if s[i - 1] != s[i] and s[i] != s[i + 1] and s[i - 1] != s[i + 1]: res += 1 return res"},{"prompt":"You are given a **0indexed** binary matrix `grid`. In one operation, you can flip any `1` in `grid` to be `0`. A binary matrix is **wellisolated** if there is no `1` in the matrix that is **4directionally connected** (i.e., horizontal and vertical) to another `1`. Return _the minimum number of operations to make_ `grid` _**wellisolated**_. **Example 1:** **Input:** grid = [[1,1,0],[0,1,1],[1,1,1]] **Output:** 3 **Explanation:** Use 3 operations to change grid[0][1], grid[1][2], and grid[2][1] to 0. After, no more 1\'s are 4directionally connected and grid is wellisolated. **Example 2:** **Input:** grid = [[0,0,0],[0,0,0],[0,0,0]] **Output:** 0 **Explanation:** There are no 1\'s in grid and it is wellisolated. No operations were done so return 0. **Example 3:** **Input:** grid = [[0,1],[1,0]] **Output:** 0 **Explanation:** None of the 1\'s are 4directionally connected and grid is wellisolated. No operations were done so return 0. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 300` * `grid[i][j]` is either `0` or `1`.","completion":"def numberOfWeakCharacters(properties): properties.sort(key=lambda x: (x[0], -x[1])) max_defense = 0 weak_count = 0 for attack, defense in reversed(properties): if defense < max_defense: weak_count += 1 else: max_defense = defense return weak_count"},{"prompt":"Given an array of points on the **XY** plane `points` where `points[i] = [xi, yi]`, return _the area of the largest triangle that can be formed by any three different points_. Answers within `105` of the actual answer will be accepted. **Example 1:** **Input:** points = [[0,0],[0,1],[1,0],[0,2],[2,0]] **Output:** 2.00000 **Explanation:** The five points are shown in the above figure. The red triangle is the largest. **Example 2:** **Input:** points = [[1,0],[0,0],[0,1]] **Output:** 0.50000 **Constraints:** * `3 <= points.length <= 50` * `50 <= xi, yi <= 50` * All the given points are **unique**.","completion":"def is_shifted(s, goal): if len(s) != len(goal): return False s = s + s return goal in s"},{"prompt":"You are given an integer `n`. There are `n` rooms numbered from `0` to `n 1`. You are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **halfclosed** time interval `[starti, endi)`. All the values of `starti` are **unique**. Meetings are allocated to rooms in the following manner: 1. Each meeting will take place in the unused room with the **lowest** number. 2. If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting. 3. When a room becomes unused, meetings that have an earlier original **start** time should be given the room. Return _the **number** of the room that held the most meetings._ If there are multiple rooms, return _the room with the **lowest** number._ A **halfclosed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`. **Example 1:** **Input:** n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]] **Output:** 0 **Explanation:** At time 0, both rooms are not being used. The first meeting starts in room 0. At time 1, only room 1 is not being used. The second meeting starts in room 1. At time 2, both rooms are being used. The third meeting is delayed. At time 3, both rooms are being used. The fourth meeting is delayed. At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10). At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11). Both rooms 0 and 1 held 2 meetings, so we return 0. **Example 2:** **Input:** n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]] **Output:** 1 **Explanation:** At time 1, all three rooms are not being used. The first meeting starts in room 0. At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1. At time 3, only room 2 is not being used. The third meeting starts in room 2. At time 4, all three rooms are being used. The fourth meeting is delayed. At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10). At time 6, all three rooms are being used. The fifth meeting is delayed. At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12). Room 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. **Constraints:** * `1 <= n <= 100` * `1 <= meetings.length <= 105` * `meetings[i].length == 2` * `0 <= starti < endi <= 5 * 105` * All the values of `starti` are **unique**.","completion":"import heapq def most_visited_room(n, meetings): meetings.sort() pq = [] rooms = [0] * n for start, end in meetings: while pq and pq[0][0] <= start: _, room = heapq.heappop(pq) rooms[room] += 1 heapq.heappush(pq, (end, len(pq) % n)) return rooms.index(max(rooms))"},{"prompt":"You are given a **0indexed** `m x n` binary matrix `grid`. A **0indexed** `m x n` difference matrix `diff` is created with the following procedure: * Let the number of ones in the `ith` row be `onesRowi`. * Let the number of ones in the `jth` column be `onesColj`. * Let the number of zeros in the `ith` row be `zerosRowi`. * Let the number of zeros in the `jth` column be `zerosColj`. * `diff[i][j] = onesRowi + onesColj zerosRowi zerosColj` Return _the difference matrix_ `diff`. **Example 1:** **Input:** grid = [[0,1,1],[1,0,1],[0,0,1]] **Output:** [[0,0,4],[0,0,4],[2,2,2]] **Explanation:** diff[0][0] = `onesRow0 + onesCol0 zerosRow0 zerosCol0` = 2 + 1 1 2 = 0 diff[0][1] = `onesRow0 + onesCol1 zerosRow0 zerosCol1` = 2 + 1 1 2 = 0 diff[0][2] = `onesRow0 + onesCol2 zerosRow0 zerosCol2` = 2 + 3 1 0 = 4 diff[1][0] = `onesRow1 + onesCol0 zerosRow1 zerosCol0` = 2 + 1 1 2 = 0 diff[1][1] = `onesRow1 + onesCol1 zerosRow1 zerosCol1` = 2 + 1 1 2 = 0 diff[1][2] = `onesRow1 + onesCol2 zerosRow1 zerosCol2` = 2 + 3 1 0 = 4 diff[2][0] = `onesRow2 + onesCol0 zerosRow2 zerosCol0` = 1 + 1 2 2 = 2 diff[2][1] = `onesRow2 + onesCol1 zerosRow2 zerosCol1` = 1 + 1 2 2 = 2 diff[2][2] = `onesRow2 + onesCol2 zerosRow2 zerosCol2` = 1 + 3 2 0 = 2 **Example 2:** **Input:** grid = [[1,1,1],[1,1,1]] **Output:** [[5,5,5],[5,5,5]] **Explanation:** diff[0][0] = onesRow0 + onesCol0 zerosRow0 zerosCol0 = 3 + 2 0 0 = 5 diff[0][1] = onesRow0 + onesCol1 zerosRow0 zerosCol1 = 3 + 2 0 0 = 5 diff[0][2] = onesRow0 + onesCol2 zerosRow0 zerosCol2 = 3 + 2 0 0 = 5 diff[1][0] = onesRow1 + onesCol0 zerosRow1 zerosCol0 = 3 + 2 0 0 = 5 diff[1][1] = onesRow1 + onesCol1 zerosRow1 zerosCol1 = 3 + 2 0 0 = 5 diff[1][2] = onesRow1 + onesCol2 zerosRow1 zerosCol2 = 3 + 2 0 0 = 5 **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 105` * `1 <= m * n <= 105` * `grid[i][j]` is either `0` or `1`.","completion":"def create_difference_matrix(grid): m, n = len(grid), len(grid[0]) ones_row, ones_col = [0] * m, [0] * n diff = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): ones_row[i] += grid[i][j] ones_col[j] += grid[i][j] for i in range(m): for j in range(n): diff[i][j] = ones_row[i] + ones_col[j] - (n - ones_row[i]) - (m - ones_col[j]) return diff"},{"prompt":"Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string. If there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original. **Example 1:** **Input:** s = abcdefg, k = 2 **Output:** bacdfeg **Example 2:** **Input:** s = abcd, k = 2 **Output:** bacd **Constraints:** * `1 <= s.length <= 104` * `s` consists of only lowercase English letters. * `1 <= k <= 104`","completion":"def reverseStr(s, k): chars = list(s) for i in range(0, len(chars), 2 * k): chars[i:i + k] = reversed(chars[i:i + k]) return \\"\\".join(chars)"},{"prompt":"A binary string is monotone increasing if it consists of some number of `0`\'s (possibly none), followed by some number of `1`\'s (also possibly none). You are given a binary string `s`. You can flip `s[i]` changing it from `0` to `1` or from `1` to `0`. Return _the minimum number of flips to make_ `s` _monotone increasing_. **Example 1:** **Input:** s = 00110 **Output:** 1 **Explanation:** We flip the last digit to get 00111. **Example 2:** **Input:** s = 010110 **Output:** 2 **Explanation:** We flip to get 011111, or alternatively 000111. **Example 3:** **Input:** s = 00011000 **Output:** 2 **Explanation:** We flip to get 00000000. **Constraints:** * `1 <= s.length <= 105` * `s[i]` is either `\'0\'` or `\'1\'`.","completion":"def find_and_replace_patterns(words, pattern): result = [] for word in words: if len(word) != len(pattern): continue w2p = {} p2w = {} matches = True for cWord, cPattern in zip(word, pattern): if cWord not in w2p: w2p[cWord] = cPattern if cPattern not in p2w: p2w[cPattern] = cWord if w2p[cWord] != cPattern or p2w[cPattern] != cWord: matches = False break if matches: result.append(word) return result"},{"prompt":"You are given a **0indexed** array `nums` of **distinct** integers. You want to rearrange the elements in the array such that every element in the rearranged array is **not** equal to the **average** of its neighbors. More formally, the rearranged array should have the property such that for every `i` in the range `1 <= i < nums.length 1`, `(nums[i1] + nums[i+1]) / 2` is **not** equal to `nums[i]`. Return _**any** rearrangement of_ `nums` _that meets the requirements_. **Example 1:** **Input:** nums = [1,2,3,4,5] **Output:** [1,2,4,5,3] **Explanation:** When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5. When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5. When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5. **Example 2:** **Input:** nums = [6,2,0,9,7] **Output:** [9,7,6,2,0] **Explanation:** When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5. When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5. When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3. **Constraints:** * `3 <= nums.length <= 105` * `0 <= nums[i] <= 105`","completion":"def max_building(n, restrictions): restrictions += [[1, 0], [n, n - 1]] restrictions.sort() for i in range(1, len(restrictions)): restrictions[i][1] = min(restrictions[i][1], restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]) for i in range(len(restrictions) - 2, -1, -1): restrictions[i][1] = min(restrictions[i][1], restrictions[i + 1][1] + restrictions[i + 1][0] - restrictions[i][0]) maxHeight = 0 for i in range(1, len(restrictions)): height = (restrictions[i][1] + restrictions[i - 1][1] + restrictions[i][0] - restrictions[i - 1][0]) // 2 maxHeight = max(maxHeight, height) return maxHeight"},{"prompt":"There is a group of `n` members, and a list of various crimes they could commit. The `ith` crime generates a `profit[i]` and requires `group[i]` members to participate in it. If a member participates in one crime, that member can\'t participate in another crime. Let\'s call a **profitable scheme** any subset of these crimes that generates at least `minProfit` profit, and the total number of members participating in that subset of crimes is at most `n`. Return the number of schemes that can be chosen. Since the answer may be very large, **return it modulo** `109 + 7`. **Example 1:** **Input:** n = 5, minProfit = 3, group = [2,2], profit = [2,3] **Output:** 2 **Explanation:** To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. **Example 2:** **Input:** n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] **Output:** 7 **Explanation:** To make a profit of at least 5, the group could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). **Constraints:** * `1 <= n <= 100` * `0 <= minProfit <= 100` * `1 <= group.length <= 100` * `1 <= group[i] <= 100` * `profit.length == group.length` * `0 <= profit[i] <= 100`","completion":"def max_dist_to_closest(seats): max_dist = 0 last_person = -1 for i, seat in enumerate(seats): if seat == 1: max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2) last_person = i return max(max_dist, len(seats) - 1 - last_person)"},{"prompt":"Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be **pseudopalindromic** if at least one permutation of the node values in the path is a palindrome. _Return the number of **pseudopalindromic** paths going from the root node to leaf nodes._ **Example 1:** **Input:** root = [2,3,1,3,1,null,1] **Output:** 2 **Explanation:** The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudopalindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). **Example 2:** **Input:** root = [2,1,1,1,3,null,null,null,null,null,1] **Output:** 1 **Explanation:** The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudopalindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). **Example 3:** **Input:** root = [9] **Output:** 1 **Constraints:** * The number of nodes in the tree is in the range `[1, 105]`. * `1 <= Node.val <= 9`","completion":"def minDifficulty(jobDifficulty, d): n = len(jobDifficulty) if n < d: return -1 dp = [[float(\\"inf\\")] * n for _ in range(d)] dp[0][0] = jobDifficulty[0] for i in range(1, n): dp[0][i] = max(dp[0][i-1], jobDifficulty[i]) for i in range(1, d): for j in range(i, n): maxD = jobDifficulty[j] for k in range(j, i - 1, -1): maxD = max(maxD, jobDifficulty[k]) dp[i][j] = min(dp[i][j], dp[i-1][k-1] + maxD) return dp[d-1][n-1]"},{"prompt":"You are given a **0indexed** `m x n` integer matrix `grid` and an integer `k`. You are currently at position `(0, 0)` and you want to reach position `(m 1, n 1)` moving only **down** or **right**. Return _the number of paths where the sum of the elements on the path is divisible by_ `k`. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3 **Output:** 2 **Explanation:** There are two paths where the sum of the elements on the path is divisible by k. The first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3. The second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3. **Example 2:** **Input:** grid = [[0,0]], k = 5 **Output:** 1 **Explanation:** The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5. **Example 3:** **Input:** grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1 **Output:** 10 **Explanation:** Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 5 * 104` * `1 <= m * n <= 5 * 104` * `0 <= grid[i][j] <= 100` * `1 <= k <= 50`","completion":"def ways(grid, m, n, i, j, k, sum, dp): if i == m - 1 and j == n - 1: return 1 if (sum + grid[i][j]) % k == 0 else 0 if dp[i][j][sum] == -1: ans = 0 if i + 1 < m: ans = (ans + ways(grid, m, n, i + 1, j, k, (sum + grid[i][j]) % k, dp)) % 1000000007 if j + 1 < n: ans = (ans + ways(grid, m, n, i, j + 1, k, (sum + grid[i][j]) % k, dp)) % 1000000007 dp[i][j][sum] = ans return dp[i][j][sum] def waysToReachDivisibleSum(grid, k): m, n = len(grid), len(grid[0]) dp = [[[-1] * k for _ in range(n)] for _ in range(m)] return ways(grid, m, n, 0, 0, k, 0, dp)"},{"prompt":"Given a list of `accounts` where each element `accounts[i]` is a list of strings, where the first element `accounts[i][0]` is a name, and the rest of the elements are **emails** representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails **in sorted order**. The accounts themselves can be returned in **any order**. **Example 1:** **Input:** accounts = [[ John , johnsmith@mail.com , john_newyork@mail.com ],[ John , johnsmith@mail.com , john00@mail.com ],[ Mary , mary@mail.com ],[ John , johnnybravo@mail.com ]] **Output:** [[ John , john00@mail.com , john_newyork@mail.com , johnsmith@mail.com ],[ Mary , mary@mail.com ],[ John , johnnybravo@mail.com ]] **Explanation:** The first and second John\'s are the same person as they have the common email johnsmith@mail.com . The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [[\'Mary\', \'mary@mail.com\'], [\'John\', \'johnnybravo@mail.com\'], [\'John\', \'john00@mail.com\', \'john_newyork@mail.com\', \'johnsmith@mail.com\']] would still be accepted. **Example 2:** **Input:** accounts = [[ Gabe , Gabe0@m.co , Gabe3@m.co , Gabe1@m.co ],[ Kevin , Kevin3@m.co , Kevin5@m.co , Kevin0@m.co ],[ Ethan , Ethan5@m.co , Ethan4@m.co , Ethan0@m.co ],[ Hanzo , Hanzo3@m.co , Hanzo1@m.co , Hanzo0@m.co ],[ Fern , Fern5@m.co , Fern1@m.co , Fern0@m.co ]] **Output:** [[ Ethan , Ethan0@m.co , Ethan4@m.co , Ethan5@m.co ],[ Gabe , Gabe0@m.co , Gabe1@m.co , Gabe3@m.co ],[ Hanzo , Hanzo0@m.co , Hanzo1@m.co , Hanzo3@m.co ],[ Kevin , Kevin0@m.co , Kevin3@m.co , Kevin5@m.co ],[ Fern , Fern0@m.co , Fern1@m.co , Fern5@m.co ]] **Constraints:** * `1 <= accounts.length <= 1000` * `2 <= accounts[i].length <= 10` * `1 <= accounts[i][j].length <= 30` * `accounts[i][0]` consists of English letters. * `accounts[i][j] (for j > 0)` is a valid email.","completion":"from collections import defaultdict def accountsMerge(accounts): def dfs(id, visited, merged_emails): if id in visited: return visited.add(id) for email in accounts[id][1:]: merged_emails.add(email) dfs(email_to_id[email], visited, merged_emails) email_to_id = {} for i, account in enumerate(accounts): for email in account[1:]: email_to_id[email] = i result = [] visited = set() for i, account in enumerate(accounts): if i not in visited: merged_emails = set() dfs(i, visited, merged_emails) result.append([account[0]] + sorted(merged_emails)) return result"},{"prompt":"You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`. Return _the size of the largest **island** in_ `grid` _after applying this operation_. An **island** is a 4directionally connected group of `1`s. **Example 1:** **Input:** grid = [[1,0],[0,1]] **Output:** 3 **Explanation:** Change one 0 to 1 and connect two 1s, then we get an island with area = 3. **Example 2:** **Input:** grid = [[1,1],[1,0]] **Output:** 4 **Explanation:** Change the 0 to 1 and make the island bigger, only one island with area = 4. **Example 3:** **Input:** grid = [[1,1],[1,1]] **Output:** 4 **Explanation:** Can\'t change any 0 to 1, only one island with area = 4. **Constraints:** * `n == grid.length` * `n == grid[i].length` * `1 <= n <= 500` * `grid[i][j]` is either `0` or `1`.","completion":"def maxAreaOfIsland(grid): def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1 ans = 0 for i, row in enumerate(grid): for j, cell in enumerate(row): if cell == 0: grid[i][j] = 1 ans = max(ans, dfs(i, j)) grid[i][j] = 0 return ans"},{"prompt":"**Runlength encoding** is a compression algorithm that allows for an integer array `nums` with many segments of **consecutive repeated** numbers to be represented by a (generally smaller) 2D array `encoded`. Each `encoded[i] = [vali, freqi]` describes the `ith` segment of repeated numbers in `nums` where `vali` is the value that is repeated `freqi` times. * For example, `nums = [1,1,1,2,2,2,2,2]` is represented by the **runlength encoded** array `encoded = [[1,3],[2,5]]`. Another way to read this is three `1`\'s followed by five `2`\'s . The **product** of two runlength encoded arrays `encoded1` and `encoded2` can be calculated using the following steps: 1. **Expand** both `encoded1` and `encoded2` into the full arrays `nums1` and `nums2` respectively. 2. Create a new array `prodNums` of length `nums1.length` and set `prodNums[i] = nums1[i] * nums2[i]`. 3. **Compress** `prodNums` into a runlength encoded array and return it. You are given two **runlength encoded** arrays `encoded1` and `encoded2` representing full arrays `nums1` and `nums2` respectively. Both `nums1` and `nums2` have the **same length**. Each `encoded1[i] = [vali, freqi]` describes the `ith` segment of `nums1`, and each `encoded2[j] = [valj, freqj]` describes the `jth` segment of `nums2`. Return _the **product** of_ `encoded1` _and_ `encoded2`. **Note:** Compression should be done such that the runlength encoded array has the **minimum** possible length. **Example 1:** **Input:** encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]] **Output:** [[6,6]] **Explanation:** encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3]. prodNums = [6,6,6,6,6,6], which is compressed into the runlength encoded array [[6,6]]. **Example 2:** **Input:** encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]] **Output:** [[2,3],[6,1],[9,2]] **Explanation:** encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3]. prodNums = [2,2,2,6,9,9], which is compressed into the runlength encoded array [[2,3],[6,1],[9,2]]. **Constraints:** * `1 <= encoded1.length, encoded2.length <= 105` * `encoded1[i].length == 2` * `encoded2[j].length == 2` * `1 <= vali, freqi <= 104` for each `encoded1[i]`. * `1 <= valj, freqj <= 104` for each `encoded2[j]`. * The full arrays that `encoded1` and `encoded2` represent are the same length.","completion":"def findRLEProduct(encoded1, encoded2): result = [] i, j, count1, count2 = 0, 0, 0, 0 while i < len(encoded1) and j < len(encoded2): product = encoded1[i][0] * encoded2[j][0] count = min(encoded1[i][1] - count1, encoded2[j][1] - count2) count1 += count count2 += count if result and result[-1][0] == product: result[-1][1] += count else: result.append([product, count]) if count1 == encoded1[i][1]: i += 1 count1 = 0 if count2 == encoded2[j][1]: j += 1 count2 = 0 return result"},{"prompt":"There are `n` employees, each with a unique id from `0` to `n 1`. You are given a 2D integer array `logs` where `logs[i] = [idi, leaveTimei]` where: * `idi` is the id of the employee that worked on the `ith` task, and * `leaveTimei` is the time at which the employee finished the `ith` task. All the values `leaveTimei` are **unique**. Note that the `ith` task starts the moment right after the `(i 1)th` task ends, and the `0th` task starts at time `0`. Return _the id of the employee that worked the task with the longest time._ If there is a tie between two or more employees, return _the **smallest** id among them_. **Example 1:** **Input:** n = 10, logs = [[0,3],[2,5],[0,9],[1,15]] **Output:** 1 **Explanation:** Task 0 started at 0 and ended at 3 with 3 units of times. Task 1 started at 3 and ended at 5 with 2 units of times. Task 2 started at 5 and ended at 9 with 4 units of times. Task 3 started at 9 and ended at 15 with 6 units of times. The task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1. **Example 2:** **Input:** n = 26, logs = [[1,1],[3,7],[2,12],[7,17]] **Output:** 3 **Explanation:** Task 0 started at 0 and ended at 1 with 1 unit of times. Task 1 started at 1 and ended at 7 with 6 units of times. Task 2 started at 7 and ended at 12 with 5 units of times. Task 3 started at 12 and ended at 17 with 5 units of times. The tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3. **Example 3:** **Input:** n = 2, logs = [[0,10],[1,20]] **Output:** 0 **Explanation:** Task 0 started at 0 and ended at 10 with 10 units of times. Task 1 started at 10 and ended at 20 with 10 units of times. The tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0. **Constraints:** * `2 <= n <= 500` * `1 <= logs.length <= 500` * `logs[i].length == 2` * `0 <= idi <= n 1` * `1 <= leaveTimei <= 500` * `idi != idi+1` * `leaveTimei` are sorted in a strictly increasing order.","completion":"def worker_with_longest_task(n, logs): result = 0 max_time = logs[0][1] - 0 for i in range(1, len(logs)): time = logs[i][1] - logs[i-1][1] if time > max_time: max_time = time result = logs[i][0] return result"},{"prompt":"You wrote down many **positive** integers in a string called `num`. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was **nondecreasing** and that **no** integer had leading zeros. Return _the **number of possible lists of integers** that you could have written down to get the string_ `num`. Since the answer may be large, return it **modulo** `109 + 7`. **Example 1:** **Input:** num = 327 **Output:** 2 **Explanation:** You could have written down the numbers: 3, 27 327 **Example 2:** **Input:** num = 094 **Output:** 0 **Explanation:** No numbers can have leading zeros and all numbers must be positive. **Example 3:** **Input:** num = 0 **Output:** 0 **Explanation:** No numbers can have leading zeros and all numbers must be positive. **Constraints:** * `1 <= num.length <= 3500` * `num` consists of digits `\'0\'` through `\'9\'`.","completion":"def intervalFinding(intervals, queries): intervals.sort(key=lambda x: x[0]) ans = [] for q in queries: min_size = float(\'inf\') for interval in intervals: if interval[0] <= q <= interval[1]: min_size = min(min_size, interval[1] - interval[0] + 1) ans.append(-1 if min_size == float(\'inf\') else min_size) return ans"},{"prompt":"Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the `ParkingSystem` class: * `ParkingSystem(int big, int medium, int small)` Initializes object of the `ParkingSystem` class. The number of slots for each parking space are given as part of the constructor. * `bool addCar(int carType)` Checks whether there is a parking space of `carType` for the car that wants to get into the parking lot. `carType` can be of three kinds: big, medium, or small, which are represented by `1`, `2`, and `3` respectively. **A car can only park in a parking space of its** `carType`. If there is no space available, return `false`, else park the car in that size space and return `true`. **Example 1:** **Input** [ ParkingSystem , addCar , addCar , addCar , addCar ] [[1, 1, 0], [1], [2], [3], [1]] **Output** [null, true, true, false, false] **Explanation** ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0); parkingSystem.addCar(1); // return true because there is 1 available slot for a big car parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car parkingSystem.addCar(3); // return false because there is no available slot for a small car parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied. **Constraints:** * `0 <= big, medium, small <= 1000` * `carType` is `1`, `2`, or `3` * At most `1000` calls will be made to `addCar`","completion":"def runningSum(nums): for i in range(1, len(nums)): nums[i] += nums[i - 1] return nums"},{"prompt":"There is a safe protected by a password. The password is a sequence of `n` digits where each digit can be in the range `[0, k 1]`. The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the **most recent** `n` **digits** that were entered each time you type a digit. * For example, the correct password is `345 ` and you enter in `012345 `: * After typing `0`, the most recent `3` digits is `0 `, which is incorrect. * After typing `1`, the most recent `3` digits is `01 `, which is incorrect. * After typing `2`, the most recent `3` digits is `012 `, which is incorrect. * After typing `3`, the most recent `3` digits is `123 `, which is incorrect. * After typing `4`, the most recent `3` digits is `234 `, which is incorrect. * After typing `5`, the most recent `3` digits is `345 `, which is correct and the safe unlocks. Return _any string of **minimum length** that will unlock the safe **at some point** of entering it_. **Example 1:** **Input:** n = 1, k = 2 **Output:** 10 **Explanation:** The password is a single digit, so enter each digit. 01 would also unlock the safe. **Example 2:** **Input:** n = 2, k = 2 **Output:** 01100 **Explanation:** For each possible password: 00 is typed in starting from the 4th digit. 01 is typed in starting from the 1st digit. 10 is typed in starting from the 3rd digit. 11 is typed in starting from the 2nd digit. Thus 01100 will unlock the safe. 10011 , and 11001 would also unlock the safe. **Constraints:** * `1 <= n <= 4` * `1 <= k <= 10` * `1 <= kn <= 4096`","completion":"from collections import deque def openLock(deadends, target): dead = set(deadends) visited = set() wheel_states = deque([(\\"0000\\", 0)]) if \\"0000\\" in dead: return -1 while wheel_states: current_state, turns = wheel_states.popleft() if current_state == target: return turns for i in range(4): up_state = current_state[:i] + str((int(current_state[i]) + 1) % 10) + current_state[i + 1:] down_state = current_state[:i] + str((int(current_state[i]) - 1) % 10) + current_state[i + 1:] if up_state not in visited and up_state not in dead: wheel_states.append((up_state, turns + 1)) visited.add(up_state) if down_state not in visited and down_state not in dead: wheel_states.append((down_state, turns + 1)) visited.add(down_state) return -1"},{"prompt":"You are given an `m x n` integer matrix `grid` containing **distinct** positive integers. You have to replace each integer in the matrix with a positive integer satisfying the following conditions: * The **relative** order of every two elements that are in the same row or column should stay the **same** after the replacements. * The **maximum** number in the matrix after the replacements should be as **small** as possible. The relative order stays the same if for all pairs of elements in the original matrix such that `grid[r1][c1] > grid[r2][c2]` where either `r1 == r2` or `c1 == c2`, then it must be true that `grid[r1][c1] > grid[r2][c2]` after the replacements. For example, if `grid = [[2, 4, 5], [7, 3, 9]]` then a good replacement could be either `grid = [[1, 2, 3], [2, 1, 4]]` or `grid = [[1, 2, 3], [3, 1, 4]]`. Return _the **resulting** matrix._ If there are multiple answers, return **any** of them. **Example 1:** **Input:** grid = [[3,1],[2,5]] **Output:** [[2,1],[1,2]] **Explanation:** The above diagram shows a valid replacement. The maximum number in the matrix is 2. It can be shown that no smaller value can be obtained. **Example 2:** **Input:** grid = [[10]] **Output:** [[1]] **Explanation:** We replace the only number in the matrix with 1. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 1000` * `1 <= m * n <= 105` * `1 <= grid[i][j] <= 109` * `grid` consists of distinct integers.","completion":"def smallest_max_number_grid(grid): rows = [0] * len(grid) cols = [0] * len(grid[0]) for i in range(len(grid)): for j in range(len(grid[0])): rows[i] = max(rows[i], grid[i][j]) cols[j] = max(cols[j], grid[i][j]) for i in range(len(grid)): for j in range(len(grid[0])): grid[i][j] = min(rows[i], cols[j]) return grid"},{"prompt":"We have an integer array `nums`, where all the integers in `nums` are **0** or **1**. You will not be given direct access to the array, instead, you will have an **API** `ArrayReader` which have the following functions: * `int query(int a, int b, int c, int d)`: where `0 <= a < b < c < d < ArrayReader.length()`. The function returns the distribution of the value of the 4 elements and returns: * **4** : if the values of the 4 elements are the same (0 or 1). * **2** : if three elements have a value equal to 0 and one element has value equal to 1 or vice versa. * **0** : if two element have a value equal to 0 and two elements have a value equal to 1. * `int length()`: Returns the size of the array. You are allowed to call `query()` **2 * n times** at most where n is equal to `ArrayReader.length()`. Return **any** index of the most frequent value in `nums`, in case of tie, return 1. **Example 1:** **Input:** nums = [0,0,1,0,1,1,1,1] **Output:** 5 **Explanation:** The following calls to the API reader.length() // returns 8 because there are 8 elements in the hidden array. reader.query(0,1,2,3) // returns 2 this is a query that compares the elements nums[0], nums[1], nums[2], nums[3] // Three elements have a value equal to 0 and one element has value equal to 1 or viceversa. reader.query(4,5,6,7) // returns 4 because nums[4], nums[5], nums[6], nums[7] have the same value. we can infer that the most frequent value is found in the last 4 elements. Index 2, 4, 6, 7 is also a correct answer. **Example 2:** **Input:** nums = [0,0,1,1,0] **Output:** 0 **Example 3:** **Input:** nums = [1,0,1,0,1,0,1,0] **Output:** 1 **Constraints:** * `5 <= nums.length <= 105` * `0 <= nums[i] <= 1`","completion":"def maxScore(cardPoints, k): n = len(cardPoints) total = sum(cardPoints[:k]) max_score = total for i in range(k - 1, -1, -1): j = n - k + i total += cardPoints[j] - cardPoints[i] max_score = max(max_score, total) return max_score"},{"prompt":"You are **building** a string `s` of length `n` **one** character at a time, **prepending** each new character to the **front** of the string. The strings are labeled from `1` to `n`, where the string with length `i` is labeled `si`. * For example, for `s = abaca `, `s1 == a `, `s2 == ca `, `s3 == aca `, etc. The **score** of `si` is the length of the **longest common prefix** between `si` and `sn` (Note that `s == sn`). Given the final string `s`, return _the **sum** of the **score** of every_ `si`. **Example 1:** **Input:** s = babab **Output:** 9 **Explanation:** For s1 == b , the longest common prefix is b which has a score of 1. For s2 == ab , there is no common prefix so the score is 0. For s3 == bab , the longest common prefix is bab which has a score of 3. For s4 == abab , there is no common prefix so the score is 0. For s5 == babab , the longest common prefix is babab which has a score of 5. The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9. **Example 2:** **Input:** s = azbazbzaz **Output:** 14 **Explanation:** For s2 == az , the longest common prefix is az which has a score of 2. For s6 == azbzaz , the longest common prefix is azb which has a score of 3. For s9 == azbazbzaz , the longest common prefix is azbazbzaz which has a score of 9. For all other si, the score is 0. The sum of the scores is 2 + 3 + 9 = 14, so we return 14. **Constraints:** * `1 <= s.length <= 105` * `s` consists of lowercase English letters.","completion":"def string_sum_scores(s): score = 0 prefix_length = 0 for i in range(len(s) - 1, -1, -1): if s[i] == s[-1]: prefix_length += 1 else: prefix_length = 0 score += prefix_length return score"},{"prompt":"We have `n` cities labeled from `1` to `n`. Two different cities with labels `x` and `y` are directly connected by a bidirectional road if and only if `x` and `y` share a common divisor **strictly greater** than some `threshold`. More formally, cities with labels `x` and `y` have a road between them if there exists an integer `z` such that all of the following are true: * `x % z == 0`, * `y % z == 0`, and * `z > threshold`. Given the two integers, `n` and `threshold`, and an array of `queries`, you must determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are connected directly or indirectly. (i.e. there is some path between them). Return _an array_ `answer`_, where_ `answer.length == queries.length` _and_ `answer[i]` _is_ `true` _if for the_ `ith` _query, there is a path between_ `ai` _and_ `bi`_, or_ `answer[i]` _is_ `false` _if there is no path._ **Example 1:** **Input:** n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]] **Output:** [false,false,true] **Explanation:** The divisors for each number: 1: 1 2: 1, 2 3: 1, 3 4: 1, 2, 4 5: 1, 5 6: 1, 2, 3, 6 Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the only ones directly connected. The result of each query: [1,4] 1 is not connected to 4 [2,5] 2 is not connected to 5 [3,6] 3 is connected to 6 through path 36 **Example 2:** **Input:** n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]] **Output:** [true,true,true,true,true] **Explanation:** The divisors for each number are the same as the previous example. However, since the threshold is 0, all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected. **Example 3:** **Input:** n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]] **Output:** [false,false,false,false,false] **Explanation:** Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected. Please notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x]. **Constraints:** * `2 <= n <= 104` * `0 <= threshold <= n` * `1 <= queries.length <= 105` * `queries[i].length == 2` * `1 <= ai, bi <= cities` * `ai != bi`","completion":"def lastMoment(n, left, right): max_left = max(left, default=0) min_right = min(right, default=n) return max(max_left, n - min_right)"},{"prompt":"Given a binary string `s`, return `true` _if the **longest** contiguous segment of_ `1`\'_s is **strictly longer** than the **longest** contiguous segment of_ `0`\'_s in_ `s`, or return `false` _otherwise_. * For example, in `s = 110100010 ` the longest continuous segment of `1`s has length `2`, and the longest continuous segment of `0`s has length `3`. Note that if there are no `0`\'s, then the longest continuous segment of `0`\'s is considered to have a length `0`. The same applies if there is no `1`\'s. **Example 1:** **Input:** s = 1101 **Output:** true **Explanation:** The longest contiguous segment of 1s has length 2: 1101 The longest contiguous segment of 0s has length 1: 1101 The segment of 1s is longer, so return true. **Example 2:** **Input:** s = 111000 **Output:** false **Explanation:** The longest contiguous segment of 1s has length 3: 111000 The longest contiguous segment of 0s has length 3: 111000 The segment of 1s is not longer, so return false. **Example 3:** **Input:** s = 110100010 **Output:** false **Explanation:** The longest contiguous segment of 1s has length 2: 110100010 The longest contiguous segment of 0s has length 3: 110100010 The segment of 1s is not longer, so return false. **Constraints:** * `1 <= s.length <= 100` * `s[i]` is either `\'0\'` or `\'1\'`.","completion":"def checkZeroOnes(s: str) -> bool: max_ones, max_zeros, current_ones, current_zeros = 0, 0, 0, 0 for c in s: if c == \'1\': current_ones += 1 current_zeros = 0 else: current_zeros += 1 current_ones = 0 max_ones = max(max_ones, current_ones) max_zeros = max(max_zeros, current_zeros) return max_ones > max_zeros"},{"prompt":"Given a string `s`, consider all _duplicated substrings_: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap. Return **any** duplicated substring that has the longest possible length. If `s` does not have a duplicated substring, the answer is ` `. **Example 1:** **Input:** s = banana **Output:** ana **Example 2:** **Input:** s = abcd **Output:** **Constraints:** * `2 <= s.length <= 3 * 104` * `s` consists of lowercase English letters.","completion":"from collections import Counter def commonChars(words): merged = Counter() for word in words: word_count = Counter(word) if not merged: merged = word_count else: for char in merged: merged[char] = min(merged[char], word_count[char]) result = [] for char, count in merged.items(): result.extend([char] * count) return result"},{"prompt":"A sequence of numbers is called an **arithmetic progression** if the difference between any two consecutive elements is the same. Given an array of numbers `arr`, return `true` _if the array can be rearranged to form an **arithmetic progression**. Otherwise, return_ `false`. **Example 1:** **Input:** arr = [3,5,1] **Output:** true **Explanation:** We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and 2 respectively, between each consecutive elements. **Example 2:** **Input:** arr = [1,2,4] **Output:** false **Explanation:** There is no way to reorder the elements to obtain an arithmetic progression. **Constraints:** * `2 <= arr.length <= 1000` * `106 <= arr[i] <= 106`","completion":"def can_construct(s, k): char_counts = [0] * 26 for c in s: char_counts[ord(c) - ord(\'a\')] += 1 odd_count = sum(count % 2 for count in char_counts) return odd_count <= k <= len(s)"},{"prompt":"Given a string `s`, reverse the string according to the following rules: * All the characters that are not English letters remain in the same position. * All the English letters (lowercase or uppercase) should be reversed. Return `s` _after reversing it_. **Example 1:** **Input:** s = abcd **Output:** dcba **Example 2:** **Input:** s = abCdEfghIj **Output:** jIhgfEdCba **Example 3:** **Input:** s = Test1ngLeet=codeQ! **Output:** Qedo1cteeLg=ntseT! **Constraints:** * `1 <= s.length <= 100` * `s` consists of characters with ASCII values in the range `[33, 122]`. * `s` does not contain `\' \'` or `\'\'`.","completion":"def num_rescue_boats(people, limit): people.sort() left, right = 0, len(people) - 1 boats = 0 while left <= right: if people[left] + people[right] <= limit: left += 1 right -= 1 boats += 1 return boats"},{"prompt":"You are given a **0indexed** integer array `stations` of length `n`, where `stations[i]` represents the number of power stations in the `ith` city. Each power station can provide power to every city in a fixed **range**. In other words, if the range is denoted by `r`, then a power station at city `i` can provide power to all cities `j` such that `|i j| <= r` and `0 <= i, j <= n 1`. * Note that `|x|` denotes **absolute** value. For example, `|7 5| = 2` and `|3 10| = 7`. The **power** of a city is the total number of power stations it is being provided power from. The government has sanctioned building `k` more power stations, each of which can be built in any city, and have the same range as the preexisting ones. Given the two integers `r` and `k`, return _the **maximum possible minimum power** of a city, if the additional power stations are built optimally._ **Note** that you can build the `k` power stations in multiple cities. **Example 1:** **Input:** stations = [1,2,4,5,0], r = 1, k = 2 **Output:** 5 **Explanation:** One of the optimal ways is to install both the power stations at city 1. So stations will become [1,4,4,5,0]. City 0 is provided by 1 + 4 = 5 power stations. City 1 is provided by 1 + 4 + 4 = 9 power stations. City 2 is provided by 4 + 4 + 5 = 13 power stations. City 3 is provided by 5 + 4 = 9 power stations. City 4 is provided by 5 + 0 = 5 power stations. So the minimum power of a city is 5. Since it is not possible to obtain a larger power, we return 5. **Example 2:** **Input:** stations = [4,4,4,4], r = 0, k = 3 **Output:** 4 **Explanation:** It can be proved that we cannot make the minimum power of a city greater than 4. **Constraints:** * `n == stations.length` * `1 <= n <= 105` * `0 <= stations[i] <= 105` * `0 <= r <= n 1` * `0 <= k <= 109`","completion":"def max_min_power(stations, r, k): n = len(stations) total_power = [0] * n for i in range(n): for j in range(max(0, i - r), min(n, i + r + 1)): total_power[j] += stations[i] sumk = 0 min_power = float(\'inf\') for i in range(r, n - r): sumk += stations[i] min_power = min(min_power, total_power[i]) for j in range(2 * r): i = n - 2 * r - 1 - j sumk -= stations[i + r + 1] min_power -= stations[j] min_power += sumk min_power += k min_power = min(min_power, total_power[j]) return min_power"},{"prompt":"A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations. The game is represented by an `m x n` grid of characters `grid` where each element is a wall, floor, or box. Your task is to move the box `\'B\'` to the target position `\'T\'` under the following rules: * The character `\'S\'` represents the player. The player can move up, down, left, right in `grid` if it is a floor (empty cell). * The character `\'.\'` represents the floor which means a free cell to walk. * The character `\'#\'` represents the wall which means an obstacle (impossible to walk there). * There is only one box `\'B\'` and one target cell `\'T\'` in the `grid`. * The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a **push**. * The player cannot walk through the box. Return _the minimum number of **pushes** to move the box to the target_. If there is no way to reach the target, return `1`. **Example 1:** **Input:** grid = [[ # , # , # , # , # , # ], [ # , T , # , # , # , # ], [ # , . , . , B , . , # ], [ # , . , # , # , . , # ], [ # , . , . , . , S , # ], [ # , # , # , # , # , # ]] **Output:** 3 **Explanation:** We return only the number of times the box is pushed. **Example 2:** **Input:** grid = [[ # , # , # , # , # , # ], [ # , T , # , # , # , # ], [ # , . , . , B , . , # ], [ # , # , # , # , . , # ], [ # , . , . , . , S , # ], [ # , # , # , # , # , # ]] **Output:** 1 **Example 3:** **Input:** grid = [[ # , # , # , # , # , # ], [ # , T , . , . , # , # ], [ # , . , # , B , . , # ], [ # , . , . , . , . , # ], [ # , . , . , . , S , # ], [ # , # , # , # , # , # ]] **Output:** 5 **Explanation:** push the box down, left, left, up and up. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 20` * `grid` contains only characters `\'.\'`, `\'#\'`, `\'S\'`, `\'T\'`, or `\'B\'`. * There is only one character `\'S\'`, `\'B\'`, and `\'T\'` in the `grid`.","completion":"def numRollsToTarget(n, k, target): MOD = 10**9 + 7 dp = [[0] * (target + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(1, target + 1): for l in range(1, k + 1): if j >= l: dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD return dp[n][target]"},{"prompt":"There is an ATM machine that stores banknotes of `5` denominations: `20`, `50`, `100`, `200`, and `500` dollars. Initially the ATM is empty. The user can use the machine to deposit or withdraw any amount of money. When withdrawing, the machine prioritizes using banknotes of **larger** values. * For example, if you want to withdraw `300` and there are `2` `50` banknotes, `1` `100` banknote, and `1` `200` banknote, then the machine will use the `100` and `200` banknotes. * However, if you try to withdraw `600` and there are `3` `200` banknotes and `1` `500` banknote, then the withdraw request will be rejected because the machine will first try to use the `500` banknote and then be unable to use banknotes to complete the remaining `100`. Note that the machine is **not** allowed to use the `200` banknotes instead of the `500` banknote. Implement the ATM class: * `ATM()` Initializes the ATM object. * `void deposit(int[] banknotesCount)` Deposits new banknotes in the order `20`, `50`, `100`, `200`, and `500`. * `int[] withdraw(int amount)` Returns an array of length `5` of the number of banknotes that will be handed to the user in the order `20`, `50`, `100`, `200`, and `500`, and update the number of banknotes in the ATM after withdrawing. Returns `[1]` if it is not possible (do **not** withdraw any banknotes in this case). **Example 1:** **Input** [ ATM , deposit , withdraw , deposit , withdraw , withdraw ] [[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]] **Output** [null, null, [0,0,1,0,1], null, [1], [0,1,0,0,1]] **Explanation** ATM atm = new ATM(); atm.deposit([0,0,1,2,1]); // Deposits 1 100 banknote, 2 200 banknotes, // and 1 500 banknote. atm.withdraw(600); // Returns [0,0,1,0,1]. The machine uses 1 100 banknote // and 1 500 banknote. The banknotes left over in the // machine are [0,0,0,2,0]. atm.deposit([0,1,0,1,1]); // Deposits 1 50, 200, and 500 banknote. // The banknotes in the machine are now [0,1,0,3,1]. atm.withdraw(600); // Returns [1]. The machine will try to use a 500 banknote // and then be unable to complete the remaining 100, // so the withdraw request will be rejected. // Since the request is rejected, the number of banknotes // in the machine is not modified. atm.withdraw(550); // Returns [0,1,0,0,1]. The machine uses 1 50 banknote // and 1 500 banknote. **Constraints:** * `banknotesCount.length == 5` * `0 <= banknotesCount[i] <= 109` * `1 <= amount <= 109` * At most `5000` calls **in total** will be made to `withdraw` and `deposit`. * At least **one** call will be made to each function `withdraw` and `deposit`.","completion":"def recoverArray(n, nums): nums.sort() arr = [nums[i * 2] for i in range(n)] return arr"},{"prompt":"Given two string arrays `word1` and `word2`, return `true` _if the two arrays **represent** the same string, and_ `false` _otherwise._ A string is **represented** by an array if the array elements concatenated **in order** forms the string. **Example 1:** **Input:** word1 = [ ab , c ], word2 = [ a , bc ] **Output:** true **Explanation:** word1 represents string ab + c > abc word2 represents string a + bc > abc The strings are the same, so return true. **Example 2:** **Input:** word1 = [ a , cb ], word2 = [ ab , c ] **Output:** false **Example 3:** **Input:** word1 = [ abc , d , defg ], word2 = [ abcddefg ] **Output:** true **Constraints:** * `1 <= word1.length, word2.length <= 103` * `1 <= word1[i].length, word2[i].length <= 103` * `1 <= sum(word1[i].length), sum(word2[i].length) <= 103` * `word1[i]` and `word2[i]` consist of lowercase letters.","completion":"def min_num_operations(nums): result = 0 highest_bit = [0] * 32 for num in nums: for j in range(32): if num & (1 << j): highest_bit[j] += 1 for count in highest_bit: result = max(result, count) return result + 31"},{"prompt":"You are given an integer `n` representing the length of an unknown array that you are trying to recover. You are also given an array `sums` containing the values of all `2n` **subset sums** of the unknown array (in no particular order). Return _the array_ `ans` _of length_ `n` _representing the unknown array. If **multiple** answers exist, return **any** of them_. An array `sub` is a **subset** of an array `arr` if `sub` can be obtained from `arr` by deleting some (possibly zero or all) elements of `arr`. The sum of the elements in `sub` is one possible **subset sum** of `arr`. The sum of an empty array is considered to be `0`. **Note:** Test cases are generated such that there will **always** be at least one correct answer. **Example 1:** **Input:** n = 3, sums = [3,2,1,0,0,1,2,3] **Output:** [1,2,3] **Explanation:** [1,2,3] is able to achieve the given subset sums: []: sum is 0 [1]: sum is 1 [2]: sum is 2 [1,2]: sum is 3 [3]: sum is 3 [1,3]: sum is 2 [2,3]: sum is 1 [1,2,3]: sum is 0 Note that any permutation of [1,2,3] and also any permutation of [1,2,3] will also be accepted. **Example 2:** **Input:** n = 2, sums = [0,0,0,0] **Output:** [0,0] **Explanation:** The only correct answer is [0,0]. **Example 3:** **Input:** n = 4, sums = [0,0,5,5,4,1,4,9,9,1,4,3,4,8,3,8] **Output:** [0,1,4,5] **Explanation:** [0,1,4,5] is able to achieve the given subset sums. **Constraints:** * `1 <= n <= 15` * `sums.length == 2n` * `104 <= sums[i] <= 104`","completion":"from collections import Counter def recoverArray(n, sums): sums = Counter(sums) ans = [] while len(ans) < n: # remove the 0 sum sums[0] -= 1 if sums[0] == 0: del sums[0] # selected next value cur = next(iter(sums)) sums[cur] -= 1 if sums[cur] == 0: del sums[cur] # update sums tmp = Counter() for k, v in sums.items(): cnt = v - Ans.count(k - cur) if cnt > 0: tmp[k] = cnt sums = tmp ans.append(cur) return ans"},{"prompt":"You are given a **0indexed** string array `words`, where `words[i]` consists of lowercase English letters. In one operation, select any index `i` such that `0 < i < words.length` and `words[i 1]` and `words[i]` are **anagrams**, and **delete** `words[i]` from `words`. Keep performing this operation as long as you can select an index that satisfies the conditions. Return `words` _after performing all operations_. It can be shown that selecting the indices for each operation in **any** arbitrary order will lead to the same result. An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, `dacb ` is an anagram of `abdc `. **Example 1:** **Input:** words = [ abba , baba , bbaa , cd , cd ] **Output:** [ abba , cd ] **Explanation:** One of the ways we can obtain the resultant array is by using the following operations: Since words[2] = bbaa and words[1] = baba are anagrams, we choose index 2 and delete words[2]. Now words = [ abba , baba , cd , cd ]. Since words[1] = baba and words[0] = abba are anagrams, we choose index 1 and delete words[1]. Now words = [ abba , cd , cd ]. Since words[2] = cd and words[1] = cd are anagrams, we choose index 2 and delete words[2]. Now words = [ abba , cd ]. We can no longer perform any operations, so [ abba , cd ] is the final answer. **Example 2:** **Input:** words = [ a , b , c , d , e ] **Output:** [ a , b , c , d , e ] **Explanation:** No two adjacent strings in words are anagrams of each other, so no operations are performed. **Constraints:** * `1 <= words.length <= 100` * `1 <= words[i].length <= 10` * `words[i]` consists of lowercase English letters.","completion":"def anagramOperations(words): i = 1 while i < len(words): word1 = sorted(words[i]) word2 = sorted(words[i - 1]) if word1 == word2: del words[i] else: i += 1 return words"},{"prompt":"You are given a string of digits `num`, such as `123456579 `. We can split it into a Fibonaccilike sequence `[123, 456, 579]`. Formally, a **Fibonaccilike** sequence is a list `f` of nonnegative integers such that: * `0 <= f[i] < 231`, (that is, each integer fits in a **32bit** signed integer type), * `f.length >= 3`, and * `f[i] + f[i + 1] == f[i + 2]` for all `0 <= i < f.length 2`. Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number `0` itself. Return any Fibonaccilike sequence split from `num`, or return `[]` if it cannot be done. **Example 1:** **Input:** num = 1101111 **Output:** [11,0,11,11] **Explanation:** The output [110, 1, 111] would also be accepted. **Example 2:** **Input:** num = 112358130 **Output:** [] **Explanation:** The task is impossible. **Example 3:** **Input:** num = 0123 **Output:** [] **Explanation:** Leading zeroes are not allowed, so 01 , 2 , 3 is not valid. **Constraints:** * `1 <= num.length <= 200` * `num` contains only digits.","completion":"def smallest_good_integer(fronts, backs): not_good = {fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i]} result = float(\'inf\') for i in range(len(fronts)): if fronts[i] not in not_good: result = min(result, fronts[i]) if backs[i] not in not_good: result = min(result, backs[i]) return 0 if result == float(\'inf\') else result"},{"prompt":"You own a **Goal Parser** that can interpret a string `command`. The `command` consists of an alphabet of `G `, `() ` and/or `(al) ` in some order. The Goal Parser will interpret `G ` as the string `G `, `() ` as the string `o `, and `(al) ` as the string `al `. The interpreted strings are then concatenated in the original order. Given the string `command`, return _the **Goal Parser**\'s interpretation of_ `command`. **Example 1:** **Input:** command = G()(al) **Output:** Goal **Explanation:** The Goal Parser interprets the command as follows: G > G () > o (al) > al The final concatenated result is Goal . **Example 2:** **Input:** command = G()()()()(al) **Output:** Gooooal **Example 3:** **Input:** command = (al)G(al)()()G **Output:** alGalooG **Constraints:** * `1 <= command.length <= 100` * `command` consists of `G `, `() `, and/or `(al) ` in some order.","completion":"def num_ways(s: str) -> int: number_of_ones = s.count(\'1\') if number_of_ones % 3 != 0: return 0 target = number_of_ones // 3 if target == 0: n = len(s) return ((n - 1) * (n - 2) // 2) % 1000000007 ones_so_far1, ones_so_far2 = 0, 0 way1, way2 = 0, 0 for c in s: if c == \'1\': ones_so_far1 += 1 if ones_so_far1 == target: way1 += 1 ones_so_far1 = 0 ones_so_far2 += 1 if ones_so_far2 == target * 2: way2 += 1 ones_so_far2 = 0 return (way1 * way2) % 1000000007"},{"prompt":"You are given an integer array `nums` of `2 * n` integers. You need to partition `nums` into **two** arrays of length `n` to **minimize the absolute difference** of the **sums** of the arrays. To partition `nums`, put each element of `nums` into **one** of the two arrays. Return _the **minimum** possible absolute difference_. **Example 1:** **Input:** nums = [3,9,7,3] **Output:** 2 **Explanation:** One optimal partition is: [3,9] and [7,3]. The absolute difference between the sums of the arrays is abs((3 + 9) (7 + 3)) = 2. **Example 2:** **Input:** nums = [36,36] **Output:** 72 **Explanation:** One optimal partition is: [36] and [36]. The absolute difference between the sums of the arrays is abs((36) (36)) = 72. **Example 3:** **Input:** nums = [2,1,0,4,2,9] **Output:** 0 **Explanation:** One optimal partition is: [2,4,9] and [1,0,2]. The absolute difference between the sums of the arrays is abs((2 + 4 + 9) (1 + 0 + 2)) = 0. **Constraints:** * `1 <= n <= 15` * `nums.length == 2 * n` * `107 <= nums[i] <= 107`","completion":"def countSubIslands(grid1, grid2): def dfs(i, j): if i < 0 or i >= len(grid1) or j < 0 or j >= len(grid1[0]) or grid2[i][j] == 0: return True grid2[i][j] = 0 isSubIsland = grid1[i][j] == 1 isSubIsland &= dfs(i + 1, j) isSubIsland &= dfs(i - 1, j) isSubIsland &= dfs(i, j + 1) isSubIsland &= dfs(i, j - 1) return isSubIsland count = 0 for i in range(len(grid1)): for j in range(len(grid1[0])): if grid2[i][j] == 1 and dfs(i, j): count += 1 return count"},{"prompt":"You are given two string arrays `words1` and `words2`. A string `b` is a **subset** of string `a` if every letter in `b` occurs in `a` including multiplicity. * For example, `wrr ` is a subset of `warrior ` but is not a subset of `world `. A string `a` from `words1` is **universal** if for every string `b` in `words2`, `b` is a subset of `a`. Return an array of all the **universal** strings in `words1`. You may return the answer in **any order**. **Example 1:** **Input:** words1 = [ amazon , apple , facebook , google , leetcode ], words2 = [ e , o ] **Output:** [ facebook , google , leetcode ] **Example 2:** **Input:** words1 = [ amazon , apple , facebook , google , leetcode ], words2 = [ l , e ] **Output:** [ apple , google , leetcode ] **Constraints:** * `1 <= words1.length, words2.length <= 104` * `1 <= words1[i].length, words2[i].length <= 10` * `words1[i]` and `words2[i]` consist only of lowercase English letters. * All the strings of `words1` are **unique**.","completion":"def find_kth_character(s: str, k: int) -> str: n = len(s) size = 0 for c in s: if c.isdigit(): size = size * int(c) else: size += 1 for i in range(n - 1, -1, -1): c = s[i] k %= size if k == 0 and not c.isdigit(): return c if c.isdigit(): size //= int(c) else: size -= 1 return \'-\'"},{"prompt":"You are given a positive integer `n`, you can do the following operation **any** number of times: * Add or subtract a **power** of `2` from `n`. Return _the **minimum** number of operations to make_ `n` _equal to_ `0`. A number `x` is power of `2` if `x == 2i` where `i >= 0`_._ **Example 1:** **Input:** n = 39 **Output:** 3 **Explanation:** We can do the following operations: Add 20 = 1 to n, so now n = 40. Subtract 23 = 8 from n, so now n = 32. Subtract 25 = 32 from n, so now n = 0. It can be shown that 3 is the minimum number of operations we need to make n equal to 0. **Example 2:** **Input:** n = 54 **Output:** 3 **Explanation:** We can do the following operations: Add 21 = 2 to n, so now n = 56. Add 23 = 8 to n, so now n = 64. Subtract 26 = 64 from n, so now n = 0. So the minimum number of operations is 3. **Constraints:** * `1 <= n <= 105`","completion":"def minOperations(n: int) -> int: operations = 0 while n: operations += n % 2 n //= 2 return operations"},{"prompt":"Given a string `s` of lowercase letters, you need to find the maximum number of **nonempty** substrings of `s` that meet the following conditions: 1. The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[x..y]`, either `j < x` or `i > y` is true. 2. A substring that contains a certain character `c` must also contain all occurrences of `c`. Find _the maximum number of substrings that meet the above conditions_. If there are multiple solutions with the same number of substrings, _return the one with minimum total length._ It can be shown that there exists a unique solution of minimum total length. Notice that you can return the substrings in **any** order. **Example 1:** **Input:** s = adefaddaccc **Output:** [ e , f , ccc ] **Explanation:** The following are all the possible substrings that meet the conditions: [ adefaddaccc adefadda , ef , e , f , ccc , ] If we choose the first string, we cannot choose anything else and we\'d get only 1. If we choose adefadda , we are left with ccc which is the only one that doesn\'t overlap, thus obtaining 2 substrings. Notice also, that it\'s not optimal to choose ef since it can be split into two. Therefore, the optimal way is to choose [ e , f , ccc ] which gives us 3 substrings. No other solution of the same number of substrings exist. **Example 2:** **Input:** s = abbaccd **Output:** [ d , bb , cc ] **Explanation:** Notice that while the set of substrings [ d , abba , cc ] also has length 3, it\'s considered incorrect since it has larger total length. **Constraints:** * `1 <= s.length <= 105` * `s` contains only lowercase English letters.","completion":"def num_steps(s: str) -> int: steps = 0 carry = 0 for i in range(len(s) - 1, 0, -1): current = int(s[i]) + carry if current == 1: steps += 2 carry = 1 else: steps += carry carry = current return steps + carry"},{"prompt":"You are given an integer `n` denoting the number of nodes of a **weighted directed** graph. The nodes are numbered from `0` to `n 1`. You are also given a 2D integer array `edges` where `edges[i] = [fromi, toi, weighti]` denotes that there exists a **directed** edge from `fromi` to `toi` with weight `weighti`. Lastly, you are given three **distinct** integers `src1`, `src2`, and `dest` denoting three distinct nodes of the graph. Return _the **minimum weight** of a subgraph of the graph such that it is **possible** to reach_ `dest` _from both_ `src1` _and_ `src2` _via a set of edges of this subgraph_. In case such a subgraph does not exist, return `1`. A **subgraph** is a graph whose vertices and edges are subsets of the original graph. The **weight** of a subgraph is the sum of weights of its constituent edges. **Example 1:** **Input:** n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5 **Output:** 9 **Explanation:** The above figure represents the input graph. The blue edges represent one of the subgraphs that yield the optimal answer. Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints. **Example 2:** **Input:** n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2 **Output:** 1 **Explanation:** The above figure represents the input graph. It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints. **Constraints:** * `3 <= n <= 105` * `0 <= edges.length <= 105` * `edges[i].length == 3` * `0 <= fromi, toi, src1, src2, dest <= n 1` * `fromi != toi` * `src1`, `src2`, and `dest` are pairwise distinct. * `1 <= weight[i] <= 105`","completion":"from heapq import heappop, heappush from sys import maxsize def dijkstra(src, adj): dist = [maxsize] * len(adj) dist[src] = 0 pq = [(0, src)] while pq: d, u = heappop(pq) if d != dist[u]: continue for v, w in adj[u]: if d + w < dist[v]: dist[v] = d + w heappush(pq, (dist[v], v)) return dist def min_weight_subgraph(n, edges, src1, src2, dest): adj = [[] for _ in range(n)] for u, v, w in edges: adj[u].append((v, w)) dist1 = dijkstra(src1, adj) dist2 = dijkstra(src2, adj) res = dist1[dest] + dist2[dest] for u, v, w in edges: res = min(res, dist1[u] + dist2[v] + w) res = min(res, dist1[v] + dist2[u] + w) return res if res != maxsize else -1"},{"prompt":"You have `n` `tiles`, where each tile has one letter `tiles[i]` printed on it. Return _the number of possible nonempty sequences of letters_ you can make using the letters printed on those `tiles`. **Example 1:** **Input:** tiles = AAB **Output:** 8 **Explanation:** The possible sequences are A , B , AA , AB , BA , AAB , ABA , BAA . **Example 2:** **Input:** tiles = AAABBC **Output:** 188 **Example 3:** **Input:** tiles = V **Output:** 1 **Constraints:** * `1 <= tiles.length <= 7` * `tiles` consists of uppercase English letters.","completion":"def sumRootToLeaf(root, path_value=0): if not root: return 0 path_value = path_value * 2 + root.val if not root.left and not root.right: return path_value return sumRootToLeaf(root.left, path_value) + sumRootToLeaf(root.right, path_value)"},{"prompt":"A square matrix is said to be an **XMatrix** if **both** of the following conditions hold: 1. All the elements in the diagonals of the matrix are **nonzero**. 2. All other elements are 0. Given a 2D integer array `grid` of size `n x n` representing a square matrix, return `true` _if_ `grid` _is an XMatrix_. Otherwise, return `false`. **Example 1:** **Input:** grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]] **Output:** true **Explanation:** Refer to the diagram above. An XMatrix should have the green elements (diagonals) be nonzero and the red elements be 0. Thus, grid is an XMatrix. **Example 2:** **Input:** grid = [[5,7,0],[0,3,1],[0,5,0]] **Output:** false **Explanation:** Refer to the diagram above. An XMatrix should have the green elements (diagonals) be nonzero and the red elements be 0. Thus, grid is not an XMatrix. **Constraints:** * `n == grid.length == grid[i].length` * `3 <= n <= 100` * `0 <= grid[i][j] <= 105`","completion":"def longest_repeat_substring(s, query_characters, query_indices): k = len(query_characters) lengths = [] s_copy = list(s) for i in range(k): s_copy[query_indices[i]] = query_characters[i] max_len = cur_len = 1 for j in range(1, len(s_copy)): if s_copy[j] == s_copy[j-1]: cur_len += 1 else: max_len = max(max_len, cur_len) cur_len = 1 max_len = max(max_len, cur_len) lengths.append(max_len) return lengths"},{"prompt":"You have `n` bulbs in a row numbered from `1` to `n`. Initially, all the bulbs are turned off. We turn on **exactly one** bulb every day until all bulbs are on after `n` days. You are given an array `bulbs` of length `n` where `bulbs[i] = x` means that on the `(i+1)th` day, we will turn on the bulb at position `x` where `i` is **0indexed** and `x` is **1indexed.** Given an integer `k`, return _the **minimum day number** such that there exists two **turned on** bulbs that have **exactly** `k` bulbs between them that are **all turned off**. If there isn\'t such day, return `1`._ **Example 1:** **Input:** bulbs = [1,3,2], k = 1 **Output:** 2 **Explanation:** On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0] On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1] On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1] We return 2 because on the second day, there were two on bulbs with one off bulb between them. **Example 2:** **Input:** bulbs = [1,2,3], k = 1 **Output:** 1 **Constraints:** * `n == bulbs.length` * `1 <= n <= 2 * 104` * `1 <= bulbs[i] <= n` * `bulbs` is a permutation of numbers from `1` to `n`. * `0 <= k <= 2 * 104`","completion":"def kEmptySlots(bulbs, k): days = [0] * len(bulbs) for i, bulb in enumerate(bulbs): days[bulb - 1] = i ans = float(\'inf\') left = 0 right = k + 1 while right < len(days): i = left + 1 for i in range(left + 1, right): if days[i] < days[left] or days[i] < days[right]: left = i break else: ans = min(ans, max(days[left], days[right])) left += 1 right += 1 return -1 if ans == float(\'inf\') else ans + 1"},{"prompt":"You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`. Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove **exactly one node** from `initial`. Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with **the smallest index**. Note that if a node was removed from the `initial` list of infected nodes, it might still be infected later due to the malware spread. **Example 1:** **Input:** graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] **Output:** 0 **Example 2:** **Input:** graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] **Output:** 0 **Example 3:** **Input:** graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] **Output:** 1 **Constraints:** * `n == graph.length` * `n == graph[i].length` * `2 <= n <= 300` * `graph[i][j]` is `0` or `1`. * `graph[i][j] == graph[j][i]` * `graph[i][i] == 1` * `1 <= initial.length <= n` * `0 <= initial[i] <= n 1` * All the integers in `initial` are **unique**.","completion":"def fair_candy_swap(aliceSizes, bobSizes): aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes) delta = (bobTotal - aliceTotal) // 2 for a in aliceSizes: for b in bobSizes: if a + delta == b: return [a, b] return []"},{"prompt":"We are given a list `nums` of integers representing a list compressed with runlength encoding. Consider each adjacent pair of elements `[freq, val] = [nums[2*i], nums[2*i+1]]` (with `i >= 0`). For each such pair, there are `freq` elements with value `val` concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list. **Example 1:** **Input:** nums = [1,2,3,4] **Output:** [2,4,4,4] **Explanation:** The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2]. The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4]. At the end the concatenation [2] + [4,4,4] is [2,4,4,4]. **Example 2:** **Input:** nums = [1,1,2,3] **Output:** [1,3,3] **Constraints:** * `2 <= nums.length <= 100` * `nums.length % 2 == 0` * `1 <= nums[i] <= 100`","completion":"MOD = 10**9 + 7 def add_rooms(idx, children, memo): if not children[idx]: return 1 if memo[idx] != -1: return memo[idx] res = 1 cnt = 0 for child in children[idx]: cnt += 1 res = (res * add_rooms(child, children, memo)) % MOD for i in range(2, cnt + 1): res = (res * i) % MOD memo[idx] = res return res def num_of_ways(prev_room): n = len(prev_room) children = [[] for _ in range(n)] for i in range(1, n): children[prev_room[i]].append(i) memo = [-1] * n return add_rooms(0, children, memo)"},{"prompt":"Given an array of integers `nums`, sort the array in **increasing** order based on the frequency of the values. If multiple values have the same frequency, sort them in **decreasing** order. Return the _sorted array_. **Example 1:** **Input:** nums = [1,1,2,2,2,3] **Output:** [3,1,1,2,2,2] **Explanation:** \'3\' has a frequency of 1, \'1\' has a frequency of 2, and \'2\' has a frequency of 3. **Example 2:** **Input:** nums = [2,3,1,3,2] **Output:** [1,3,3,2,2] **Explanation:** \'2\' and \'3\' both have a frequency of 2, so they are sorted in decreasing order. **Example 3:** **Input:** nums = [1,1,6,4,5,6,1,4,1] **Output:** [5,1,4,4,6,6,1,1,1] **Constraints:** * `1 <= nums.length <= 100` * `100 <= nums[i] <= 100`","completion":"def num_sub(s: str) -> int: mod = 1000000007 result = 0 count = 0 for c in s: count = count + 1 if c == \'1\' else 0 result = (result + count) % mod return result"},{"prompt":"You are given a positive integer `n`, indicating that we initially have an `n x n` **0indexed** integer matrix `mat` filled with zeroes. You are also given a 2D integer array `query`. For each `query[i] = [row1i, col1i, row2i, col2i]`, you should do the following operation: * Add `1` to **every element** in the submatrix with the **top left** corner `(row1i, col1i)` and the **bottom right** corner `(row2i, col2i)`. That is, add `1` to `mat[x][y]` for all `row1i <= x <= row2i` and `col1i <= y <= col2i`. Return _the matrix_ `mat` _after performing every query._ **Example 1:** **Input:** n = 3, queries = [[1,1,2,2],[0,0,1,1]] **Output:** [[1,1,0],[1,2,1],[0,1,1]] **Explanation:** The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query. In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2). In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1). **Example 2:** **Input:** n = 2, queries = [[0,0,1,1]] **Output:** [[1,1],[1,1]] **Explanation:** The diagram above shows the initial matrix and the matrix after the first query. In the first query we add 1 to every element in the matrix. **Constraints:** * `1 <= n <= 500` * `1 <= queries.length <= 104` * `0 <= row1i <= row2i < n` * `0 <= col1i <= col2i < n`","completion":"def apply_queries(n, queries): mat = [[0] * n for _ in range(n)] for query in queries: for i in range(query[0], query[2] + 1): for j in range(query[1], query[3] + 1): mat[i][j] += 1 return mat"},{"prompt":"You are given a binary string `s` and a positive integer `k`. Return _the length of the **longest** subsequence of_ `s` _that makes up a **binary** number less than or equal to_ `k`. Note: * The subsequence can contain **leading zeroes**. * The empty string is considered to be equal to `0`. * A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. **Example 1:** **Input:** s = 1001010 , k = 5 **Output:** 5 **Explanation:** The longest subsequence of s that makes up a binary number less than or equal to 5 is 00010 , as this number is equal to 2 in decimal. Note that 00100 and 00101 are also possible, which are equal to 4 and 5 in decimal, respectively. The length of this subsequence is 5, so 5 is returned. **Example 2:** **Input:** s = 00101001 , k = 1 **Output:** 6 **Explanation:** 000001 is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal. The length of this subsequence is 6, so 6 is returned. **Constraints:** * `1 <= s.length <= 1000` * `s[i]` is either `\'0\'` or `\'1\'`. * `1 <= k <= 109`","completion":"def min_visible_white_tiles(floor, num_carpets, carpet_len): n = len(floor) visible_white_count = floor.count(\'1\') covered_tiles = 0 for i in range(n): if floor[i] == \'1\': start = max(0, i - carpet_len + 1) end = min(n - carpet_len, i) max_cover = 0 for first_tile in range(start, end + 1): cover = floor[first_tile:first_tile + carpet_len].count(\'1\') max_cover = max(max_cover, cover) covered_tiles += max_cover num_carpets -= 1 if num_carpets == 0: break return visible_white_count - covered_tiles"},{"prompt":"There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way. You are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point. * For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2. The frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane. * For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3. Return _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._ **Note:** There will be no obstacles on points `0` and `n`. **Example 1:** **Input:** obstacles = [0,1,2,3,0] **Output:** 2 **Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows). Note that the frog can jump over obstacles only when making side jumps (as shown at point 2). **Example 2:** **Input:** obstacles = [0,1,1,3,3,0] **Output:** 0 **Explanation:** There are no obstacles on lane 2. No side jumps are required. **Example 3:** **Input:** obstacles = [0,2,1,0,3,0] **Output:** 2 **Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps. **Constraints:** * `obstacles.length == n + 1` * `1 <= n <= 5 * 105` * `0 <= obstacles[i] <= 3` * `obstacles[0] == obstacles[n] == 0`","completion":"import heapq def eatenApples(apples, days): n = len(apples) pq = [] ans = 0 for i in range(n + 1): if i < n and apples[i] > 0: heapq.heappush(pq, (i + days[i], apples[i])) while pq and pq[0][0] <= i: heapq.heappop(pq) if pq: ans += 1 curr_apple = heapq.heappop(pq) if curr_apple[1] > 1: heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1)) return ans"},{"prompt":"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`: * `actuali` is the actual amount of energy you **spend to finish** the `ith` task. * `minimumi` is the minimum amount of energy you **require to begin** the `ith` task. For example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it. You can finish the tasks in **any order** you like. Return _the **minimum** initial amount of energy you will need_ _to finish all the tasks_. **Example 1:** **Input:** tasks = [[1,2],[2,4],[4,8]] **Output:** 8 **Explanation:** Starting with 8 energy, we finish the tasks in the following order: 3rd task. Now energy = 8 4 = 4. 2nd task. Now energy = 4 2 = 2. 1st task. Now energy = 2 1 = 1. Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task. **Example 2:** **Input:** tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]] **Output:** 32 **Explanation:** Starting with 32 energy, we finish the tasks in the following order: 1st task. Now energy = 32 1 = 31. 2nd task. Now energy = 31 2 = 29. 3rd task. Now energy = 29 10 = 19. 4th task. Now energy = 19 10 = 9. 5th task. Now energy = 9 8 = 1. **Example 3:** **Input:** tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]] **Output:** 27 **Explanation:** Starting with 27 energy, we finish the tasks in the following order: 5th task. Now energy = 27 5 = 22. 2nd task. Now energy = 22 2 = 20. 3rd task. Now energy = 20 3 = 17. 1st task. Now energy = 17 1 = 16. 4th task. Now energy = 16 4 = 12. 6th task. Now energy = 12 6 = 6. **Constraints:** * `1 <= tasks.length <= 105` * `1 <= actual​i <= minimumi <= 104`","completion":"def minimumEffort(tasks): tasks.sort(key=lambda task: task[1] - task[0], reverse=True) ans, sum_energy = 0, 0 for task in tasks: ans = max(ans, sum_energy + task[1]) sum_energy += task[0] return ans"},{"prompt":"A **peak** element in a 2D grid is an element that is **strictly greater** than all of its **adjacent** neighbors to the left, right, top, and bottom. Given a **0indexed** `m x n` matrix `mat` where **no two adjacent cells are equal**, find **any** peak element `mat[i][j]` and return _the length 2 array_ `[i,j]`. You may assume that the entire matrix is surrounded by an **outer perimeter** with the value `1` in each cell. You must write an algorithm that runs in `O(m log(n))` or `O(n log(m))` time. **Example 1:** **Input:** mat = [[1,4],[3,2]] **Output:** [0,1] **Explanation:** Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers. **Example 2:** **Input:** mat = [[10,20,15],[21,30,14],[7,16,32]] **Output:** [1,1] **Explanation:** Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers. **Constraints:** * `m == mat.length` * `n == mat[i].length` * `1 <= m, n <= 500` * `1 <= mat[i][j] <= 105` * No two adjacent cells are equal.","completion":"def min_operations(nums1, nums2): sum1, sum2 = sum(nums1), sum(nums2) if sum1 == sum2: return 0 if sum1 < sum2: nums1, nums2 = nums2, nums1 nums1.sort(reverse=True) nums2.sort() diff, operations, i, j = abs(sum1 - sum2), 0, 0, 0 while diff > 0 and (i < len(nums1) or j < len(nums2)): option1 = nums1[i] - 1 if i < len(nums1) else 0 option2 = 6 - nums2[j] if j < len(nums2) else 0 if option1 > option2: diff -= option1 i += 1 else: diff -= option2 j += 1 operations += 1 return operations if diff == 0 else -1"},{"prompt":"There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a **unique** color. You are given a 2D integer array `segments`, where `segments[i] = [starti, endi, colori]` represents the **halfclosed segment** `[starti, endi)` with `colori` as the color. The colors in the overlapping segments of the painting were **mixed** when it was painted. When two or more colors mix, they form a new color that can be represented as a **set** of mixed colors. * For example, if colors `2`, `4`, and `6` are mixed, then the resulting mixed color is `{2,4,6}`. For the sake of simplicity, you should only output the **sum** of the elements in the set rather than the full set. You want to **describe** the painting with the **minimum** number of nonoverlapping **halfclosed segments** of these mixed colors. These segments can be represented by the 2D array `painting` where `painting[j] = [leftj, rightj, mixj]` describes a **halfclosed segment** `[leftj, rightj)` with the mixed color **sum** of `mixj`. * For example, the painting created with `segments = [[1,4,5],[1,7,7]]` can be described by `painting = [[1,4,12],[4,7,7]]` because: * `[1,4)` is colored `{5,7}` (with a sum of `12`) from both the first and second segments. * `[4,7)` is colored `{7}` from only the second segment. Return _the 2D array_ `painting` _describing the finished painting (excluding any parts that are **not** painted). You may return the segments in **any order**_. A **halfclosed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`. **Example 1:** **Input:** segments = [[1,4,5],[4,7,7],[1,7,9]] **Output:** [[1,4,14],[4,7,16]] **Explanation:** The painting can be described as follows: [1,4) is colored {5,9} (with a sum of 14) from the first and third segments. [4,7) is colored {7,9} (with a sum of 16) from the second and third segments. **Example 2:** **Input:** segments = [[1,7,9],[6,8,15],[8,10,7]] **Output:** [[1,6,9],[6,7,24],[7,8,15],[8,10,7]] **Explanation:** The painting can be described as follows: [1,6) is colored 9 from the first segment. [6,7) is colored {9,15} (with a sum of 24) from the first and second segments. [7,8) is colored 15 from the second segment. [8,10) is colored 7 from the third segment. **Example 3:** **Input:** segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]] **Output:** [[1,4,12],[4,7,12]] **Explanation:** The painting can be described as follows: [1,4) is colored {5,7} (with a sum of 12) from the first and second segments. [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments. Note that returning a single segment [1,7) is incorrect because the mixed color sets are different. **Constraints:** * `1 <= segments.length <= 2 * 104` * `segments[i].length == 3` * `1 <= starti < endi <= 105` * `1 <= colori <= 109` * Each `colori` is distinct.","completion":"def splitPainting(segments): line = {} for s in segments: start, end, color = s if start not in line: line[start] = 0 if end not in line: line[end] = 0 line[start] += color line[end] -= color res = [] pre = 0 sum = 0 for key in sorted(line.keys()): if pre > 0: if sum > 0: res.append([pre, key, sum]) pre = key sum += line[key] return res"},{"prompt":"Given a **nonnegative** integer `num`, return `true` _if_ `num` _can be expressed as the sum of any **nonnegative** integer and its reverse, or_ `false` _otherwise._ **Example 1:** **Input:** num = 443 **Output:** true **Explanation:** 172 + 271 = 443 so we return true. **Example 2:** **Input:** num = 63 **Output:** false **Explanation:** 63 cannot be expressed as the sum of a nonnegative integer and its reverse so we return false. **Example 3:** **Input:** num = 181 **Output:** true **Explanation:** 140 + 041 = 181 so we return true. Note that when a number is reversed, there may be leading zeros. **Constraints:** * `0 <= num <= 105`","completion":"def sum_with_reverse(num: int) -> bool: for i in range(num + 1): reverse = int(str(i)[::-1]) if i + reverse == num: return True return False"},{"prompt":"A **pangram** is a sentence where every letter of the English alphabet appears at least once. Given a string `sentence` containing only lowercase English letters, return `true` _if_ `sentence` _is a **pangram**, or_ `false` _otherwise._ **Example 1:** **Input:** sentence = thequickbrownfoxjumpsoverthelazydog **Output:** true **Explanation:** sentence contains at least one of every letter of the English alphabet. **Example 2:** **Input:** sentence = leetcode **Output:** false **Constraints:** * `1 <= sentence.length <= 1000` * `sentence` consists of lowercase English letters.","completion":"from bisect import bisect_left def min_operations(target, arr): index_map = {num: i for i, num in enumerate(target)} lis = [] for num in arr: if num in index_map: pos = bisect_left(lis, index_map[num]) if pos == len(lis): lis.append(index_map[num]) else: lis[pos] = index_map[num] return len(target) - len(lis)"},{"prompt":"You are given a string `s` consisting of lowercase English letters, and an integer `k`. First, **convert** `s` into an integer by replacing each letter with its position in the alphabet (i.e., replace `\'a\'` with `1`, `\'b\'` with `2`, ..., `\'z\'` with `26`). Then, **transform** the integer by replacing it with the **sum of its digits**. Repeat the **transform** operation `k` **times** in total. For example, if `s = zbax ` and `k = 2`, then the resulting integer would be `8` by the following operations: * **Convert**: `zbax ➝ (26)(2)(1)(24) ➝ 262124 ➝ 262124` * **Transform #1**: `262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17` * **Transform #2**: `17 ➝ 1 + 7 ➝ 8` Return _the resulting integer after performing the operations described above_. **Example 1:** **Input:** s = iiii , k = 1 **Output:** 36 **Explanation:** The operations are as follows: Convert: iiii ➝ (9)(9)(9)(9) ➝ 9999 ➝ 9999 Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36 Thus the resulting integer is 36. **Example 2:** **Input:** s = leetcode , k = 2 **Output:** 6 **Explanation:** The operations are as follows: Convert: leetcode ➝ (12)(5)(5)(20)(3)(15)(4)(5) ➝ 12552031545 ➝ 12552031545 Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33 Transform #2: 33 ➝ 3 + 3 ➝ 6 Thus the resulting integer is 6. **Example 3:** **Input:** s = zbax , k = 2 **Output:** 8 **Constraints:** * `1 <= s.length <= 100` * `1 <= k <= 10` * `s` consists of lowercase English letters.","completion":"from collections import defaultdict def finding_users_active_minutes(logs, k): user_minutes = defaultdict(set) for log in logs: user_minutes[log[0]].add(log[1]) result = [0] * k for minutes in user_minutes.values(): if len(minutes) <= k: result[len(minutes) - 1] += 1 return result"},{"prompt":"You are given an undirected graph defined by an integer `n`, the number of nodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i] = [ui, vi]` indicates that there is an **undirected** edge between `ui` and `vi`. You are also given an integer array `queries`. Let `incident(a, b)` be defined as the **number of edges** that are connected to **either** node `a` or `b`. The answer to the `jth` query is the **number of pairs** of nodes `(a, b)` that satisfy **both** of the following conditions: * `a < b` * `incident(a, b) > queries[j]` Return _an array_ `answers` _such that_ `answers.length == queries.length` _and_ `answers[j]` _is the answer of the_ `jth` _query_. Note that there can be **multiple edges** between the same two nodes. **Example 1:** **Input:** n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3] **Output:** [6,5] **Explanation:** The calculations for incident(a, b) are shown in the table above. The answers for each of the queries are as follows: answers[0] = 6. All the pairs have an incident(a, b) value greater than 2. answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3. **Example 2:** **Input:** n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5] **Output:** [10,10,9,8,6] **Constraints:** * `2 <= n <= 2 * 104` * `1 <= edges.length <= 105` * `1 <= ui, vi <= n` * `ui != vi` * `1 <= queries.length <= 20` * `0 <= queries[j] < edges.length`","completion":"def get_smallest_string(n: int, k: int) -> str: result = [\'a\'] * n k -= n idx = n - 1 while k > 0: value = min(k, 25) result[idx] = chr(ord(result[idx]) + value) k -= value idx -= 1 return \'\'.join(result)"},{"prompt":"You are given an integer array `coins` (**1indexed**) of length `n` and an integer `maxJump`. You can jump to any index `i` of the array `coins` if `coins[i] != 1` and you have to pay `coins[i]` when you visit index `i`. In addition to that, if you are currently at index `i`, you can only jump to any index `i + k` where `i + k <= n` and `k` is a value in the range `[1, maxJump]`. You are initially positioned at index `1` (`coins[1]` is not `1`). You want to find the path that reaches index n with the minimum cost. Return an integer array of the indices that you will visit in order so that you can reach index n with the minimum cost. If there are multiple paths with the same cost, return the **lexicographically smallest** such path. If it is not possible to reach index n, return an empty array. A path `p1 = [Pa1, Pa2, ..., Pax]` of length `x` is **lexicographically smaller** than `p2 = [Pb1, Pb2, ..., Pbx]` of length `y`, if and only if at the first `j` where `Paj` and `Pbj` differ, `Paj < Pbj`; when no such `j` exists, then `x < y`. **Example 1:** **Input:** coins = [1,2,4,1,2], maxJump = 2 **Output:** [1,3,5] **Example 2:** **Input:** coins = [1,2,4,1,2], maxJump = 1 **Output:** [] **Constraints:** * `1 <= coins.length <= 1000` * `1 <= coins[i] <= 100` * `coins[1] != 1` * `1 <= maxJump <= 100`","completion":"def cheapestJump(coins, maxJump): n = len(coins) dp = [float(\'inf\')] * n parent = [-1] * n dp[0] = coins[0] for i in range(n): if coins[i] == -1: continue for j in range(1, maxJump + 1): if i + j >= n: break next = i + j cost = coins[next] + dp[i] if cost < dp[next]: dp[next] = cost parent[next] = i ans = [] if dp[n - 1] == float(\'inf\'): return ans cur = n - 1 while cur != -1: ans.append(cur + 1) cur = parent[cur] ans.reverse() return ans"},{"prompt":"You are given a **0indexed binary** string `floor`, which represents the colors of tiles on a floor: * `floor[i] = \'0\'` denotes that the `ith` tile of the floor is colored **black**. * On the other hand, `floor[i] = \'1\'` denotes that the `ith` tile of the floor is colored **white**. You are also given `numCarpets` and `carpetLen`. You have `numCarpets` **black** carpets, each of length `carpetLen` tiles. Cover the tiles with the given carpets such that the number of **white** tiles still visible is **minimum**. Carpets may overlap one another. Return _the **minimum** number of white tiles still visible._ **Example 1:** **Input:** floor = 10110101 , numCarpets = 2, carpetLen = 2 **Output:** 2 **Explanation:** The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible. No other way of covering the tiles with the carpets can leave less than 2 white tiles visible. **Example 2:** **Input:** floor = 11111 , numCarpets = 2, carpetLen = 3 **Output:** 0 **Explanation:** The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible. Note that the carpets are able to overlap one another. **Constraints:** * `1 <= carpetLen <= floor.length <= 1000` * `floor[i]` is either `\'0\'` or `\'1\'`. * `1 <= numCarpets <= 1000`","completion":"def minVisibleWhiteTiles(floor: str, numCarpets: int, carpetLen: int) -> int: n, res = len(floor), len(floor) for i in range(n - carpetLen + 1): count = sum(1 for j in range(carpetLen) if floor[i + j] == \'1\') for k in range(1, numCarpets + 1): if k * carpetLen - 1 <= i + carpetLen: res = min(res, n - count * k) if i + carpetLen < n: count -= floor[i + carpetLen - k * carpetLen] == \'1\' count += floor[i + carpetLen] == \'1\' return res"},{"prompt":"Given two integers `a` and `b`, return **any** string `s` such that: * `s` has length `a + b` and contains exactly `a` `\'a\'` letters, and exactly `b` `\'b\'` letters, * The substring `\'aaa\'` does not occur in `s`, and * The substring `\'bbb\'` does not occur in `s`. **Example 1:** **Input:** a = 1, b = 2 **Output:** abb **Explanation:** abb , bab and bba are all correct answers. **Example 2:** **Input:** a = 4, b = 1 **Output:** aabaa **Constraints:** * `0 <= a, b <= 100` * It is guaranteed such an `s` exists for the given `a` and `b`.","completion":"from collections import defaultdict def removeStones(stones): row_groups = defaultdict(int) col_groups = defaultdict(int) group_count = 0 groups = defaultdict(list) for x, y in stones: if x not in row_groups: row_groups[x] = group_count group_count += 1 if y + 10001 not in col_groups: # Offset by max row index col_groups[y + 10001] = group_count group_count += 1 group_x, group_y = row_groups[x], col_groups[y + 10001] groups[group_x].append(group_y) groups[group_y].append(group_x) visited = [False] * group_count def dfs(groupId): if visited[groupId]: return 0 visited[groupId] = True size = 1 for neighbor in groups[groupId]: size += dfs(neighbor) return size max_stones = 0 for groupId in range(group_count): max_stones += dfs(groupId) - 1 return max_stones"},{"prompt":"Given an array of integers `nums` and an integer `limit`, return the size of the longest **nonempty** subarray such that the absolute difference between any two elements of this subarray is less than or equal to `limit`_._ **Example 1:** **Input:** nums = [8,2,4,7], limit = 4 **Output:** 2 **Explanation:** All subarrays are: [8] with maximum absolute diff |88| = 0 <= 4. [8,2] with maximum absolute diff |82| = 6 > 4. [8,2,4] with maximum absolute diff |82| = 6 > 4. [8,2,4,7] with maximum absolute diff |82| = 6 > 4. [2] with maximum absolute diff |22| = 0 <= 4. [2,4] with maximum absolute diff |24| = 2 <= 4. [2,4,7] with maximum absolute diff |27| = 5 > 4. [4] with maximum absolute diff |44| = 0 <= 4. [4,7] with maximum absolute diff |47| = 3 <= 4. [7] with maximum absolute diff |77| = 0 <= 4. Therefore, the size of the longest subarray is 2. **Example 2:** **Input:** nums = [10,1,2,4,7,2], limit = 5 **Output:** 4 **Explanation:** The subarray [2,4,7,2] is the longest since the maximum absolute diff is |27| = 5 <= 5. **Example 3:** **Input:** nums = [4,2,2,2,4,4,2,2], limit = 0 **Output:** 3 **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109` * `0 <= limit <= 109`","completion":"from collections import deque def longestSubarray(nums, limit): max_deque = deque() min_deque = deque() left, right, longest = 0, 0, 0 while right < len(nums): while max_deque and nums[right] > max_deque[-1]: max_deque.pop() while min_deque and nums[right] < min_deque[-1]: min_deque.pop() max_deque.append(nums[right]) min_deque.append(nums[right]) while max_deque[0] - min_deque[0] > limit: if max_deque[0] == nums[left]: max_deque.popleft() if min_deque[0] == nums[left]: min_deque.popleft() left += 1 longest = max(longest, right - left + 1) right += 1 return longest"},{"prompt":"You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has `n` accounts numbered from `1` to `n`. The initial balance of each account is stored in a **0indexed** integer array `balance`, with the `(i + 1)th` account having an initial balance of `balance[i]`. Execute all the **valid** transactions. A transaction is **valid** if: * The given account number(s) are between `1` and `n`, and * The amount of money withdrawn or transferred from is **less than or equal** to the balance of the account. Implement the `Bank` class: * `Bank(long[] balance)` Initializes the object with the **0indexed** integer array `balance`. * `boolean transfer(int account1, int account2, long money)` Transfers `money` dollars from the account numbered `account1` to the account numbered `account2`. Return `true` if the transaction was successful, `false` otherwise. * `boolean deposit(int account, long money)` Deposit `money` dollars into the account numbered `account`. Return `true` if the transaction was successful, `false` otherwise. * `boolean withdraw(int account, long money)` Withdraw `money` dollars from the account numbered `account`. Return `true` if the transaction was successful, `false` otherwise. **Example 1:** **Input** [ Bank , withdraw , transfer , deposit , transfer , withdraw ] [[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]] **Output** [null, true, true, true, false, false] **Explanation** Bank bank = new Bank([10, 100, 20, 50, 30]); bank.withdraw(3, 10); // return true, account 3 has a balance of 20, so it is valid to withdraw 10. // Account 3 has 20 10 = 10. bank.transfer(5, 1, 20); // return true, account 5 has a balance of 30, so it is valid to transfer 20. // Account 5 has 30 20 = 10, and account 1 has 10 + 20 = 30. bank.deposit(5, 20); // return true, it is valid to deposit 20 to account 5. // Account 5 has 10 + 20 = 30. bank.transfer(3, 4, 15); // return false, the current balance of account 3 is 10, // so it is invalid to transfer 15 from it. bank.withdraw(10, 50); // return false, it is invalid because account 10 does not exist. **Constraints:** * `n == balance.length` * `1 <= n, account, account1, account2 <= 105` * `0 <= balance[i], money <= 1012` * At most `104` calls will be made to **each** function `transfer`, `deposit`, `withdraw`.","completion":"def rotateGrid(grid, k): def rotateLayer(layer, k): m, n = len(grid), len(grid[0]) top, bottom = layer, m - 1 - layer left, right = layer, n - 1 - layer data_in_layer = (right - left + 1) * 2 + (bottom - top - 1) * 2 k %= data_in_layer for _ in range(k): temp = grid[top][left] for j in range(left, right): grid[top][j] = grid[top][j + 1] for i in range(top, bottom): grid[i][right] = grid[i + 1][right] for j in range(right, left, -1): grid[bottom][j] = grid[bottom][j - 1] for i in range(bottom, top, -1): grid[i][left] = grid[i - 1][left] grid[top + 1][left] = temp m, n = len(grid), len(grid[0]) layers = min(m, n) // 2 for layer in range(layers): rotateLayer(layer, k) return grid"},{"prompt":"Given the binary representation of an integer as a string `s`, return _the number of steps to reduce it to_ `1` _under the following rules_: * If the current number is even, you have to divide it by `2`. * If the current number is odd, you have to add `1` to it. It is guaranteed that you can always reach one for all test cases. **Example 1:** **Input:** s = 1101 **Output:** 6 **Explanation:** 1101 corressponds to number 13 in their decimal representation. Step 1) 13 is odd, add 1 and obtain 14. Step 2) 14 is even, divide by 2 and obtain 7. Step 3) 7 is odd, add 1 and obtain 8. Step 4) 8 is even, divide by 2 and obtain 4. Step 5) 4 is even, divide by 2 and obtain 2. Step 6) 2 is even, divide by 2 and obtain 1. **Example 2:** **Input:** s = 10 **Output:** 1 **Explanation:** 10 corressponds to number 2 in their decimal representation. Step 1) 2 is even, divide by 2 and obtain 1. **Example 3:** **Input:** s = 1 **Output:** 0 **Constraints:** * `1 <= s.length <= 500` * `s` consists of characters \'0\' or \'1\' * `s[0] == \'1\'`","completion":"def num_steps(s: str) -> int: steps = 0 carry = 0 for c in reversed(s[1:]): bit = int(c) if bit and carry: carry = 1 steps += 2 elif bit or carry: carry ^= 1 steps += 2 else: steps += 1 return steps + carry"},{"prompt":"You are given an integer array `nums` and an array `queries` where `queries[i] = [vali, indexi]`. For each query `i`, first, apply `nums[indexi] = nums[indexi] + vali`, then print the sum of the even values of `nums`. Return _an integer array_ `answer` _where_ `answer[i]` _is the answer to the_ `ith` _query_. **Example 1:** **Input:** nums = [1,2,3,4], queries = [[1,0],[3,1],[4,0],[2,3]] **Output:** [8,6,2,4] **Explanation:** At the beginning, the array is [1,2,3,4]. After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8. After adding 3 to nums[1], the array is [2,1,3,4], and the sum of even values is 2 + 4 = 6. After adding 4 to nums[0], the array is [2,1,3,4], and the sum of even values is 2 + 4 = 2. After adding 2 to nums[3], the array is [2,1,3,6], and the sum of even values is 2 + 6 = 4. **Example 2:** **Input:** nums = [1], queries = [[4,0]] **Output:** [0] **Constraints:** * `1 <= nums.length <= 104` * `104 <= nums[i] <= 104` * `1 <= queries.length <= 104` * `104 <= vali <= 104` * `0 <= indexi < nums.length`","completion":"def bag_of_tokens_score(tokens, power): tokens.sort() max_score = score = 0 left, right = 0, len(tokens) - 1 while left <= right: if power >= tokens[left]: power -= tokens[left] left += 1 score += 1 max_score = max(max_score, score) elif score > 0: power += tokens[right] right -= 1 score -= 1 else: break return max_score"},{"prompt":"We have an array of integers, `nums`, and an array of `requests` where `requests[i] = [starti, endi]`. The `ith` request asks for the sum of `nums[starti] + nums[starti + 1] + ... + nums[endi 1] + nums[endi]`. Both `starti` and `endi` are _0indexed_. Return _the maximum total sum of all requests **among all permutations** of_ `nums`. Since the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** **Input:** nums = [1,2,3,4,5], requests = [[1,3],[0,1]] **Output:** 19 **Explanation:** One permutation of nums is [2,1,3,4,5] with the following result: requests[0] > nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8 requests[1] > nums[0] + nums[1] = 2 + 1 = 3 Total sum: 8 + 3 = 11. A permutation with a higher total sum is [3,5,4,2,1] with the following result: requests[0] > nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11 requests[1] > nums[0] + nums[1] = 3 + 5 = 8 Total sum: 11 + 8 = 19, which is the best that you can do. **Example 2:** **Input:** nums = [1,2,3,4,5,6], requests = [[0,1]] **Output:** 11 **Explanation:** A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11]. **Example 3:** **Input:** nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]] **Output:** 47 **Explanation:** A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10]. **Constraints:** * `n == nums.length` * `1 <= n <= 105` * `0 <= nums[i] <= 105` * `1 <= requests.length <= 105` * `requests[i].length == 2` * `0 <= starti <= endi < n`","completion":"def maxSumRangeQuery(nums, requests): n = len(nums) count = [0] * n for request in requests: count[request[0]] += 1 if request[1] + 1 < n: count[request[1] + 1] -= 1 for i in range(1, n): count[i] += count[i - 1] nums.sort() count.sort() ans = 0 for i in range(n): ans = (ans + nums[i] * count[i]) % 1000000007 return ans"},{"prompt":"Given two string arrays `words1` and `words2`, return _the number of strings that appear **exactly once** in **each** of the two arrays._ **Example 1:** **Input:** words1 = [ leetcode , is , amazing , as , is ], words2 = [ amazing , leetcode , is ] **Output:** 2 **Explanation:** leetcode appears exactly once in each of the two arrays. We count this string. amazing appears exactly once in each of the two arrays. We count this string. is appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string. as appears once in words1, but does not appear in words2. We do not count this string. Thus, there are 2 strings that appear exactly once in each of the two arrays. **Example 2:** **Input:** words1 = [ b , bb , bbb ], words2 = [ a , aa , aaa ] **Output:** 0 **Explanation:** There are no strings that appear in each of the two arrays. **Example 3:** **Input:** words1 = [ a , ab ], words2 = [ a , a , a , ab ] **Output:** 1 **Explanation:** The only string that appears exactly once in each of the two arrays is ab . **Constraints:** * `1 <= words1.length, words2.length <= 1000` * `1 <= words1[i].length, words2[j].length <= 30` * `words1[i]` and `words2[j]` consists only of lowercase English letters.","completion":"def rearrangeArray(nums): nums.sort() for i in range(1, len(nums) - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"prompt":"You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: `\'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'`. The wheels can rotate freely and wrap around: for example we can turn `\'9\'` to be `\'0\'`, or `\'0\'` to be `\'9\'`. Each move consists of turning one wheel one slot. The lock initially starts at `\'0000\'`, a string representing the state of the 4 wheels. You are given a list of `deadends` dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it. Given a `target` representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or 1 if it is impossible. **Example 1:** **Input:** deadends = [ 0201 , 0101 , 0102 , 1212 , 2002 ], target = 0202 **Output:** 6 **Explanation:** A sequence of valid moves would be 0000 > 1000 > 1100 > 1200 > 1201 > 1202 > 0202 . Note that a sequence like 0000 > 0001 > 0002 > 0102 > 0202 would be invalid, because the wheels of the lock become stuck after the display becomes the dead end 0102 . **Example 2:** **Input:** deadends = [ 8888 ], target = 0009 **Output:** 1 **Explanation:** We can turn the last wheel in reverse to move from 0000 > 0009 . **Example 3:** **Input:** deadends = [ 8887 , 8889 , 8878 , 8898 , 8788 , 8988 , 7888 , 9888 ], target = 8888 **Output:** 1 **Explanation:** We cannot reach the target without getting stuck. **Constraints:** * `1 <= deadends.length <= 500` * `deadends[i].length == 4` * `target.length == 4` * target **will not be** in the list `deadends`. * `target` and `deadends[i]` consist of digits only.","completion":"from collections import deque def openLock(deadends, target): dead = set(deadends) visited = set() q = deque([\\"0000\\"]) if \\"0000\\" in dead: return -1 visited.add(\\"0000\\") moves = 0 while q: level_size = len(q) for i in range(level_size): cur = q.popleft() if cur == target: return moves for j in range(4): for k in [-1, 1]: next_val = cur[:j] + str((int(cur[j]) + k + 10) % 10) + cur[j + 1:] if next_val not in visited and next_val not in dead: visited.add(next_val) q.append(next_val) moves += 1 return -1"},{"prompt":"Given a string `expression` representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an [irreducible fraction](https://en.wikipedia.org/wiki/Irreducible_fraction). If your final result is an integer, change it to the format of a fraction that has a denominator `1`. So in this case, `2` should be converted to `2/1`. **Example 1:** **Input:** expression = 1/2+1/2 **Output:** 0/1 **Example 2:** **Input:** expression = 1/2+1/2+1/3 **Output:** 1/3 **Example 3:** **Input:** expression = 1/31/2 **Output:** 1/6 **Constraints:** * The input string only contains `\'0\'` to `\'9\'`, `\'/\'`, `\'+\'` and `\'\'`. So does the output. * Each fraction (input and output) has the format `±numerator/denominator`. If the first input fraction or the output is positive, then `\'+\'` will be omitted. * The input only contains valid **irreducible fractions**, where the **numerator** and **denominator** of each fraction will always be in the range `[1, 10]`. If the denominator is `1`, it means this fraction is actually an integer in a fraction format defined above. * The number of given fractions will be in the range `[1, 10]`. * The numerator and denominator of the **final result** are guaranteed to be valid and in the range of **32bit** int.","completion":"from fractions import Fraction def fractionAddition(expression: str) -> str: fractions = expression.replace(\'+\', \' +\').replace(\'-\', \' -\').split() result = sum(Fraction(fraction) for fraction in fractions) return f\\"{result.numerator}/{result.denominator}\\""},{"prompt":"a warehouse, there is a row of barcodes, where the `ith` barcode is `barcodes[i]`. Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists. **Example 1:** **Input:** barcodes = [1,1,1,2,2,2] **Output:** [2,1,2,1,2,1] **Example 2:** **Input:** barcodes = [1,1,1,1,2,2,3,3] **Output:** [1,3,1,3,1,2,1,2] **Constraints:** * `1 <= barcodes.length <= 10000` * `1 <= barcodes[i] <= 10000`","completion":"def bitwise_complement(n): x = 1 while n > x: x = x * 2 + 1 return x - n"},{"prompt":"Given two integer arrays `arr1` and `arr2`, and the integer `d`, _return the distance value between the two arrays_. The distance value is defined as the number of elements `arr1[i]` such that there is not any element `arr2[j]` where `|arr1[i]arr2[j]| <= d`. **Example 1:** **Input:** arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 **Output:** 2 **Explanation:** For arr1[0]=4 we have: |410|=6 > d=2 |49|=5 > d=2 |41|=3 > d=2 |48|=4 > d=2 For arr1[1]=5 we have: |510|=5 > d=2 |59|=4 > d=2 |51|=4 > d=2 |58|=3 > d=2 For arr1[2]=8 we have: **|810|=2 <= d=2** **|89|=1 <= d=2** |81|=7 > d=2 **|88|=0 <= d=2** **Example 2:** **Input:** arr1 = [1,4,2,3], arr2 = [4,3,6,10,20,30], d = 3 **Output:** 2 **Example 3:** **Input:** arr1 = [2,1,100,3], arr2 = [5,2,10,3,7], d = 6 **Output:** 1 **Constraints:** * `1 <= arr1.length, arr2.length <= 500` * `1000 <= arr1[i], arr2[j] <= 1000` * `0 <= d <= 100`","completion":"def findTheDistanceValue(arr1, arr2, d): distance = 0 for a in arr1: found = True for b in arr2: if abs(a - b) <= d: found = False break if found: distance += 1 return distance"},{"prompt":"You are given a **0indexed** integer array `nums` of **even** length. As long as `nums` is **not** empty, you must repetitively: * Find the minimum number in `nums` and remove it. * Find the maximum number in `nums` and remove it. * Calculate the average of the two removed numbers. The **average** of two numbers `a` and `b` is `(a + b) / 2`. * For example, the average of `2` and `3` is `(2 + 3) / 2 = 2.5`. Return _the number of **distinct** averages calculated using the above process_. **Note** that when there is a tie for a minimum or maximum number, any can be removed. **Example 1:** **Input:** nums = [4,1,4,0,3,5] **Output:** 2 **Explanation:** 1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3]. 2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3]. 3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5. Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2. **Example 2:** **Input:** nums = [1,100] **Output:** 1 **Explanation:** There is only one average to be calculated after removing 1 and 100, so we return 1. **Constraints:** * `2 <= nums.length <= 100` * `nums.length` is even. * `0 <= nums[i] <= 100`","completion":"def distinctAverages(nums): averages = set() nums.sort() n = len(nums) for i in range(n // 2): averages.add((nums[i] + nums[n - 1 - i]) / 2.0) return len(averages)"},{"prompt":"A **good meal** is a meal that contains **exactly two different food items** with a sum of deliciousness equal to a power of two. You can pick **any** two different foods to make a good meal. Given an array of integers `deliciousness` where `deliciousness[i]` is the deliciousness of the `i​​​​​​th​​​​`​​​​ item of food, return _the number of different **good meals** you can make from this list modulo_ `109 + 7`. Note that items with different indices are considered different even if they have the same deliciousness value. **Example 1:** **Input:** deliciousness = [1,3,5,7,9] **Output:** 4 **Explanation:** The good meals are (1,3), (1,7), (3,5) and, (7,9). Their respective sums are 4, 8, 8, and 16, all of which are powers of 2. **Example 2:** **Input:** deliciousness = [1,1,1,3,3,3,7] **Output:** 15 **Explanation:** The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways. **Constraints:** * `1 <= deliciousness.length <= 105` * `0 <= deliciousness[i] <= 220`","completion":"def restoreMatrix(rowSum, colSum): m, n = len(rowSum), len(colSum) result = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): value = min(rowSum[i], colSum[j]) result[i][j] = value rowSum[i] -= value colSum[j] -= value return result"},{"prompt":"Given an integer array `arr` and an integer `k`, modify the array by repeating it `k` times. For example, if `arr = [1, 2]` and `k = 3` then the modified array will be `[1, 2, 1, 2, 1, 2]`. Return the maximum subarray sum in the modified array. Note that the length of the subarray can be `0` and its sum in that case is `0`. As the answer can be very large, return the answer **modulo** `109 + 7`. **Example 1:** **Input:** arr = [1,2], k = 3 **Output:** 9 **Example 2:** **Input:** arr = [1,2,1], k = 5 **Output:** 2 **Example 3:** **Input:** arr = [1,2], k = 7 **Output:** 0 **Constraints:** * `1 <= arr.length <= 105` * `1 <= k <= 105` * `104 <= arr[i] <= 104`","completion":"def kConcatenationMaxSum(arr, k): mod = 10**9 + 7 n = len(arr) max_sum, max_left, max_right = 0, 0, 0 total_sum = sum(arr) temp_sum = 0 for i in range(n): temp_sum += arr[i] max_sum = max(max_sum, temp_sum) temp_sum = max(0, temp_sum) max_left = max(max_left, temp_sum) temp = total_sum for i in range(n - 1, -1, -1): temp -= arr[i] max_right = max(max_right, temp) ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0) return ans % mod"},{"prompt":"An **image smoother** is a filter of the size `3 x 3` that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother). Given an `m x n` integer matrix `img` representing the grayscale of an image, return _the image after applying the smoother on each cell of it_. **Example 1:** **Input:** img = [[1,1,1],[1,0,1],[1,1,1]] **Output:** [[0,0,0],[0,0,0],[0,0,0]] **Explanation:** For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0 **Example 2:** **Input:** img = [[100,200,100],[200,50,200],[100,200,100]] **Output:** [[137,141,137],[141,138,141],[137,141,137]] **Explanation:** For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137 For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141 For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138 **Constraints:** * `m == img.length` * `n == img[i].length` * `1 <= m, n <= 200` * `0 <= img[i][j] <= 255`","completion":"def imageSmoother(img): m, n = len(img), len(img[0]) result = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): count, total = 0, 0 for x in range(i - 1, i + 2): for y in range(j - 1, j + 2): if 0 <= x < m and 0 <= y < n: total += img[x][y] count += 1 result[i][j] = total // count return result"},{"prompt":"Antitheft security devices are activated inside a bank. You are given a **0indexed** binary string array `bank` representing the floor plan of the bank, which is an `m x n` 2D matrix. `bank[i]` represents the `ith` row, consisting of `\'0\'`s and `\'1\'`s. `\'0\'` means the cell is empty, while`\'1\'` means the cell has a security device. There is **one** laser beam between any **two** security devices **if both** conditions are met: * The two devices are located on two **different rows**: `r1` and `r2`, where `r1 < r2`. * For **each** row `i` where `r1 < i < r2`, there are **no security devices** in the `ith` row. Laser beams are independent, i.e., one beam does not interfere nor join with another. Return _the total number of laser beams in the bank_. **Example 1:** **Input:** bank = [ 011001 , 000000 , 010100 , 001000 ] **Output:** 8 **Explanation:** Between each of the following device pairs, there is one beam. In total, there are 8 beams: * bank[0][1] bank[2][1] * bank[0][1] bank[2][3] * bank[0][2] bank[2][1] * bank[0][2] bank[2][3] * bank[0][5] bank[2][1] * bank[0][5] bank[2][3] * bank[2][1] bank[3][2] * bank[2][3] bank[3][2] Note that there is no beam between any device on the 0th row with any on the 3rd row. This is because the 2nd row contains security devices, which breaks the second condition. **Example 2:** **Input:** bank = [ 000 , 111 , 000 ] **Output:** 0 **Explanation:** There does not exist two devices located on two different rows. **Constraints:** * `m == bank.length` * `n == bank[i].length` * `1 <= m, n <= 500` * `bank[i][j]` is either `\'0\'` or `\'1\'`.","completion":"def can_sort_using_swap(nums): for i in range(1, len(nums)): if nums[i] < nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i] if sorted(nums) == nums: return True nums[i], nums[i - 1] = nums[i - 1], nums[i] return False"},{"prompt":"A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2DMap and wants to build the new center in a position such that **the sum of the euclidean distances to all customers is minimum**. Given an array `positions` where `positions[i] = [xi, yi]` is the position of the `ith` customer on the map, return _the minimum sum of the euclidean distances_ to all customers. In other words, you need to choose the position of the service center `[xcentre, ycentre]` such that the following formula is minimized: Answers within `105` of the actual value will be accepted. **Example 1:** **Input:** positions = [[0,1],[1,0],[1,2],[2,1]] **Output:** 4.00000 **Explanation:** As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve. **Example 2:** **Input:** positions = [[1,1],[3,3]] **Output:** 2.82843 **Explanation:** The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843 **Constraints:** * `1 <= positions.length <= 50` * `positions[i].length == 2` * `0 <= xi, yi <= 100` F(0) = 0, F(1) = 1, F(n) = F(n 1) + F(n 2) for n >= 2.","completion":"def find_min_fibonacci_numbers(k): if k == 0: return 0 a, b = 0, 1 while b <= k: a, b = b, a + b return 1 + find_min_fibonacci_numbers(k - a)"},{"prompt":"You are given an integer array `nums`. We call a subset of `nums` **good** if its product can be represented as a product of one or more **distinct prime** numbers. * For example, if `nums = [1, 2, 3, 4]`: * `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are **good** subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively. * `[1, 4]` and `[4]` are not **good** subsets with products `4 = 2*2` and `4 = 2*2` respectively. Return _the number of different **good** subsets in_ `nums` _**modulo**_ `109 + 7`. A **subset** of `nums` is any array that can be obtained by deleting some (possibly none or all) elements from `nums`. Two subsets are different if and only if the chosen indices to delete are different. **Example 1:** **Input:** nums = [1,2,3,4] **Output:** 6 **Explanation:** The good subsets are: [1,2]: product is 2, which is the product of distinct prime 2. [1,2,3]: product is 6, which is the product of distinct primes 2 and 3. [1,3]: product is 3, which is the product of distinct prime 3. [2]: product is 2, which is the product of distinct prime 2. [2,3]: product is 6, which is the product of distinct primes 2 and 3. [3]: product is 3, which is the product of distinct prime 3. **Example 2:** **Input:** nums = [4,2,3,15] **Output:** 5 **Explanation:** The good subsets are: [2]: product is 2, which is the product of distinct prime 2. [2,3]: product is 6, which is the product of distinct primes 2 and 3. [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5. [3]: product is 3, which is the product of distinct prime 3. [15]: product is 15, which is the product of distinct primes 3 and 5. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 30`","completion":"def min_swaps(s: str) -> int: zeros, ones = 0, 0 for c in s: if c == \'0\': zeros += 1 else: ones += 1 if abs(zeros - ones) > 1: return -1 mismatch_count1, mismatch_count2 = 0, 0 for i, c in enumerate(s): if i % 2 == 0: if c != \'0\': mismatch_count1 += 1 if c != \'1\': mismatch_count2 += 1 else: if c != \'1\': mismatch_count1 += 1 if c != \'0\': mismatch_count2 += 1 return min(mismatch_count1, mismatch_count2) // 2"},{"prompt":"Given an integer array `nums`, your goal is to make all elements in `nums` equal. To complete one operation, follow these steps: 1. Find the **largest** value in `nums`. Let its index be `i` (**0indexed**) and its value be `largest`. If there are multiple elements with the largest value, pick the smallest `i`. 2. Find the **next largest** value in `nums` **strictly smaller** than `largest`. Let its value be `nextLargest`. 3. Reduce `nums[i]` to `nextLargest`. Return _the number of operations to make all elements in_ `nums` _equal_. **Example 1:** **Input:** nums = [5,1,3] **Output:** 3 **Explanation:** It takes 3 operations to make all elements in nums equal: 1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3]. 2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3]. 3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1]. **Example 2:** **Input:** nums = [1,1,1] **Output:** 0 **Explanation:** All elements in nums are already equal. **Example 3:** **Input:** nums = [1,1,2,2,3] **Output:** 4 **Explanation:** It takes 4 operations to make all elements in nums equal: 1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2]. 2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2]. 3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2]. 4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1]. **Constraints:** * `1 <= nums.length <= 5 * 104` * `1 <= nums[i] <= 5 * 104`","completion":"from collections import defaultdict def min_trio_degree(n, edges): graph = defaultdict(dict) degree = [0] * (n + 1) for u, v in edges: graph[u][v] = graph[v][u] = True degree[u] += 1 degree[v] += 1 min_degree = float(\'inf\') for u, v in edges: for w in range(1, n + 1): if graph[u].get(w) and graph[v].get(w): min_degree = min(min_degree, degree[u] + degree[v] + degree[w] - 6) return min_degree if min_degree != float(\'inf\') else -1"},{"prompt":"Given two `n x n` binary matrices `mat` and `target`, return `true` _if it is possible to make_ `mat` _equal to_ `target` _by **rotating**_ `mat` _in **90degree increments**, or_ `false` _otherwise._ **Example 1:** **Input:** mat = [[0,1],[1,0]], target = [[1,0],[0,1]] **Output:** true **Explanation:** We can rotate mat 90 degrees clockwise to make mat equal target. **Example 2:** **Input:** mat = [[0,1],[1,1]], target = [[1,0],[0,1]] **Output:** false **Explanation:** It is impossible to make mat equal to target by rotating mat. **Example 3:** **Input:** mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]] **Output:** true **Explanation:** We can rotate mat 90 degrees clockwise two times to make mat equal target. **Constraints:** * `n == mat.length == target.length` * `n == mat[i].length == target[i].length` * `1 <= n <= 10` * `mat[i][j]` and `target[i][j]` are either `0` or `1`.","completion":"import heapq def minimumSize(nums, maxOperations): pq = [-num for num in nums] # Negative numbers to simulate max heap heapq.heapify(pq) while maxOperations > 0: maxBalls = -heapq.heappop(pq) heapq.heappush(pq, -maxBalls // 2) heapq.heappush(pq, -(maxBalls - (maxBalls // 2))) maxOperations -= 1 return -pq[0]"},{"prompt":"You are given a **0indexed** 2D integer array `transactions`, where `transactions[i] = [costi, cashbacki]`. The array describes transactions, where each transaction must be completed exactly once in **some order**. At any given moment, you have a certain amount of `money`. In order to complete transaction `i`, `money >= costi` must hold true. After performing a transaction, `money` becomes `money costi + cashbacki`. Return _the minimum amount of_ `money` _required before any transaction so that all of the transactions can be completed **regardless of the order** of the transactions._ **Example 1:** **Input:** transactions = [[2,1],[5,0],[4,2]] **Output:** 10 **Explanation:** Starting with money = 10, the transactions can be performed in any order. It can be shown that starting with money < 10 will fail to complete all transactions in some order. **Example 2:** **Input:** transactions = [[3,0],[0,3]] **Output:** 3 **Explanation:** If transactions are in the order [[3,0],[0,3]], the minimum money required to complete the transactions is 3. If transactions are in the order [[0,3],[3,0]], the minimum money required to complete the transactions is 0. Thus, starting with money = 3, the transactions can be performed in any order. **Constraints:** * `1 <= transactions.length <= 105` * `transactions[i].length == 2` * `0 <= costi, cashbacki <= 109`","completion":"def min_money(transactions): min_money_needed = 0 for transaction in transactions: min_money_needed = max(min_money_needed, transaction[0] - transaction[1]) return min_money_needed"},{"prompt":"You are given a **0indexed** **circular** string array `words` and a string `target`. A **circular array** means that the array\'s end connects to the array\'s beginning. * Formally, the next element of `words[i]` is `words[(i + 1) % n]` and the previous element of `words[i]` is `words[(i 1 + n) % n]`, where `n` is the length of `words`. Starting from `startIndex`, you can move to either the next word or the previous word with `1` step at a time. Return _the **shortest** distance needed to reach the string_ `target`. If the string `target` does not exist in `words`, return `1`. **Example 1:** **Input:** words = [ hello , i , am , leetcode , hello ], target = hello , startIndex = 1 **Output:** 1 **Explanation:** We start from index 1 and can reach hello by moving 3 units to the right to reach index 4. moving 2 units to the left to reach index 4. moving 4 units to the right to reach index 0. moving 1 unit to the left to reach index 0. The shortest distance to reach hello is 1. **Example 2:** **Input:** words = [ a , b , leetcode ], target = leetcode , startIndex = 0 **Output:** 1 **Explanation:** We start from index 0 and can reach leetcode by moving 2 units to the right to reach index 3. moving 1 unit to the left to reach index 3. The shortest distance to reach leetcode is 1. **Example 3:** **Input:** words = [ i , eat , leetcode ], target = ate , startIndex = 0 **Output:** 1 **Explanation:** Since ate does not exist in `words`, we return 1. **Constraints:** * `1 <= words.length <= 100` * `1 <= words[i].length <= 100` * `words[i]` and `target` consist of only lowercase English letters. * `0 <= startIndex < words.length`","completion":"def shortest_distance(words, target, startIndex): n = len(words) left, right, i = 0, 0, startIndex while True: if words[i] == target: return min(left, right) left += 1 right += 1 i = (i + 1) % n if left == n: break return -1"},{"prompt":"You have some number of sticks with positive integer lengths. These lengths are given as an array `sticks`, where `sticks[i]` is the length of the `ith` stick. You can connect any two sticks of lengths `x` and `y` into one stick by paying a cost of `x + y`. You must connect all the sticks until there is only one stick remaining. Return _the minimum cost of connecting all the given sticks into one stick in this way_. **Example 1:** **Input:** sticks = [2,4,3] **Output:** 14 **Explanation:** You start with sticks = [2,4,3]. 1. Combine sticks 2 and 3 for a cost of 2 + 3 = 5. Now you have sticks = [5,4]. 2. Combine sticks 5 and 4 for a cost of 5 + 4 = 9. Now you have sticks = [9]. There is only one stick left, so you are done. The total cost is 5 + 9 = 14. **Example 2:** **Input:** sticks = [1,8,3,5] **Output:** 30 **Explanation:** You start with sticks = [1,8,3,5]. 1. Combine sticks 1 and 3 for a cost of 1 + 3 = 4. Now you have sticks = [4,8,5]. 2. Combine sticks 4 and 5 for a cost of 4 + 5 = 9. Now you have sticks = [9,8]. 3. Combine sticks 9 and 8 for a cost of 9 + 8 = 17. Now you have sticks = [17]. There is only one stick left, so you are done. The total cost is 4 + 9 + 17 = 30. **Example 3:** **Input:** sticks = [5] **Output:** 0 **Explanation:** There is only one stick, so you don\'t need to do anything. The total cost is 0. **Constraints:** * `1 <= sticks.length <= 104` * `1 <= sticks[i] <= 104`","completion":"import heapq def connectSticks(sticks): heapq.heapify(sticks) cost = 0 while len(sticks) > 1: first = heapq.heappop(sticks) second = heapq.heappop(sticks) cost += first + second heapq.heappush(sticks, first + second) return cost"},{"prompt":"You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`. We want to place these books in order onto bookcase shelves that have a total width `shelfWidth`. We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place. Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books. * For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf. Return _the minimum possible height that the total bookshelf can be after placing shelves in this manner_. **Example 1:** **Input:** books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4 **Output:** 6 **Explanation:** The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6. Notice that book number 2 does not have to be on the first shelf. **Example 2:** **Input:** books = [[1,3],[2,4],[3,2]], shelfWidth = 6 **Output:** 4 **Constraints:** * `1 <= books.length <= 1000` * `1 <= thicknessi <= shelfWidth <= 1000` * `1 <= heighti <= 1000`","completion":"def max_uncrossed_lines(nums1, nums2): m, n = len(nums1), len(nums2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"prompt":"A **Bitset** is a data structure that compactly stores bits. Implement the `Bitset` class: * `Bitset(int size)` Initializes the Bitset with `size` bits, all of which are `0`. * `void fix(int idx)` Updates the value of the bit at the index `idx` to `1`. If the value was already `1`, no change occurs. * `void unfix(int idx)` Updates the value of the bit at the index `idx` to `0`. If the value was already `0`, no change occurs. * `void flip()` Flips the values of each bit in the Bitset. In other words, all bits with value `0` will now have value `1` and vice versa. * `boolean all()` Checks if the value of **each** bit in the Bitset is `1`. Returns `true` if it satisfies the condition, `false` otherwise. * `boolean one()` Checks if there is **at least one** bit in the Bitset with value `1`. Returns `true` if it satisfies the condition, `false` otherwise. * `int count()` Returns the **total number** of bits in the Bitset which have value `1`. * `String toString()` Returns the current composition of the Bitset. Note that in the resultant string, the character at the `ith` index should coincide with the value at the `ith` bit of the Bitset. **Example 1:** **Input** [ Bitset , fix , fix , flip , all , unfix , flip , one , unfix , count , toString ] [[5], [3], [1], [], [], [0], [], [], [0], [], []] **Output** [null, null, null, null, false, null, null, true, null, 2, 01010 ] **Explanation** Bitset bs = new Bitset(5); // bitset = 00000 . bs.fix(3); // the value at idx = 3 is updated to 1, so bitset = 00010 . bs.fix(1); // the value at idx = 1 is updated to 1, so bitset = 01010 . bs.flip(); // the value of each bit is flipped, so bitset = 10101 . bs.all(); // return False, as not all values of the bitset are 1. bs.unfix(0); // the value at idx = 0 is updated to 0, so bitset = 00101 . bs.flip(); // the value of each bit is flipped, so bitset = 11010 . bs.one(); // return True, as there is at least 1 index with value 1. bs.unfix(0); // the value at idx = 0 is updated to 0, so bitset = 01010 . bs.count(); // return 2, as there are 2 bits with value 1. bs.toString(); // return 01010 , which is the composition of bitset. **Constraints:** * `1 <= size <= 105` * `0 <= idx <= size 1` * At most `105` calls will be made **in total** to `fix`, `unfix`, `flip`, `all`, `one`, `count`, and `toString`. * At least one call will be made to `all`, `one`, `count`, or `toString`. * At most `5` calls will be made to `toString`.","completion":"def valid_move_combinations(pieces, positions): n = len(pieces) count = 0 for i in range(n): for j in range(n): if i != j and not (pieces[i] == \\"bishop\\" and (positions[i][0] + positions[i][1]) % 2 != (positions[j][0] + positions[j][1]) % 2): count += 1 return count"},{"prompt":"You are given an integer array `nums`. You must perform **exactly one** operation where you can **replace** one element `nums[i]` with `nums[i] * nums[i]`. Return _the **maximum** possible subarray sum after **exactly one** operation_. The subarray must be nonempty. **Example 1:** **Input:** nums = [2,1,4,3] **Output:** 17 **Explanation:** You can perform the operation on index 2 (0indexed) to make nums = [2,1,**16**,3]. Now, the maximum subarray sum is 2 + 1 + 16 = 17. **Example 2:** **Input:** nums = [1,1,1,1,1,1,1] **Output:** 4 **Explanation:** You can perform the operation on index 1 (0indexed) to make nums = [1,**1**,1,1,1,1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4. **Constraints:** * `1 <= nums.length <= 105` * `104 <= nums[i] <= 104`","completion":"def maxLengthBetweenEqualCharacters(s: str) -> int: max_length = -1 char_index_map = {} for i, char in enumerate(s): if char in char_index_map: max_length = max(max_length, i - char_index_map[char] - 1) else: char_index_map[char] = i return max_length"},{"prompt":"You are given an array of `n` strings `strs`, all of the same length. We may choose any deletion indices, and we delete all the characters in those indices for each string. For example, if we have `strs = [ abcdef , uvwxyz ]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[ bef , vyz ]`. Suppose we chose a set of deletion indices `answer` such that after deletions, the final array has **every string (row) in lexicographic** order. (i.e., `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length 1])`, and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length 1])`, and so on). Return _the minimum possible value of_ `answer.length`. **Example 1:** **Input:** strs = [ babca , bbazb ] **Output:** 3 **Explanation:** After deleting columns 0, 1, and 4, the final array is strs = [ bc , az ]. Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]). Note that strs[0] > strs[1] the array strs is not necessarily in lexicographic order. **Example 2:** **Input:** strs = [ edcba ] **Output:** 4 **Explanation:** If we delete less than 4 columns, the only row will not be lexicographically sorted. **Example 3:** **Input:** strs = [ ghi , def , abc ] **Output:** 0 **Explanation:** All rows are already lexicographically sorted. **Constraints:** * `n == strs.length` * `1 <= n <= 100` * `1 <= strs[i].length <= 100` * `strs[i]` consists of lowercase English letters.","completion":"from collections import deque def minMalwareSpread(graph, initial): n = len(graph) initial.sort() malware = set(initial) minNode = initial[0] minSpread = n + 1 for node in initial: q = deque(otherNode for otherNode in initial if node != otherNode) visited = [node != otherNode and otherNode in malware for otherNode in range(n)] while q: cur = q.popleft() for next, isConnected in enumerate(graph[cur]): if isConnected and not visited[next] and next not in malware: visited[next] = True q.append(next) spread = sum(visited) if spread < minSpread: minNode = node minSpread = spread return minNode"},{"prompt":"A **valueequal** string is a string where **all** characters are the same. * For example, `1111 ` and `33 ` are valueequal strings. * In contrast, `123 ` is not a valueequal string. Given a digit string `s`, decompose the string into some number of **consecutive valueequal** substrings where **exactly one** substring has a **length of** `2` and the remaining substrings have a **length of** `3`. Return `true` _if you can decompose_ `s` _according to the above rules. Otherwise, return_ `false`. A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** s = 000111000 **Output:** false **Explanation:** s cannot be decomposed according to the rules because [ 000 , 111 , 000 ] does not have a substring of length 2. **Example 2:** **Input:** s = 00011111222 **Output:** true **Explanation:** s can be decomposed into [ 000 , 111 , 11 , 222 ]. **Example 3:** **Input:** s = 011100022233 **Output:** false **Explanation:** s cannot be decomposed according to the rules because of the first \'0\'. **Constraints:** * `1 <= s.length <= 1000` * `s` consists of only digits `\'0\'` through `\'9\'`.","completion":"def num_different_integers(word): for c in word: if not c.isdigit(): word = word.replace(c, \' \') nums = word.split() unique_nums = set() for num in nums: num = num.lstrip(\'0\') or \'0\' unique_nums.add(num) return len(unique_nums)"},{"prompt":"There is a 2D `grid` of size `n x n` where each cell of this grid has a lamp that is initially **turned off**. You are given a 2D array of lamp positions `lamps`, where `lamps[i] = [rowi, coli]` indicates that the lamp at `grid[rowi][coli]` is **turned on**. Even if the same lamp is listed more than once, it is turned on. When a lamp is turned on, it **illuminates its cell** and **all other cells** in the same **row, column, or diagonal**. You are also given another 2D array `queries`, where `queries[j] = [rowj, colj]`. For the `jth` query, determine whether `grid[rowj][colj]` is illuminated or not. After answering the `jth` query, **turn off** the lamp at `grid[rowj][colj]` and its **8 adjacent lamps** if they exist. A lamp is adjacent if its cell shares either a side or corner with `grid[rowj][colj]`. Return _an array of integers_ `ans`_,_ _where_ `ans[j]` _should be_ `1` _if the cell in the_ `jth` _query was illuminated, or_ `0` _if the lamp was not._ **Example 1:** **Input:** n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]] **Output:** [1,0] **Explanation:** We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4]. The 0th query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square. The 1st query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle. **Example 2:** **Input:** n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]] **Output:** [1,1] **Example 3:** **Input:** n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]] **Output:** [1,1,0] **Constraints:** * `1 <= n <= 109` * `0 <= lamps.length <= 20000` * `0 <= queries.length <= 20000` * `lamps[i].length == 2` * `0 <= rowi, coli < n` * `queries[j].length == 2` * `0 <= rowj, colj < n`","completion":"def repeatedNTimes(nums): hash_map = {} for num in nums: if num in hash_map: return num else: hash_map[num] = 1"},{"prompt":"You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts. You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you **do not** have to have all the people living in the grid. The **happiness** of each person is calculated as follows: * Introverts **start** with `120` happiness and **lose** `30` happiness for each neighbor (introvert or extrovert). * Extroverts **start** with `40` happiness and **gain** `20` happiness for each neighbor (introvert or extrovert). Neighbors live in the directly adjacent cells north, east, south, and west of a person\'s cell. The **grid happiness** is the **sum** of each person\'s happiness. Return _the **maximum possible grid happiness**._ **Example 1:** **Input:** m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2 **Output:** 240 **Explanation:** Assume the grid is 1indexed with coordinates (row, column). We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3). Introvert at (1,1) happiness: 120 (starting happiness) (0 * 30) (0 neighbors) = 120 Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60 Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60 The grid happiness is 120 + 60 + 60 = 240. The above figure shows the grid in this example with each person\'s happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells. **Example 2:** **Input:** m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1 **Output:** 260 **Explanation:** Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1). Introvert at (1,1) happiness: 120 (starting happiness) (1 * 30) (1 neighbor) = 90 Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80 Introvert at (3,1) happiness: 120 (starting happiness) (1 * 30) (1 neighbor) = 90 The grid happiness is 90 + 80 + 90 = 260. **Example 3:** **Input:** m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0 **Output:** 240 **Constraints:** * `1 <= m, n <= 5` * `0 <= introvertsCount, extrovertsCount <= min(m * n, 6)`","completion":"def maxSum(nums1, nums2): mod = 10**9 + 7 m, n = len(nums1), len(nums2) dp1, dp2 = [0] * (m + 1), [0] * (n + 1) i, j = m - 1, n - 1 while i >= 0 or j >= 0: a = dp1[i] + nums1[i] if i >= 0 else float(\'-inf\') b = dp2[j] + nums2[j] if j >= 0 else float(\'-inf\') seen = set() if a > b: dp1[i] = a % mod i -= 1 seen.add(nums1[i + 1]) else: dp2[j] = b % mod j -= 1 seen.add(nums2[j + 1]) return max(dp1[0], dp2[0]) % mod"},{"prompt":"Given a string `s` and an array of strings `words`, return _the number of_ `words[i]` _that is a subsequence of_ `s`. A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. * For example, `ace ` is a subsequence of `abcde `. **Example 1:** **Input:** s = abcde , words = [ a , bb , acd , ace ] **Output:** 3 **Explanation:** There are three strings in words that are a subsequence of s: a , acd , ace . **Example 2:** **Input:** s = dsahjpjauf , words = [ ahjpjau , ja , ahbwzgqnuk , tnmlanowax ] **Output:** 2 **Constraints:** * `1 <= s.length <= 5 * 104` * `1 <= words.length <= 5000` * `1 <= words[i].length <= 50` * `s` and `words[i]` consist of only lowercase English letters.","completion":"def search(nums, target): left = 0 right = len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"prompt":"Given an array `arr` of 4 digits, find the latest 24hour time that can be made using each digit **exactly once**. 24hour times are formatted as `HH:MM `, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24hour time is `00:00`, and the latest is `23:59`. Return _the latest 24hour time in `HH:MM ` format_. If no valid time can be made, return an empty string. **Example 1:** **Input:** arr = [1,2,3,4] **Output:** 23:41 **Explanation:** The valid 24hour times are 12:34 , 12:43 , 13:24 , 13:42 , 14:23 , 14:32 , 21:34 , 21:43 , 23:14 , and 23:41 . Of these times, 23:41 is the latest. **Example 2:** **Input:** arr = [5,5,5,5] **Output:** **Explanation:** There are no valid 24hour times as 55:55 is not valid. **Constraints:** * `arr.length == 4` * `0 <= arr[i] <= 9`","completion":"from collections import deque def catMouseGame(graph): n = len(graph) status = [[[0]*3 for _ in range(n)] for _ in range(n)] for i in range(1, n): status[i][i][1] = 2 status[i][i][2] = 2 queue = deque([(i, i, t, 2) for i in range(1, n) for t in (1, 2)]) while queue: pos_m, pos_c, t_type, t_result = queue.popleft() for prev in graph[pos_m if t_type == 1 else pos_c]: if (t_type == 2 and prev == 0) or (t_result == 2 and status[prev][pos_c][3 - t_type]): continue if status[prev][pos_c][3 - t_type]: continue queue.append((pos_c, prev, 3 - t_type, 3 - t_result)) status[prev][pos_c][3 - t_type] = 3 - t_result return status[1][2][1]"},{"prompt":"You are given a positive integer `primeFactors`. You are asked to construct a positive integer `n` that satisfies the following conditions: * The number of prime factors of `n` (not necessarily distinct) is **at most** `primeFactors`. * The number of nice divisors of `n` is maximized. Note that a divisor of `n` is **nice** if it is divisible by every prime factor of `n`. For example, if `n = 12`, then its prime factors are `[2,2,3]`, then `6` and `12` are nice divisors, while `3` and `4` are not. Return _the number of nice divisors of_ `n`. Since that number can be too large, return it **modulo** `109 + 7`. Note that a prime number is a natural number greater than `1` that is not a product of two smaller natural numbers. The prime factors of a number `n` is a list of prime numbers such that their product equals `n`. **Example 1:** **Input:** primeFactors = 5 **Output:** 6 **Explanation:** 200 is a valid value of n. It has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200]. There is not other value of n that has at most 5 prime factors and more nice divisors. **Example 2:** **Input:** primeFactors = 8 **Output:** 18 **Constraints:** * `1 <= primeFactors <= 109`","completion":"def stoneGame(stones): n = len(stones) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): for j in range(i + 1, n): dp[i][j] = max(stones[j] - dp[i][j - 1], stones[i] - dp[i + 1][j]) return dp[0][n - 1]"},{"prompt":"Given a 2D `grid` of `0`s and `1`s, return the number of elements in the largest **square** subgrid that has all `1`s on its **border**, or `0` if such a subgrid doesn\'t exist in the `grid`. **Example 1:** **Input:** grid = [[1,1,1],[1,0,1],[1,1,1]] **Output:** 9 **Example 2:** **Input:** grid = [[1,1,0,0]] **Output:** 1 **Constraints:** * `1 <= grid.length <= 100` * `1 <= grid[0].length <= 100` * `grid[i][j]` is `0` or `1`","completion":"def prev_perm_opt1(arr): n = len(arr) for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: j = i + 1 while j < n and arr[j] < arr[i]: j += 1 arr[i], arr[j - 1] = arr[j - 1], arr[i] return arr return arr"},{"prompt":"You are given two integer arrays `nums1` and `nums2` where `nums2` is **an anagram** of `nums1`. Both arrays may contain duplicates. Return _an index mapping array_ `mapping` _from_ `nums1` _to_ `nums2` _where_ `mapping[i] = j` _means the_ `ith` _element in_ `nums1` _appears in_ `nums2` _at index_ `j`. If there are multiple answers, return **any of them**. An array `a` is **an anagram** of an array `b` means `b` is made by randomizing the order of the elements in `a`. **Example 1:** **Input:** nums1 = [12,28,46,32,50], nums2 = [50,12,32,46,28] **Output:** [1,4,3,2,0] **Explanation:** As mapping[0] = 1 because the 0th element of nums1 appears at nums2[1], and mapping[1] = 4 because the 1st element of nums1 appears at nums2[4], and so on. **Example 2:** **Input:** nums1 = [84,46], nums2 = [84,46] **Output:** [0,1] **Constraints:** * `1 <= nums1.length <= 100` * `nums2.length == nums1.length` * `0 <= nums1[i], nums2[i] <= 105` * `nums2` is an anagram of `nums1`.","completion":"def anagramMappings(nums1, nums2): num_map = {num: i for i, num in enumerate(nums2)} mapping = [num_map[num] for num in nums1] return mapping"},{"prompt":"You are given a phone number as a string `number`. `number` consists of digits, spaces `\' \'`, and/or dashes `\'\'`. You would like to reformat the phone number in a certain manner. Firstly, **remove** all spaces and dashes. Then, **group** the digits from left to right into blocks of length 3 **until** there are 4 or fewer digits. The final digits are then grouped as follows: * 2 digits: A single block of length 2. * 3 digits: A single block of length 3. * 4 digits: Two blocks of length 2 each. The blocks are then joined by dashes. Notice that the reformatting process should **never** produce any blocks of length 1 and produce **at most** two blocks of length 2. Return _the phone number after formatting._ **Example 1:** **Input:** number = 12345 6 **Output:** 123456 **Explanation:** The digits are 123456 . Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is 123 . Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is 456 . Joining the blocks gives 123456 . **Example 2:** **Input:** number = 123 4567 **Output:** 1234567 **Explanation:** The digits are 1234567 . Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is 123 . Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are 45 and 67 . Joining the blocks gives 1234567 . **Example 3:** **Input:** number = 123 45678 **Output:** 12345678 **Explanation:** The digits are 12345678 . Step 1: The 1st block is 123 . Step 2: The 2nd block is 456 . Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is 78 . Joining the blocks gives 12345678 . **Constraints:** * `2 <= number.length <= 100` * `number` consists of digits and the characters `\'\'` and `\' \'`. * There are at least **two** digits in `number`.","completion":"def min_subarray(nums, p): n = len(nums) need, cur, res = 0, 0, n last_seen = {} for num in nums: need = (need + num) % p if need == 0: return 0 last_seen[cur] = -1 for i, num in enumerate(nums): cur = (cur + num) % p last_seen[cur] = i want = (cur - need + p) % p if want in last_seen: res = min(res, i - last_seen[want]) return res if res != n else -1"},{"prompt":"You are given a **0indexed** array of positive integers `nums`. A triplet of three **distinct** indices `(i, j, k)` is called a **single divisor triplet** of `nums` if `nums[i] + nums[j] + nums[k]` is divisible by **exactly one** of `nums[i]`, `nums[j]`, or `nums[k]`. Return _the number of **single divisor triplets** of_ `nums`_._ **Example 1:** **Input:** nums = [4,6,7,3,2] **Output:** 12 **Explanation:** The triplets (0, 3, 4), (0, 4, 3), (3, 0, 4), (3, 4, 0), (4, 0, 3), and (4, 3, 0) have the values of [4, 3, 2] (or a permutation of [4, 3, 2]). 4 + 3 + 2 = 9 which is only divisible by 3, so all such triplets are single divisor triplets. The triplets (0, 2, 3), (0, 3, 2), (2, 0, 3), (2, 3, 0), (3, 0, 2), and (3, 2, 0) have the values of [4, 7, 3] (or a permutation of [4, 7, 3]). 4 + 7 + 3 = 14 which is only divisible by 7, so all such triplets are single divisor triplets. There are 12 single divisor triplets in total. **Example 2:** **Input:** nums = [1,2,2] **Output:** 6 **Explanation:** The triplets (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), and (2, 1, 0) have the values of [1, 2, 2] (or a permutation of [1, 2, 2]). 1 + 2 + 2 = 5 which is only divisible by 1, so all such triplets are single divisor triplets. There are 6 single divisor triplets in total. **Example 3:** **Input:** nums = [1,1,1] **Output:** 0 **Explanation:** There are no single divisor triplets. Note that (0, 1, 2) is not a single divisor triplet because nums[0] + nums[1] + nums[2] = 3 and 3 is divisible by nums[0], nums[1], and nums[2]. **Constraints:** * `3 <= nums.length <= 105` * `1 <= nums[i] <= 100`","completion":"from collections import defaultdict def check_friends(n, restrictions, requests): friends = defaultdict(set) for a, b in restrictions: friends[a].add(b) friends[b].add(a) result = [] for a, b in requests: if b not in friends[a] and a not in friends[b]: friends[a].add(b) friends[b].add(a) result.append(True) else: result.append(False) return result"},{"prompt":"You are given an array of strings `equations` that represent relationships between variables where each string `equations[i]` is of length `4` and takes one of two different forms: `xi==yi ` or `xi!=yi `.Here, `xi` and `yi` are lowercase letters (not necessarily different) that represent oneletter variable names. Return `true` _if it is possible to assign integers to variable names so as to satisfy all the given equations, or_ `false` _otherwise_. **Example 1:** **Input:** equations = [ a==b , b!=a ] **Output:** false **Explanation:** If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations. **Example 2:** **Input:** equations = [ b==a , a==b ] **Output:** true **Explanation:** We could assign a = 1 and b = 1 to satisfy both equations. **Constraints:** * `1 <= equations.length <= 500` * `equations[i].length == 4` * `equations[i][0]` is a lowercase letter. * `equations[i][1]` is either `\'=\'` or `\'!\'`. * `equations[i][2]` is `\'=\'`. * `equations[i][3]` is a lowercase letter.","completion":"def is_alien_sorted(words, order): alien_order = {char: i for i, char in enumerate(order)} for i in range(1, len(words)): for j in range(len(words[i - 1])): if j == len(words[i]): return False if words[i - 1][j] != words[i][j]: if alien_order[words[i - 1][j]] > alien_order[words[i][j]]: return False break return True"},{"prompt":"Given a **0indexed** integer array `nums` of size `n`, find the **maximum difference** between `nums[i]` and `nums[j]` (i.e., `nums[j] nums[i]`), such that `0 <= i < j < n` and `nums[i] < nums[j]`. Return _the **maximum difference**._ If no such `i` and `j` exists, return `1`. **Example 1:** **Input:** nums = [7,**1**,**5**,4] **Output:** 4 **Explanation:** The maximum difference occurs with i = 1 and j = 2, nums[j] nums[i] = 5 1 = 4. Note that with i = 1 and j = 0, the difference nums[j] nums[i] = 7 1 = 6, but i > j, so it is not valid. **Example 2:** **Input:** nums = [9,4,3,2] **Output:** 1 **Explanation:** There is no i and j such that i < j and nums[i] < nums[j]. **Example 3:** **Input:** nums = [**1**,5,2,**10**] **Output:** 9 **Explanation:** The maximum difference occurs with i = 0 and j = 3, nums[j] nums[i] = 10 1 = 9. **Constraints:** * `n == nums.length` * `2 <= n <= 1000` * `1 <= nums[i] <= 109`","completion":"def min_steps_to_equal_elements(nums): min_elem = min(nums) steps = 0 for num in nums: steps += (num - min_elem) return steps"},{"prompt":"Alice is texting Bob using her phone. The **mapping** of digits to letters is shown in the figure below. In order to **add** a letter, Alice has to **press** the key of the corresponding digit `i` times, where `i` is the position of the letter in the key. * For example, to add the letter `\'s\'`, Alice has to press `\'7\'` four times. Similarly, to add the letter `\'k\'`, Alice has to press `\'5\'` twice. * Note that the digits `\'0\'` and `\'1\'` do not map to any letters, so Alice **does not** use them. However, due to an error in transmission, Bob did not receive Alice\'s text message but received a **string of pressed keys** instead. * For example, when Alice sent the message `bob `, Bob received the string `2266622 `. Given a string `pressedKeys` representing the string received by Bob, return _the **total number of possible text messages** Alice could have sent_. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** pressedKeys = 22233 **Output:** 8 **Explanation:** The possible text messages Alice could have sent are: aaadd , abdd , badd , cdd , aaae , abe , bae , and ce . Since there are 8 possible messages, we return 8. **Example 2:** **Input:** pressedKeys = 222222222222222222222222222222222222 **Output:** 82876089 **Explanation:** There are 2082876103 possible text messages Alice could have sent. Since we need to return the answer modulo 109 + 7, we return 2082876103 % (109 + 7) = 82876089. **Constraints:** * `1 <= pressedKeys.length <= 105` * `pressedKeys` only consists of digits from `\'2\'` `\'9\'`.","completion":"def min_cost(startAt, moveCost, pushCost, targetSeconds): min_cost = float(\'inf\') for i in range(100): for j in range(100): if i * 60 + j == targetSeconds: minute_move_cost = abs(i - startAt) * moveCost second_move_cost = abs(j - i) * moveCost total_push_cost = (2 if j > 0 else 0) + (1 if j // 10 != 0 else 0) + (1 if i // 10 != 0 else 0) min_cost = min(min_cost, minute_move_cost + second_move_cost + total_push_cost * pushCost) return min_cost"},{"prompt":"Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `\'A\'` (an apple) and `\'.\'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k1` cuts. For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person. _Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7. **Example 1:** **Input:** pizza = [ A.. , AAA , ... ], k = 3 **Output:** 3 **Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple. **Example 2:** **Input:** pizza = [ A.. , AA. , ... ], k = 3 **Output:** 1 **Example 3:** **Input:** pizza = [ A.. , A.. , ... ], k = 1 **Output:** 1 **Constraints:** * `1 <= rows, cols <= 50` * `rows == pizza.length` * `cols == pizza[i].length` * `1 <= k <= 10` * `pizza` consists of characters `\'A\'` and `\'.\'` only.","completion":"def number_of_steps(num): steps = 0 while num: steps += 1 if num % 2 == 0 else 2 num >>= 1 return steps - 1"},{"prompt":"You have `n` boxes. You are given a binary string `boxes` of length `n`, where `boxes[i]` is `\'0\'` if the `ith` box is **empty**, and `\'1\'` if it contains **one** ball. In one operation, you can move **one** ball from a box to an adjacent box. Box `i` is adjacent to box `j` if `abs(i j) == 1`. Note that after doing so, there may be more than one ball in some boxes. Return an array `answer` of size `n`, where `answer[i]` is the **minimum** number of operations needed to move all the balls to the `ith` box. Each `answer[i]` is calculated considering the **initial** state of the boxes. **Example 1:** **Input:** boxes = 110 **Output:** [1,1,3] **Explanation:** The answer for each box is as follows: 1) First box: you will have to move one ball from the second box to the first box in one operation. 2) Second box: you will have to move one ball from the first box to the second box in one operation. 3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation. **Example 2:** **Input:** boxes = 001011 **Output:** [11,8,5,4,3,4] **Constraints:** * `n == boxes.length` * `1 <= n <= 2000` * `boxes[i]` is either `\'0\'` or `\'1\'`.","completion":"def maximum_generated(n: int) -> int: if n == 0: return 0 nums = [0] * (n + 1) nums[1] = 1 for i in range(2, n + 1): nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1] return max(nums)"},{"prompt":"You are given an integer array `arr`. In one move, you can select a **palindromic** subarray `arr[i], arr[i + 1], ..., arr[j]` where `i <= j`, and remove that subarray from the given array. Note that after removing a subarray, the elements on the left and on the right of that subarray move to fill the gap left by the removal. Return _the minimum number of moves needed to remove all numbers from the array_. **Example 1:** **Input:** arr = [1,2] **Output:** 2 **Example 2:** **Input:** arr = [1,3,4,1,5] **Output:** 3 **Explanation:** Remove [4] then remove [1,3,1] then remove [5]. **Constraints:** * `1 <= arr.length <= 100` * `1 <= arr[i] <= 20`","completion":"def minimumMoves(arr): def minRemovals(i, j): if i > j: return 0 if i == j: return 1 if dp[i][j] != -1: return dp[i][j] ans = minRemovals(i + 1, j) + 1 for k in range(i + 1, j + 1): if arr[i] == arr[k]: ans = min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j)) dp[i][j] = ans return ans dp = [[-1] * len(arr) for _ in range(len(arr))] return minRemovals(0, len(arr) - 1)"},{"prompt":"You are given the `head` of a linked list, which contains a series of integers **separated** by `0`\'s. The **beginning** and **end** of the linked list will have `Node.val == 0`. For **every** two consecutive `0`\'s, **merge** all the nodes lying in between them into a single node whose value is the **sum** of all the merged nodes. The modified list should not contain any `0`\'s. Return _the_ `head` _of the modified linked list_. **Example 1:** **Input:** head = [0,3,1,0,4,5,2,0] **Output:** [4,11] **Explanation:** The above figure represents the given linked list. The modified list contains The sum of the nodes marked in green: 3 + 1 = 4. The sum of the nodes marked in red: 4 + 5 + 2 = 11. **Example 2:** **Input:** head = [0,1,0,3,0,2,2,0] **Output:** [1,3,4] **Explanation:** The above figure represents the given linked list. The modified list contains The sum of the nodes marked in green: 1 = 1. The sum of the nodes marked in red: 3 = 3. The sum of the nodes marked in yellow: 2 + 2 = 4. **Constraints:** * The number of nodes in the list is in the range `[3, 2 * 105]`. * `0 <= Node.val <= 1000` * There are **no** two consecutive nodes with `Node.val == 0`. * The **beginning** and **end** of the linked list have `Node.val == 0`.","completion":"def smallest_index(nums): for i in range(len(nums)): if i % 10 == nums[i]: return i return -1"},{"prompt":"You are given a **0indexed** string `pattern` of length `n` consisting of the characters `\'I\'` meaning **increasing** and `\'D\'` meaning **decreasing**. A **0indexed** string `num` of length `n + 1` is created using the following conditions: * `num` consists of the digits `\'1\'` to `\'9\'`, where each digit is used **at most** once. * If `pattern[i] == \'I\'`, then `num[i] < num[i + 1]`. * If `pattern[i] == \'D\'`, then `num[i] > num[i + 1]`. Return _the lexicographically **smallest** possible string_ `num` _that meets the conditions._ **Example 1:** **Input:** pattern = IIIDIDDD **Output:** 123549876 **Explanation:** At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1]. At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1]. Some possible values of num are 245639871 , 135749862 , and 123849765 . It can be proven that 123549876 is the smallest possible num that meets the conditions. Note that 123414321 is not possible because the digit \'1\' is used more than once. **Example 2:** **Input:** pattern = DDD **Output:** 4321 **Explanation:** Some possible values of num are 9876 , 7321 , and 8742 . It can be proven that 4321 is the smallest possible num that meets the conditions. **Constraints:** * `1 <= pattern.length <= 8` * `pattern` consists of only the letters `\'I\'` and `\'D\'`.","completion":"def findSmallestNum(pattern: str) -> str: num = \\"123456789\\" i = 0 while i < len(pattern): if pattern[i] == \'D\': j = i while j < len(pattern) and pattern[j] == \'D\': j += 1 num = num[:i] + num[i:j+1][::-1] + num[j+1:] i = j else: i += 1 return num[:len(pattern) + 1]"},{"prompt":"You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes: * You can place the boxes anywhere on the floor. * If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` **must** either be adjacent to another box or to a wall. Given an integer `n`, return _the **minimum** possible number of boxes touching the floor._ **Example 1:** **Input:** n = 3 **Output:** 3 **Explanation:** The figure above is for the placement of the three boxes. These boxes are placed in the corner of the room, where the corner is on the left side. **Example 2:** **Input:** n = 4 **Output:** 3 **Explanation:** The figure above is for the placement of the four boxes. These boxes are placed in the corner of the room, where the corner is on the left side. **Example 3:** **Input:** n = 10 **Output:** 6 **Explanation:** The figure above is for the placement of the ten boxes. These boxes are placed in the corner of the room, where the corner is on the back side. **Constraints:** * `1 <= n <= 109`","completion":"def check_palindrome_formation(a: str, b: str) -> bool: def is_palindrome(s: str, left: int, right: int) -> bool: while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True i, j = 0, len(a) - 1 while i < j: if a[i] != b[j]: return is_palindrome(a, i, j) or is_palindrome(b, i, j) i += 1 j -= 1 return True"},{"prompt":"There exists an infinitely large twodimensional grid of uncolored unit cells. You are given a positive integer `n`, indicating that you must do the following routine for `n` minutes: * At the first minute, color **any** arbitrary unit cell blue. * Every minute thereafter, color blue **every** uncolored cell that touches a blue cell. Below is a pictorial representation of the state of the grid after minutes 1, 2, and 3. Return _the number of **colored cells** at the end of_ `n` _minutes_. **Example 1:** **Input:** n = 1 **Output:** 1 **Explanation:** After 1 minute, there is only 1 blue cell, so we return 1. **Example 2:** **Input:** n = 2 **Output:** 5 **Explanation:** After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5. **Constraints:** * `1 <= n <= 105`","completion":"def number_of_colored_cells(n): return n * n + (n - 1) * (n - 1)"},{"prompt":"You are given a **directed** graph of `n` nodes numbered from `0` to `n 1`, where each node has **at most one** outgoing edge. The graph is represented with a given **0indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == 1`. Return _the length of the **longest** cycle in the graph_. If no cycle exists, return `1`. A cycle is a path that starts and ends at the **same** node. **Example 1:** **Input:** edges = [3,3,4,2,3] **Output:** 3 **Explanation:** The longest cycle in the graph is the cycle: 2 > 4 > 3 > 2. The length of this cycle is 3, so 3 is returned. **Example 2:** **Input:** edges = [2,1,3,1] **Output:** 1 **Explanation:** There are no cycles in this graph. **Constraints:** * `n == edges.length` * `2 <= n <= 105` * `1 <= edges[i] < n` * `edges[i] != i`","completion":"def findLongestCycle(edges): n = len(edges) visited = [False] * n longest_cycle = -1 for i in range(n): if not visited[i]: length = 0 node = i while not visited[node] and edges[node] != -1: visited[node] = True length += 1 node = edges[node] if edges[node] == i: longest_cycle = max(longest_cycle, length) return longest_cycle"},{"prompt":"Given two strings `word1` and `word2`, return _the minimum number of **steps** required to make_ `word1` _and_ `word2` _the same_. In one **step**, you can delete exactly one character in either string. **Example 1:** **Input:** word1 = sea , word2 = eat **Output:** 2 **Explanation:** You need one step to make sea to ea and another step to make eat to ea . **Example 2:** **Input:** word1 = leetcode , word2 = etco **Output:** 4 **Constraints:** * `1 <= word1.length, word2.length <= 500` * `word1` and `word2` consist of only lowercase English letters.","completion":"def minDistance(word1, word2): m, n = len(word1), len(word2) dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] for i in range(m+1): for j in range(n+1): if i == 0 or j == 0: dp[i][j] = i + j elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"prompt":"Given a binary string `s`, return the number of nonempty substrings that have the same number of `0`\'s and `1`\'s, and all the `0`\'s and all the `1`\'s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. **Example 1:** **Input:** s = 00110011 **Output:** 6 **Explanation:** There are 6 substrings that have equal number of consecutive 1\'s and 0\'s: 0011 , 01 , 1100 , 10 , 0011 , and 01 . Notice that some of these substrings repeat and are counted the number of times they occur. Also, 00110011 is not a valid substring because all the 0\'s (and 1\'s) are not grouped together. **Example 2:** **Input:** s = 10101 **Output:** 4 **Explanation:** There are 4 substrings: 10 , 01 , 10 , 01 that have equal number of consecutive 1\'s and 0\'s. **Constraints:** * `1 <= s.length <= 105` * `s[i]` is either `\'0\'` or `\'1\'`.","completion":"def count_binary_substrings(s: str) -> int: prev, curr, result = 0, 1, 0 for i in range(1, len(s)): if s[i] == s[i - 1]: curr += 1 else: result += min(prev, curr) prev, curr = curr, 1 return result + min(prev, curr)"},{"prompt":"You are given an array `time` where `time[i]` denotes the time taken by the `ith` bus to complete **one trip**. Each bus can make multiple trips **successively**; that is, the next trip can start **immediately after** completing the current trip. Also, each bus operates **independently**; that is, the trips of one bus do not influence the trips of any other bus. You are also given an integer `totalTrips`, which denotes the number of trips all buses should make **in total**. Return _the **minimum time** required for all buses to complete **at least**_ `totalTrips` _trips_. **Example 1:** **Input:** time = [1,2,3], totalTrips = 5 **Output:** 3 **Explanation:** At time t = 1, the number of trips completed by each bus are [1,0,0]. The total number of trips completed is 1 + 0 + 0 = 1. At time t = 2, the number of trips completed by each bus are [2,1,0]. The total number of trips completed is 2 + 1 + 0 = 3. At time t = 3, the number of trips completed by each bus are [3,1,1]. The total number of trips completed is 3 + 1 + 1 = 5. So the minimum time needed for all buses to complete at least 5 trips is 3. **Example 2:** **Input:** time = [2], totalTrips = 1 **Output:** 2 **Explanation:** There is only one bus, and it will complete its first trip at t = 2. So the minimum time needed to complete 1 trip is 2. **Constraints:** * `1 <= time.length <= 105` * `1 <= time[i], totalTrips <= 107`","completion":"def sum_of_vowels_in_the_substrings(word: str) -> int: total_sum = 0 n = len(word) for i, char in enumerate(word): if char in {\'a\', \'e\', \'i\', \'o\', \'u\'}: total_sum += (i + 1) * (n - i) return total_sum"},{"prompt":"You are given a **0indexed** integer array `nums`. **Swaps** of **adjacent** elements are able to be performed on `nums`. A **valid** array meets the following conditions: * The largest element (any of the largest elements if there are multiple) is at the rightmost position in the array. * The smallest element (any of the smallest elements if there are multiple) is at the leftmost position in the array. Return _the **minimum** swaps required to make_ `nums` _a valid array_. **Example 1:** **Input:** nums = [3,4,5,5,3,1] **Output:** 6 **Explanation:** Perform the following swaps: Swap 1: Swap the 3rd and 4th elements, nums is then [3,4,5,**3**,**5**,1]. Swap 2: Swap the 4th and 5th elements, nums is then [3,4,5,3,**1**,**5**]. Swap 3: Swap the 3rd and 4th elements, nums is then [3,4,5,**1**,**3**,5]. Swap 4: Swap the 2nd and 3rd elements, nums is then [3,4,**1**,**5**,3,5]. Swap 5: Swap the 1st and 2nd elements, nums is then [3,**1**,**4**,5,3,5]. Swap 6: Swap the 0th and 1st elements, nums is then [**1**,**3**,4,5,3,5]. It can be shown that 6 swaps is the minimum swaps required to make a valid array. **Example 2:** **Input:** nums = [9] **Output:** 0 **Explanation:** The array is already valid, so we return 0. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 105`","completion":"def minSwaps(nums): n = len(nums) minPos = 0 maxPos = 0 swaps = 0 for i in range(1, n): if nums[i] <= nums[minPos]: minPos = i if nums[i] >= nums[maxPos]: maxPos = i swaps = minPos + (n - 1 - maxPos) if minPos < maxPos: swaps -= 1 return swaps"},{"prompt":"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**. A **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other. For each `d` from `1` to `n1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`. Return _an array of size_ `n1` _where the_ `dth` _element **(1indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`. **Notice** that the **distance** between the two cities is the number of edges in the path between them. **Example 1:** **Input:** n = 4, edges = [[1,2],[2,3],[2,4]] **Output:** [3,4,0] **Explanation:** The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1. The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2. No subtree has two nodes where the max distance between them is 3. **Example 2:** **Input:** n = 2, edges = [[1,2]] **Output:** [1] **Example 3:** **Input:** n = 3, edges = [[1,2],[2,3]] **Output:** [2,1] **Constraints:** * `2 <= n <= 15` * `edges.length == n1` * `edges[i].length == 2` * `1 <= ui, vi <= n` * All pairs `(ui, vi)` are distinct.","completion":"def winnerSquareGame(n: int) -> bool: dp = [False] * (n + 1) for i in range(1, n + 1): j = 1 while j * j <= i: if not dp[i - j * j]: dp[i] = True break j += 1 return dp[n]"},{"prompt":"Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `\'A\'` (accelerate) and `\'R\'` (reverse): * When you get an instruction `\'A\'`, your car does the following: * `position += speed` * `speed *= 2` * When you get an instruction `\'R\'`, your car does the following: * If your speed is positive then `speed = 1` * otherwise `speed = 1`Your position stays the same. For example, after commands `AAR `, your car goes to positions `0 > 1 > 3 > 3`, and your speed goes to `1 > 2 > 4 > 1`. Given a target position `target`, return _the length of the shortest sequence of instructions to get there_. **Example 1:** **Input:** target = 3 **Output:** 2 **Explanation:** The shortest instruction sequence is AA . Your position goes from 0 > 1 > 3. **Example 2:** **Input:** target = 6 **Output:** 5 **Explanation:** The shortest instruction sequence is AAARA . Your position goes from 0 > 1 > 3 > 7 > 7 > 6. **Constraints:** * `1 <= target <= 104`","completion":"def racecar(target: int) -> int: memo = {} def dp(position, speed): if abs(position) > 2 * target: return target + 1 if position == target: return 0 if speed == 1 else 1 if (position, speed) in memo: return memo[(position, speed)] ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1 ans = min(ans, dp(position + speed, speed * 2) + 1) memo[(position, speed)] = ans return ans return dp(0, 1)"},{"prompt":"Fruits are available at some positions on an infinite xaxis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**. You are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the xaxis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position. Return _the **maximum total number** of fruits you can harvest_. **Example 1:** **Input:** fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4 **Output:** 9 **Explanation:** The optimal way is to: Move right to position 6 and harvest 3 fruits Move right to position 8 and harvest 6 fruits You moved 3 steps and harvested 3 + 6 = 9 fruits in total. **Example 2:** **Input:** fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4 **Output:** 14 **Explanation:** You can move at most k = 4 steps, so you cannot reach position 0 nor 10. The optimal way is to: Harvest the 7 fruits at the starting position 5 Move left to position 4 and harvest 1 fruit Move right to position 6 and harvest 2 fruits Move right to position 7 and harvest 4 fruits You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total. **Example 3:** **Input:** fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2 **Output:** 0 **Explanation:** You can move at most k = 2 steps and cannot reach any position with fruits. **Constraints:** * `1 <= fruits.length <= 105` * `fruits[i].length == 2` * `0 <= startPos, positioni <= 2 * 105` * `positioni1 < positioni` for any `i > 0` (**0indexed**) * `1 <= amounti <= 104` * `0 <= k <= 2 * 105`","completion":"from math import gcd def findGCD(nums): return gcd(min(nums), max(nums))"},{"prompt":"You are given two integers `m` and `n` representing a **0indexed** `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `ith` guard and `jth` wall respectively. A guard can see **every** cell in the four cardinal directions (north, east, south, or west) starting from their position unless **obstructed** by a wall or another guard. A cell is **guarded** if there is **at least** one guard that can see it. Return _the number of unoccupied cells that are **not** **guarded**._ **Example 1:** **Input:** m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]] **Output:** 7 **Explanation:** The guarded and unguarded cells are shown in red and green respectively in the above diagram. There are a total of 7 unguarded cells, so we return 7. **Example 2:** **Input:** m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]] **Output:** 4 **Explanation:** The unguarded cells are shown in green in the above diagram. There are a total of 4 unguarded cells, so we return 4. **Constraints:** * `1 <= m, n <= 105` * `2 <= m * n <= 105` * `1 <= guards.length, walls.length <= 5 * 104` * `2 <= guards.length + walls.length <= m * n` * `guards[i].length == walls[j].length == 2` * `0 <= rowi, rowj < m` * `0 <= coli, colj < n` * All the positions in `guards` and `walls` are **unique**.","completion":"def earliest_blooming_day(plant_time, grow_time): bloom_time = [plant_time[i] + grow_time[i] for i in range(len(plant_time))] bloom_time.sort() earliest_day = 0 for i in bloom_time: earliest_day = max(earliest_day, i) earliest_day += 1 return earliest_day"},{"prompt":"A certain bug\'s home is on the xaxis at position `x`. Help them get there from position `0`. The bug jumps according to the following rules: * It can jump exactly `a` positions **forward** (to the right). * It can jump exactly `b` positions **backward** (to the left). * It cannot jump backward twice in a row. * It cannot jump to any `forbidden` positions. The bug may jump forward **beyond** its home, but it **cannot jump** to positions numbered with **negative** integers. Given an array of integers `forbidden`, where `forbidden[i]` means that the bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and `x`, return _the minimum number of jumps needed for the bug to reach its home_. If there is no possible sequence of jumps that lands the bug on position `x`, return `1.` **Example 1:** **Input:** forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9 **Output:** 3 **Explanation:** 3 jumps forward (0 > 3 > 6 > 9) will get the bug home. **Example 2:** **Input:** forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11 **Output:** 1 **Example 3:** **Input:** forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7 **Output:** 2 **Explanation:** One jump forward (0 > 16) then one jump backward (16 > 7) will get the bug home. **Constraints:** * `1 <= forbidden.length <= 1000` * `1 <= a, b, forbidden[i] <= 2000` * `0 <= x <= 2000` * All the elements in `forbidden` are distinct. * Position `x` is not forbidden.","completion":"from collections import deque def minimumJumps(forbidden, a, b, x): forbidden_positions = set(forbidden) q = deque([(0, 0, 0)]) visited = {(0, 0)} while q: pos, steps, backward = q.popleft() if pos == x: return steps forward_pos = pos + a backward_pos = pos - b if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited: visited.add((forward_pos, 0)) q.append((forward_pos, steps + 1, 0)) if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited: visited.add((backward_pos, 1)) q.append((backward_pos, steps + 1, 1)) return -1"},{"prompt":"You are given an undirected weighted graph of `n` nodes (0indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`. Given two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability. If there is no path from `start` to `end`, **return 0**. Your answer will be accepted if it differs from the correct answer by at most **1e5**. **Example 1:** **Input:** n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2 **Output:** 0.25000 **Explanation:** There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25. **Example 2:** **Input:** n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2 **Output:** 0.30000 **Example 3:** **Input:** n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2 **Output:** 0.00000 **Explanation:** There is no path between 0 and 2. **Constraints:** * `2 <= n <= 10^4` * `0 <= start, end < n` * `start != end` * `0 <= a, b < n` * `a != b` * `0 <= succProb.length == edges.length <= 2*10^4` * `0 <= succProb[i] <= 1` * There is at most one edge between every two nodes.","completion":"def min_start_value(nums): min_sum, sum = 0, 0 for num in nums: sum += num min_sum = min(min_sum, sum) return 1 - min_sum"},{"prompt":"You are given a **valid** boolean expression as a string `expression` consisting of the characters `\'1\'`,`\'0\'`,`\'&\'` (bitwise **AND** operator),`\'|\'` (bitwise **OR** operator),`\'(\'`, and `\')\'`. * For example, `()1|1 ` and `(1)&() ` are **not valid** while `1 `, `(((1))|(0)) `, and `1|(0&(1)) ` are **valid** expressions. Return _the **minimum cost** to change the final value of the expression_. * For example, if `expression = 1|1|(0&0)&1 `, its **value** is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the **new** expression evaluates to `0`. The **cost** of changing the final value of an expression is the **number of operations** performed on the expression. The types of **operations** are described as follows: * Turn a `\'1\'` into a `\'0\'`. * Turn a `\'0\'` into a `\'1\'`. * Turn a `\'&\'` into a `\'|\'`. * Turn a `\'|\'` into a `\'&\'`. **Note:** `\'&\'` does **not** take precedence over `\'|\'` in the **order of calculation**. Evaluate parentheses **first**, then in **lefttoright** order. **Example 1:** **Input:** expression = 1&(0|1) **Output:** 1 **Explanation:** We can turn 1&(0**|**1) into 1&(0**&**1) by changing the \'|\' to a \'&\' using 1 operation. The new expression evaluates to 0. **Example 2:** **Input:** expression = (0&0)&(0&0&0) **Output:** 3 **Explanation:** We can turn (0**&0**)**&**(0&0&0) into (0**|1**)**|**(0&0&0) using 3 operations. The new expression evaluates to 1. **Example 3:** **Input:** expression = (0|(1|0&1)) **Output:** 1 **Explanation:** We can turn (0|(**1**|0&1)) into (0|(**0**|0&1)) using 1 operation. The new expression evaluates to 0. **Constraints:** * `1 <= expression.length <= 105` * `expression` only contains `\'1\'`,`\'0\'`,`\'&\'`,`\'|\'`,`\'(\'`, and `\')\'` * All parentheses are properly matched. * There will be no empty parentheses (i.e: `() ` is not a substring of `expression`).","completion":"def maximumScore(nums, multipliers): n, m = len(nums), len(multipliers) dp = [[0] * (m + 1) for _ in range(m + 1)] maxScore = float(\'-inf\') for i in range(m + 1): for j in range(m - i + 1): if i == 0 and j == 0: continue score = 0 if i == 0: score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1] elif j == 0: score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1] else: score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1], dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]) dp[i][j] = score if i + j == m: maxScore = max(maxScore, score) return maxScore"},{"prompt":"You are given a string `text`. You can swap two of the characters in the `text`. Return _the length of the longest substring with repeated characters_. **Example 1:** **Input:** text = ababa **Output:** 3 **Explanation:** We can swap the first \'b\' with the last \'a\', or the last \'b\' with the first \'a\'. Then, the longest repeated character substring is aaa with length 3. **Example 2:** **Input:** text = aaabaaa **Output:** 6 **Explanation:** Swap \'b\' with the last \'a\' (or the first \'a\'), and we get longest repeated character substring aaaaaa with length 6. **Example 3:** **Input:** text = aaaaa **Output:** 5 **Explanation:** No need to swap, longest repeated character substring is aaaaa with length is 5. **Constraints:** * `1 <= text.length <= 2 * 104` * `text` consist of lowercase English characters only.","completion":"def find_third_words(text, first, second): words = text.split() result = [] for i in range(len(words) - 2): if words[i] == first and words[i + 1] == second: result.append(words[i + 2]) return result"},{"prompt":"There are `n` kids with candies. You are given an integer array `candies`, where each `candies[i]` represents the number of candies the `ith` kid has, and an integer `extraCandies`, denoting the number of extra candies that you have. Return _a boolean array_ `result` _of length_ `n`_, where_ `result[i]` _is_ `true` _if, after giving the_ `ith` _kid all the_ `extraCandies`_, they will have the **greatest** number of candies among all the kids__, or_ `false` _otherwise_. Note that **multiple** kids can have the **greatest** number of candies. **Example 1:** **Input:** candies = [2,3,5,1,3], extraCandies = 3 **Output:** [true,true,true,false,true] **Explanation:** If you give all extraCandies to: Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. **Example 2:** **Input:** candies = [4,2,1,1,2], extraCandies = 1 **Output:** [true,false,false,false,false] **Explanation:** There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. **Example 3:** **Input:** candies = [12,1,12], extraCandies = 10 **Output:** [true,false,true] **Constraints:** * `n == candies.length` * `2 <= n <= 100` * `1 <= candies[i] <= 100` * `1 <= extraCandies <= 50`","completion":"from collections import defaultdict def find_ancestors(node, adj_list, visited, ans): if visited[node]: return visited[node] = True for ancestor in adj_list[node]: ans.append(ancestor) find_ancestors(ancestor, adj_list, visited, ans) def find_ancestors_in_dag(n, edges): adj_list = defaultdict(list) for edge in edges: adj_list[edge[1]].append(edge[0]) ans = [] for i in range(n): visited = [False] * n ancestors = [] find_ancestors(i, adj_list, visited, ancestors) ans.append(sorted(ancestors)) return ans"},{"prompt":"There is an `m x n` grid, where `(0, 0)` is the topleft cell and `(m 1, n 1)` is the bottomright cell. You are given an integer array `startPos` where `startPos = [startrow, startcol]` indicates that **initially**, a **robot** is at the cell `(startrow, startcol)`. You are also given an integer array `homePos` where `homePos = [homerow, homecol]` indicates that its **home** is at the cell `(homerow, homecol)`. The robot needs to go to its home. It can move one cell in four directions: **left**, **right**, **up**, or **down**, and it can not move outside the boundary. Every move incurs some cost. You are further given two **0indexed** integer arrays: `rowCosts` of length `m` and `colCosts` of length `n`. * If the robot moves **up** or **down** into a cell whose **row** is `r`, then this move costs `rowCosts[r]`. * If the robot moves **left** or **right** into a cell whose **column** is `c`, then this move costs `colCosts[c]`. Return _the **minimum total cost** for this robot to return home_. **Example 1:** **Input:** startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7] **Output:** 18 **Explanation:** One optimal path is that: Starting from (1, 0) > It goes down to (**2**, 0). This move costs rowCosts[2] = 3. > It goes right to (2, **1**). This move costs colCosts[1] = 2. > It goes right to (2, **2**). This move costs colCosts[2] = 6. > It goes right to (2, **3**). This move costs colCosts[3] = 7. The total cost is 3 + 2 + 6 + 7 = 18 **Example 2:** **Input:** startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26] **Output:** 0 **Explanation:** The robot is already at its home. Since no moves occur, the total cost is 0. **Constraints:** * `m == rowCosts.length` * `n == colCosts.length` * `1 <= m, n <= 105` * `0 <= rowCosts[r], colCosts[c] <= 104` * `startPos.length == 2` * `homePos.length == 2` * `0 <= startrow, homerow < m` * `0 <= startcol, homecol < n`","completion":"def minTotalCost(startPos, homePos, rowCosts, colCosts): row_difference = abs(startPos[0] - homePos[0]) col_difference = abs(startPos[1] - homePos[1]) row_cost = sum(rowCosts[min(startPos[0], homePos[0]):min(startPos[0], homePos[0]) + row_difference]) col_cost = sum(colCosts[min(startPos[1], homePos[1]):min(startPos[1], homePos[1]) + col_difference]) return row_cost + col_cost"},{"prompt":"You are given a **0indexed** string `s` of **even** length `n`. The string consists of **exactly** `n / 2` opening brackets `\'[\'` and `n / 2` closing brackets `\']\'`. A string is called **balanced** if and only if: * It is the empty string, or * It can be written as `AB`, where both `A` and `B` are **balanced** strings, or * It can be written as `[C]`, where `C` is a **balanced** string. You may swap the brackets at **any** two indices **any** number of times. Return _the **minimum** number of swaps to make_ `s` _**balanced**_. **Example 1:** **Input:** s = ][][ **Output:** 1 **Explanation:** You can make the string balanced by swapping index 0 with index 3. The resulting string is [[]] . **Example 2:** **Input:** s = ]]][[[ **Output:** 2 **Explanation:** You can do the following to make the string balanced: Swap index 0 with index 4. s = []][][ . Swap index 1 with index 5. s = [[][]] . The resulting string is [[][]] . **Example 3:** **Input:** s = [] **Output:** 0 **Explanation:** The string is already balanced. **Constraints:** * `n == s.length` * `2 <= n <= 106` * `n` is even. * `s[i]` is either `\'[\'` or `\']\'`. * The number of opening brackets `\'[\'` equals `n / 2`, and the number of closing brackets `\']\'` equals `n / 2`.","completion":"def get_xor_sum(arr1, arr2): xor_arr1 = xor_arr2 = 0 for i in arr1: xor_arr1 ^= i for j in arr2: xor_arr2 ^= j return xor_arr1 & xor_arr2"},{"prompt":"Given an integer `n`, return _the **decimal value** of the binary string formed by concatenating the binary representations of_ `1` _to_ `n` _in order, **modulo**_ `109 + 7`. **Example 1:** **Input:** n = 1 **Output:** 1 **Explanation: ** 1 in binary corresponds to the decimal value 1. **Example 2:** **Input:** n = 3 **Output:** 27 **Explanation:** In binary, 1, 2, and 3 corresponds to 1 , 10 , and 11 . After concatenating them, we have 11011 , which corresponds to the decimal value 27. **Example 3:** **Input:** n = 12 **Output:** 505379714 **Explanation**: The concatenation results in 1101110010111011110001001101010111100 . The decimal value of that is 118505380540. After modulo 109 + 7, the result is 505379714. **Constraints:** * `1 <= n <= 105`","completion":"def count_routes(locations, start, finish, fuel, curr=None, remaining_fuel=None, memo=None): if memo is None: memo = {} if curr is None: curr = start remaining_fuel = fuel if remaining_fuel < 0: return 0 if (curr, remaining_fuel) in memo: return memo[(curr, remaining_fuel)] ans = 1 if curr == finish else 0 for next in range(len(locations)): if next != curr: ans += count_routes(locations, start, finish, fuel, next, remaining_fuel - abs(locations[curr] - locations[next]), memo) ans %= 1000000007 memo[(curr, remaining_fuel)] = ans return ans"},{"prompt":"We want to split a group of `n` people (labeled from `1` to `n`) into two groups of **any size**. Each person may dislike some other people, and they should not go into the same group. Given the integer `n` and the array `dislikes` where `dislikes[i] = [ai, bi]` indicates that the person labeled `ai` does not like the person labeled `bi`, return `true` _if it is possible to split everyone into two groups in this way_. **Example 1:** **Input:** n = 4, dislikes = [[1,2],[1,3],[2,4]] **Output:** true **Explanation:** The first group has [1,4], and the second group has [2,3]. **Example 2:** **Input:** n = 3, dislikes = [[1,2],[1,3],[2,3]] **Output:** false **Explanation:** We need at least 3 groups to divide them. We cannot put them in two groups. **Constraints:** * `1 <= n <= 2000` * `0 <= dislikes.length <= 104` * `dislikes[i].length == 2` * `1 <= ai < bi <= n` * All the pairs of `dislikes` are **unique**.","completion":"def scoreOfParentheses(s): score, depth = 0, 0 for i in range(len(s)): if s[i] == \'(\': depth += 1 else: depth -= 1 if s[i - 1] == \'(\': score += 1 << depth return score"},{"prompt":"Given a list `paths` of directory info, including the directory path, and all the files with contents in this directory, return _all the duplicate files in the file system in terms of their paths_. You may return the answer in **any order**. A group of duplicate files consists of at least two files that have the same content. A single directory info string in the input list has the following format: * `root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content) ` It means there are `n` files `(f1.txt, f2.txt ... fn.txt)` with content `(f1_content, f2_content ... fn_content)` respectively in the directory `root/d1/d2/.../dm `. Note that `n >= 1` and `m >= 0`. If `m = 0`, it means the directory is just the root directory. The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: * `directory_path/file_name.txt ` **Example 1:** **Input:** paths = [root/a 1.txt(abcd) 2.txt(efgh),root/c 3.txt(abcd),root/c/d 4.txt(efgh),root 4.txt(efgh)] **Output:** [[root/a/2.txt,root/c/d/4.txt,root/4.txt],[root/a/1.txt,root/c/3.txt]] **Example 2:** **Input:** paths = [root/a 1.txt(abcd) 2.txt(efgh),root/c 3.txt(abcd),root/c/d 4.txt(efgh)] **Output:** [[root/a/2.txt,root/c/d/4.txt],[root/a/1.txt,root/c/3.txt]] **Constraints:** * `1 <= paths.length <= 2 * 104` * `1 <= paths[i].length <= 3000` * `1 <= sum(paths[i].length) <= 5 * 105` * `paths[i]` consist of English letters, digits, `\'/\'`, `\'.\'`, `\'(\'`, `\')\'`, and `\' \'`. * You may assume no files or directories share the same name in the same directory. * You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.","completion":"from collections import defaultdict def find_duplicate(paths): content_map = defaultdict(list) for path in paths: parts = path.split() directory = parts[0] for file in parts[1:]: start = file.index(\'(\') end = file.index(\')\') content = file[start + 1:end] file_path = directory + \'/\' + file[:start] content_map[content].append(file_path) result = [file_paths for file_paths in content_map.values() if len(file_paths) > 1] return result"},{"prompt":"You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person. The **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`\'s population if `x` is in the **inclusive** range `[birthi, deathi 1]`. Note that the person is **not** counted in the year that they die. Return _the **earliest** year with the **maximum population**_. **Example 1:** **Input:** logs = [[1993,1999],[2000,2010]] **Output:** 1993 **Explanation:** The maximum population is 1, and 1993 is the earliest year with this population. **Example 2:** **Input:** logs = [[1950,1961],[1960,1971],[1970,1981]] **Output:** 1960 **Explanation:** The maximum population is 2, and it had happened in years 1960 and 1970. The earlier year between them is 1960. **Constraints:** * `1 <= logs.length <= 100` * `1950 <= birthi < deathi <= 2050`","completion":"def maxAliveYear(logs): years = [0] * 101 for log in logs: years[log[0] - 1950] += 1 years[log[1] - 1950] -= 1 max_population = years[0] max_year = 1950 for i in range(1, 101): years[i] += years[i - 1] if years[i] > max_population: max_population = years[i] max_year = i + 1950 return max_year"},{"prompt":"You are the operator of a Centennial Wheel that has **four gondolas**, and each gondola has room for **up** **to** **four people**. You have the ability to rotate the gondolas **counterclockwise**, which costs you `runningCost` dollars. You are given an array `customers` of length `n` where `customers[i]` is the number of new customers arriving just before the `ith` rotation (0indexed). This means you **must rotate the wheel** `i` **times before the** `customers[i]` **customers arrive**. **You cannot make customers wait if there is room in the gondola**. Each customer pays `boardingCost` dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again. You can stop the wheel at any time, including **before** **serving** **all** **customers**. If you decide to stop serving customers, **all subsequent rotations are free** in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait **for the next rotation**. Return _the minimum number of rotations you need to perform to maximize your profit._ If there is **no scenario** where the profit is positive, return `1`. **Example 1:** **Input:** customers = [8,3], boardingCost = 5, runningCost = 6 **Output:** 3 **Explanation:** The numbers written on the gondolas are the number of people currently there. 1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * 5 1 * 6 = 14. 2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * 5 2 * 6 = 28. 3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * 5 3 * 6 = 37. The highest profit was 37 after rotating the wheel 3 times. **Example 2:** **Input:** customers = [10,9,6], boardingCost = 6, runningCost = 4 **Output:** 7 **Explanation:** 1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * 6 1 * 4 = 20. 2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * 6 2 * 4 = 40. 3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * 6 3 * 4 = 60. 4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * 6 4 * 4 = 80. 5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * 6 5 * 4 = 100. 6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * 6 6 * 4 = 120. 7. 1 boards, the wheel rotates. Current profit is 25 * 6 7 * 4 = 122. The highest profit was 122 after rotating the wheel 7 times. **Example 3:** **Input:** customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92 **Output:** 1 **Explanation:** 1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * 1 1 * 92 = 89. 2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * 1 2 * 92 = 177. 3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * 1 3 * 92 = 269. 4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * 1 4 * 92 = 357. 5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * 1 5 * 92 = 447. The profit was never positive, so return 1. **Constraints:** * `n == customers.length` * `1 <= n <= 105` * `0 <= customers[i] <= 50` * `1 <= boardingCost, runningCost <= 100`","completion":"def minOperationsMaxProfit(customers, boardingCost, runningCost): waiting = 0 profit = 0 max_profit = 0 rotations = 0 result = -1 for i in range(len(customers) + sum(customers)): if i < len(customers): waiting += customers[i] boarding = min(waiting, 4) waiting -= boarding profit += boarding * boardingCost - runningCost if profit > max_profit: max_profit = profit result = rotations + 1 rotations += 1 return result"},{"prompt":"There is an undirected **star** graph consisting of `n` nodes labeled from `1` to `n`. A star graph is a graph where there is one **center** node and **exactly** `n 1` edges that connect the center node with every other node. You are given a 2D integer array `edges` where each `edges[i] = [ui, vi]` indicates that there is an edge between the nodes `ui` and `vi`. Return the center of the given star graph. **Example 1:** **Input:** edges = [[1,2],[2,3],[4,2]] **Output:** 2 **Explanation:** As shown in the figure above, node 2 is connected to every other node, so 2 is the center. **Example 2:** **Input:** edges = [[1,2],[5,1],[1,3],[1,4]] **Output:** 1 **Constraints:** * `3 <= n <= 105` * `edges.length == n 1` * `edges[i].length == 2` * `1 <= ui, vi <= n` * `ui != vi` * The given `edges` represent a valid star graph.","completion":"def maximum_wealth(accounts): return max(sum(customer) for customer in accounts)"},{"prompt":"You are given two groups of points where the first group has `size1` points, the second group has `size2` points, and `size1 >= size2`. The `cost` of the connection between any two points are given in an `size1 x size2` matrix where `cost[i][j]` is the cost of connecting point `i` of the first group and point `j` of the second group. The groups are connected if **each point in both groups is connected to one or more points in the opposite group**. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group. Return _the minimum cost it takes to connect the two groups_. **Example 1:** **Input:** cost = [[15, 96], [36, 2]] **Output:** 17 **Explanation**: The optimal way of connecting the groups is: 1A 2B This results in a total cost of 17. **Example 2:** **Input:** cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] **Output:** 4 **Explanation**: The optimal way of connecting the groups is: 1A 2B 2C 3A This results in a total cost of 4. Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost. **Example 3:** **Input:** cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]] **Output:** 10 **Constraints:** * `size1 == cost.length` * `size2 == cost[i].length` * `1 <= size1, size2 <= 12` * `size1 >= size2` * `0 <= cost[i][j] <= 100`","completion":"def connectTwoGroups(cost): size1, size2 = len(cost), len(cost[0]) min_cost = [float(\'inf\')] * size2 for i in range(size1): for j in range(size2): min_cost[j] = min(min_cost[j], cost[i][j]) total_cost = 0 for i in range(size1): total_cost += min(cost[i]) for j in range(size2): total_cost += min_cost[j] return total_cost"},{"prompt":"Given a string `s`, return _the number of **homogenous** substrings of_ `s`_._ Since the answer may be too large, return it **modulo** `109 + 7`. A string is **homogenous** if all the characters of the string are the same. A **substring** is a contiguous sequence of characters within a string. **Example 1:** **Input:** s = abbcccaa **Output:** 13 **Explanation:** The homogenous substrings are listed as below: a appears 3 times. aa appears 1 time. b appears 2 times. bb appears 1 time. c appears 3 times. cc appears 2 times. ccc appears 1 time. 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13. **Example 2:** **Input:** s = xy **Output:** 2 **Explanation:** The homogenous substrings are x and y . **Example 3:** **Input:** s = zzzzz **Output:** 15 **Constraints:** * `1 <= s.length <= 105` * `s` consists of lowercase letters.","completion":"def count_homogenous(s: str) -> int: MOD = 1000000007 count, total = 1, 0 for i in range(1, len(s)): count = count + 1 if s[i] == s[i - 1] else 1 total = (total + count) % MOD return (total + count) % MOD"},{"prompt":"You are given a **0indexed** integer array `nums` of length `n`. You are initially standing at index `0`. You can jump from index `i` to index `j` where `i < j` if: * `nums[i] <= nums[j]` and `nums[k] < nums[i]` for all indexes `k` in the range `i < k < j`, or * `nums[i] > nums[j]` and `nums[k] >= nums[i]` for all indexes `k` in the range `i < k < j`. You are also given an integer array `costs` of length `n` where `costs[i]` denotes the cost of jumping **to** index `i`. Return _the **minimum** cost to jump to the index_ `n 1`. **Example 1:** **Input:** nums = [3,2,4,4,1], costs = [3,7,6,4,2] **Output:** 8 **Explanation:** You start at index 0. Jump to index 2 with a cost of costs[2] = 6. Jump to index 4 with a cost of costs[4] = 2. The total cost is 8. It can be proven that 8 is the minimum cost needed. Two other possible paths are from index 0 > 1 > 4 and index 0 > 2 > 3 > 4. These have a total cost of 9 and 12, respectively. **Example 2:** **Input:** nums = [0,1,2], costs = [1,1,1] **Output:** 2 **Explanation:** Start at index 0. Jump to index 1 with a cost of costs[1] = 1. Jump to index 2 with a cost of costs[2] = 1. The total cost is 2. Note that you cannot jump directly from index 0 to index 2 because nums[0] <= nums[1]. **Constraints:** * `n == nums.length == costs.length` * `1 <= n <= 105` * `0 <= nums[i], costs[i] <= 105`","completion":"def minHeightJump(nums, costs): n = len(nums) dp = [float(\'inf\')] * n dp[0] = 0 for i in range(1, n): for j in range(i - 1, -1, -1): if ((nums[j] <= nums[i] and (j == 0 or nums[j - 1] < nums[i])) or (nums[j] > nums[i] and (j == 0 or nums[j - 1] >= nums[i]))): dp[i] = min(dp[i], dp[j] + costs[i]) return dp[n - 1]"},{"prompt":"Given an integer n, return _the smallest **prime palindrome** greater than or equal to_ `n`. An integer is **prime** if it has exactly two divisors: `1` and itself. Note that `1` is not a prime number. * For example, `2`, `3`, `5`, `7`, `11`, and `13` are all primes. An integer is a **palindrome** if it reads the same from left to right as it does from right to left. * For example, `101` and `12321` are palindromes. The test cases are generated so that the answer always exists and is in the range `[2, 2 * 108]`. **Example 1:** **Input:** n = 6 **Output:** 7 **Example 2:** **Input:** n = 8 **Output:** 11 **Example 3:** **Input:** n = 13 **Output:** 101 **Constraints:** * `1 <= n <= 108`","completion":"def isRectangleOverlap(rec1, rec2): return rec1[2] > rec2[0] and rec1[3] > rec2[1] and rec1[0] < rec2[2] and rec1[1] < rec2[3]"},{"prompt":"Given an integer array `nums`, return _the value of the bitwise_ **OR** _of the sum of all possible **subsequences** in the array_. A **subsequence** is a sequence that can be derived from another sequence by removing zero or more elements without changing the order of the remaining elements. **Example 1:** **Input:** nums = [2,1,0,3] **Output:** 7 **Explanation:** All possible subsequence sums that we can have are: 0, 1, 2, 3, 4, 5, 6. And we have 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7, so we return 7. **Example 2:** **Input:** nums = [0,0,0] **Output:** 0 **Explanation:** 0 is the only possible subsequence sum we can have, so we return 0. **Constraints:** * `1 <= nums.length <= 105` * `0 <= nums[i] <= 109`","completion":"def subsequence_or_sum(nums): result = 0 for num in nums: result |= num return result"},{"prompt":"You are given two strings, `word1` and `word2`. You want to construct a string in the following manner: * Choose some **nonempty** subsequence `subsequence1` from `word1`. * Choose some **nonempty** subsequence `subsequence2` from `word2`. * Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string. Return _the **length** of the longest **palindrome** that can be constructed in the described manner._ If no palindromes can be constructed, return `0`. A **subsequence** of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters. A **palindrome** is a string that reads the same forward as well as backward. **Example 1:** **Input:** word1 = cacb , word2 = cbba **Output:** 5 **Explanation:** Choose ab from word1 and cba from word2 to make abcba , which is a palindrome. **Example 2:** **Input:** word1 = ab , word2 = ab **Output:** 3 **Explanation:** Choose ab from word1 and a from word2 to make aba , which is a palindrome. **Example 3:** **Input:** word1 = aa , word2 = bb **Output:** 0 **Explanation:** You cannot construct a palindrome from the described method, so return 0. **Constraints:** * `1 <= word1.length, word2.length <= 1000` * `word1` and `word2` consist of lowercase English letters.","completion":"def maxProfit(inventory, orders): mod = 10**9 + 7 inventory.sort(reverse=True) inventory.append(0) n, ans, count = len(inventory), 0, 1 for i in range(n - 1): diff = inventory[i] - inventory[i + 1] if count * diff < orders: orders -= count * diff ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod else: q, r = divmod(orders, count) ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod ans = (ans + r * (inventory[i] - q)) % mod break count += 1 return ans"},{"prompt":"A binary tree is given such that each node contains an additional random pointer which could point to any node in the tree or null. Return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the tree. The tree is represented in the same input/output way as normal binary trees where each node is represented as a pair of `[val, random_index]` where: * `val`: an integer representing `Node.val` * `random_index`: the index of the node (in the input) where the random pointer points to, or `null` if it does not point to any node. You will be given the tree in class `Node` and you should return the cloned tree in class `NodeCopy`. `NodeCopy` class is just a clone of `Node` class with the same attributes and constructors. **Example 1:** **Input:** root = [[1,null],null,[4,3],[7,0]] **Output:** [[1,null],null,[4,3],[7,0]] **Explanation:** The original binary tree is [1,null,4,7]. The random pointer of node one is null, so it is represented as [1, null]. The random pointer of node 4 is node 7, so it is represented as [4, 3] where 3 is the index of node 7 in the array representing the tree. The random pointer of node 7 is node 1, so it is represented as [7, 0] where 0 is the index of node 1 in the array representing the tree. **Example 2:** **Input:** root = [[1,4],null,[1,0],null,[1,5],[1,5]] **Output:** [[1,4],null,[1,0],null,[1,5],[1,5]] **Explanation:** The random pointer of a node can be the node itself. **Example 3:** **Input:** root = [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]] **Output:** [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]] **Constraints:** * The number of nodes in the `tree` is in the range `[0, 1000].` * `1 <= Node.val <= 106`","completion":"from collections import deque def minCost(grid): def dfs(r, c, d): if 0 <= r < m and 0 <= c < n and d < cost[r][c]: cost[r][c] = d q.append((r, c)) m, n = len(grid), len(grid[0]) cost = [[1e6] * n for _ in range(m)] q = deque() directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] dfs(0, 0, 0) while q: r, c = q.popleft() for i, (dr, dc) in enumerate(directions): dfs(r + dr, c + dc, cost[r][c] + (grid[r][c] != i + 1)) return cost[-1][-1]"},{"prompt":"You are given a positive integer array `skill` of **even** length `n` where `skill[i]` denotes the skill of the `ith` player. Divide the players into `n / 2` teams of size `2` such that the total skill of each team is **equal**. The **chemistry** of a team is equal to the **product** of the skills of the players on that team. Return _the sum of the **chemistry** of all the teams, or return_ `1` _if there is no way to divide the players into teams such that the total skill of each team is equal._ **Example 1:** **Input:** skill = [3,2,5,1,3,4] **Output:** 22 **Explanation:** Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6. The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22. **Example 2:** **Input:** skill = [3,4] **Output:** 12 **Explanation:** The two players form a team with a total skill of 7. The chemistry of the team is 3 * 4 = 12. **Example 3:** **Input:** skill = [1,1,2,3] **Output:** 1 **Explanation:** There is no way to divide the players into teams such that the total skill of each team is equal. **Constraints:** * `2 <= skill.length <= 105` * `skill.length` is even. * `1 <= skill[i] <= 1000`","completion":"def maximumChemistry(skill): total_sum = sum(skill) target_sum = total_sum // 2 if total_sum % 2 == 1: return -1 dp = {0: 1} max_chemistry = 0 for s in skill: for i in range(target_sum - s, -1, -1): if i in dp: dp[i + s] = dp.get(i + s, 0) + dp[i] if i + s == target_sum: max_chemistry += dp[i] * s return max_chemistry if max_chemistry > 0 else -1"},{"prompt":"Every **valid email** consists of a **local name** and a **domain name**, separated by the `\'@\'` sign. Besides lowercase letters, the email may contain one or more `\'.\'` or `\'+\'`. * For example, in `alice@leetcode.com `, `alice ` is the **local name**, and `leetcode.com ` is the **domain name**. If you add periods `\'.\'` between some characters in the **local name** part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule **does not apply** to **domain names**. * For example, `alice.z@leetcode.com ` and `alicez@leetcode.com ` forward to the same email address. If you add a plus `\'+\'` in the **local name**, everything after the first plus sign **will be ignored**. This allows certain emails to be filtered. Note that this rule **does not apply** to **domain names**. * For example, `m.y+name@email.com ` will be forwarded to `my@email.com `. It is possible to use both of these rules at the same time. Given an array of strings `emails` where we send one email to each `emails[i]`, return _the number of different addresses that actually receive mails_. **Example 1:** **Input:** emails = [ test.email+alex@leetcode.com , test.e.mail+bob.cathy@leetcode.com , testemail+david@lee.tcode.com ] **Output:** 2 **Explanation:** testemail@leetcode.com and testemail@lee.tcode.com actually receive mails. **Example 2:** **Input:** emails = [ a@leetcode.com , b@leetcode.com , c@leetcode.com ] **Output:** 3 **Constraints:** * `1 <= emails.length <= 100` * `1 <= emails[i].length <= 100` * `emails[i]` consist of lowercase English letters, `\'+\'`, `\'.\'` and `\'@\'`. * Each `emails[i]` contains exactly one `\'@\'` character. * All local and domain names are nonempty. * Local names do not start with a `\'+\'` character. * Domain names end with the `.com ` suffix.","completion":"def num_special_equivalent_groups(words): groups = set() for word in words: evens = \\"\\".join(sorted(word[0::2])) odds = \\"\\".join(sorted(word[1::2])) groups.add(evens + odds) return len(groups)"},{"prompt":"English, we have a concept called **root**, which can be followed by some other word to form another longer word let\'s call this word **successor**. For example, when the **root** `an ` is followed by the **successor** word `other `, we can form a new word `another `. Given a `dictionary` consisting of many **roots** and a `sentence` consisting of words separated by spaces, replace all the **successors** in the sentence with the **root** forming it. If a **successor** can be replaced by more than one **root**, replace it with the **root** that has **the shortest length**. Return _the `sentence`_ after the replacement. **Example 1:** **Input:** dictionary = [ cat , bat , rat ], sentence = the cattle was rattled by the battery **Output:** the cat was rat by the bat **Example 2:** **Input:** dictionary = [ a , b , c ], sentence = aadsfasf absbs bbab cadsfafs **Output:** a a b c **Constraints:** * `1 <= dictionary.length <= 1000` * `1 <= dictionary[i].length <= 100` * `dictionary[i]` consists of only lowercase letters. * `1 <= sentence.length <= 106` * `sentence` consists of only lowercase letters and spaces. * The number of words in `sentence` is in the range `[1, 1000]` * The length of each word in `sentence` is in the range `[1, 1000]` * Every two consecutive words in `sentence` will be separated by exactly one space. * `sentence` does not have leading or trailing spaces.","completion":"def replaceWords(dict, sentence): roots = set(dict) words = sentence.split() result = [] for word in words: prefix = \'\' for i in range(1, len(word) + 1): prefix = word[:i] if prefix in roots: break result.append(prefix) return \' \'.join(result)"},{"prompt":"You are given an `m x n` binary matrix `grid` where each cell is either `0` (empty) or `1` (occupied). You are then given stamps of size `stampHeight x stampWidth`. We want to fit the stamps such that they follow the given **restrictions** and **requirements**: 1. Cover all the **empty** cells. 2. Do not cover any of the **occupied** cells. 3. We can put as **many** stamps as we want. 4. Stamps can **overlap** with each other. 5. Stamps are not allowed to be **rotated**. 6. Stamps must stay completely **inside** the grid. Return `true` _if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return_ `false`. **Example 1:** **Input:** grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3 **Output:** true **Explanation:** We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells. **Example 2:** **Input:** grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 **Output:** false **Explanation:** There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid. **Constraints:** * `m == grid.length` * `n == grid[r].length` * `1 <= m, n <= 105` * `1 <= m * n <= 2 * 105` * `grid[r][c]` is either `0` or `1`. * `1 <= stampHeight, stampWidth <= 105`","completion":"def construct2DArray(original, m, n): if m * n != len(original): return [] res = [[0] * n for _ in range(m)] for i in range(len(original)): res[i // n][i % n] = original[i] return res"},{"prompt":"You are given a **0indexed** array of string `words` and two integers `left` and `right`. A string is called a **vowel string** if it starts with a vowel character and ends with a vowel character where vowel characters are `\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, and `\'u\'`. Return _the number of vowel strings_ `words[i]` _where_ `i` _belongs to the inclusive range_ `[left, right]`. **Example 1:** **Input:** words = [ are , amy , u ], left = 0, right = 2 **Output:** 2 **Explanation:** are is a vowel string because it starts with \'a\' and ends with \'e\'. amy is not a vowel string because it does not end with a vowel. u is a vowel string because it starts with \'u\' and ends with \'u\'. The number of vowel strings in the mentioned range is 2. **Example 2:** **Input:** words = [ hey , aeo , mu , ooo , artro ], left = 1, right = 4 **Output:** 3 **Explanation:** aeo is a vowel string because it starts with \'a\' and ends with \'o\'. mu is not a vowel string because it does not start with a vowel. ooo is a vowel string because it starts with \'o\' and ends with \'o\'. artro is a vowel string because it starts with \'a\' and ends with \'o\'. The number of vowel strings in the mentioned range is 3. **Constraints:** * `1 <= words.length <= 1000` * `1 <= words[i].length <= 10` * `words[i]` consists of only lowercase English letters. * `0 <= left <= right < words.length`","completion":"def is_vowel(c): return c in \'aeiou\' def count_vowel_strings(words, left, right): count = 0 for i in range(left, right + 1): if is_vowel(words[i][0]) and is_vowel(words[i][-1]): count += 1 return count"},{"prompt":"You are given an array of `words` where each word consists of lowercase English letters. `wordA` is a **predecessor** of `wordB` if and only if we can insert **exactly one** letter anywhere in `wordA` **without changing the order of the other characters** to make it equal to `wordB`. * For example, `abc ` is a **predecessor** of `abac `, while `cba ` is not a **predecessor** of `bcad `. A **word chain** is a sequence of words `[word1, word2, ..., wordk]` with `k >= 1`, where `word1` is a **predecessor** of `word2`, `word2` is a **predecessor** of `word3`, and so on. A single word is trivially a **word chain** with `k == 1`. Return _the **length** of the **longest possible word chain** with words chosen from the given list of_ `words`. **Example 1:** **Input:** words = [ a , b , ba , bca , bda , bdca ] **Output:** 4 **Explanation**: One of the longest word chains is [ a , ba , bda , bdca ]. **Example 2:** **Input:** words = [ xbc , pcxbcf , xb , cxbc , pcxbc ] **Output:** 5 **Explanation:** All the words can be put in a word chain [ xb , xbc , cxbc , pcxbc , pcxbcf ]. **Example 3:** **Input:** words = [ abcd , dbqca ] **Output:** 1 **Explanation:** The trivial word chain [ abcd ] is one of the longest word chains. [ abcd , dbqca ] is not a valid word chain because the ordering of the letters is changed. **Constraints:** * `1 <= words.length <= 1000` * `1 <= words[i].length <= 16` * `words[i]` only consists of lowercase English letters.","completion":"def clumsy(n: int) -> int: if n <= 2: return n if n == 3: return 6 result = n * (n - 1) // (n - 2) + (n - 3) n -= 4 while n >= 4: result = result - (n * (n - 1) // (n - 2)) + (n - 3) n -= 4 return result - clumsy(n)"},{"prompt":"You are given a string `num`, representing a large integer, and an integer `k`. We call some integer **wonderful** if it is a **permutation** of the digits in `num` and is **greater in value** than `num`. There can be many wonderful integers. However, we only care about the **smallestvalued** ones. * For example, when `num = 5489355142 `: * The 1st smallest wonderful integer is `5489355214 `. * The 2nd smallest wonderful integer is `5489355241 `. * The 3rd smallest wonderful integer is `5489355412 `. * The 4th smallest wonderful integer is `5489355421 `. Return _the **minimum number of adjacent digit swaps** that needs to be applied to_ `num` _to reach the_ `kth` _**smallest wonderful** integer_. The tests are generated in such a way that `kth` smallest wonderful integer exists. **Example 1:** **Input:** num = 5489355142 , k = 4 **Output:** 2 **Explanation:** The 4th smallest wonderful number is 5489355421 . To get this number: Swap index 7 with index 8: 5489355142 > 5489355412 Swap index 8 with index 9: 5489355412 > 5489355421 **Example 2:** **Input:** num = 11112 , k = 4 **Output:** 4 **Explanation:** The 4th smallest wonderful number is 21111 . To get this number: Swap index 3 with index 4: 11112 > 11121 Swap index 2 with index 3: 11121 > 11211 Swap index 1 with index 2: 11211 > 12111 Swap index 0 with index 1: 12111 > 21111 **Example 3:** **Input:** num = 00123 , k = 1 **Output:** 1 **Explanation:** The 1st smallest wonderful number is 00132 . To get this number: Swap index 3 with index 4: 00123 > 00132 **Constraints:** * `2 <= num.length <= 1000` * `1 <= k <= 1000` * `num` only consists of digits.","completion":"def min_length_after_operations(s: str) -> int: a_count = s.count(\'a\') b_count = s.count(\'b\') c_count = s.count(\'c\') if a_count % 2 == b_count % 2 and b_count % 2 == c_count % 2: return len(s) % 2 return (len(s) + 1) % 2"},{"prompt":"You are given a **0indexed** `m x n` binary matrix `matrix` and an integer `numSelect`, which denotes the number of **distinct** columns you must select from `matrix`. Let us consider `s = {c1, c2, ...., cnumSelect}` as the set of columns selected by you. A row `row` is **covered** by `s` if: * For each cell `matrix[row][col]` (`0 <= col <= n 1`) where `matrix[row][col] == 1`, `col` is present in `s` or, * **No cell** in `row` has a value of `1`. You need to choose `numSelect` columns such that the number of rows that are covered is **maximized**. Return _the **maximum** number of rows that can be **covered** by a set of_ `numSelect` _columns._ **Example 1:** **Input:** matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2 **Output:** 3 **Explanation:** One possible way to cover 3 rows is shown in the diagram above. We choose s = {0, 2}. Row 0 is covered because it has no occurrences of 1. Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s. Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s. Row 3 is covered because matrix[2][2] == 1 and 2 is present in s. Thus, we can cover three rows. Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered. **Example 2:** **Input:** matrix = [[1],[0]], numSelect = 1 **Output:** 2 **Explanation:** Selecting the only column will result in both rows being covered since the entire matrix is selected. Therefore, we return 2. **Constraints:** * `m == matrix.length` * `n == matrix[i].length` * `1 <= m, n <= 12` * `matrix[i][j]` is either `0` or `1`. * `1 <= numSelect <= n`","completion":"def max_covered_rows(matrix, num_select): m, n = len(matrix), len(matrix[0]) max_covered = 0 for i in range(1 << n): if bin(i).count(\'1\') == num_select: covered = 0 for row in range(m): for col in range(n): if matrix[row][col] == 1 and i & (1 << col): covered += 1 break max_covered = max(max_covered, covered) return max_covered"},{"prompt":"magine you have a special keyboard with the following keys: * A: Print one `\'A\'` on the screen. * CtrlA: Select the whole screen. * CtrlC: Copy selection to buffer. * CtrlV: Print buffer on screen appending it after what has already been printed. Given an integer n, return _the maximum number of_ `\'A\'` _you can print on the screen with **at most**_ `n` _presses on the keys_. **Example 1:** **Input:** n = 3 **Output:** 3 **Explanation:** We can at most get 3 A\'s on screen by pressing the following key sequence: A, A, A **Example 2:** **Input:** n = 7 **Output:** 9 **Explanation:** We can at most get 9 A\'s on screen by pressing following key sequence: A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V **Constraints:** * `1 <= n <= 50`","completion":"def maxA(n: int) -> int: dp = [0] * (n + 1) for i in range(1, n + 1): dp[i] = i for j in range(1, i - 2): dp[i] = max(dp[i], dp[j] * (i - j - 1)) return dp[n]"},{"prompt":"You are given a list of songs where the `ith` song has a duration of `time[i]` seconds. Return _the number of pairs of songs for which their total duration in seconds is divisible by_ `60`. Formally, we want the number of indices `i`, `j` such that `i < j` with `(time[i] + time[j]) % 60 == 0`. **Example 1:** **Input:** time = [30,20,150,100,40] **Output:** 3 **Explanation:** Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 **Example 2:** **Input:** time = [60,60,60] **Output:** 3 **Explanation:** All three pairs have a total duration of 120, which is divisible by 60. **Constraints:** * `1 <= time.length <= 6 * 104` * `1 <= time[i] <= 500`","completion":"def powerful_integers(x, y, bound): result = set() for i in range(20): for j in range(20): val = x**i + y**j if val <= bound: result.add(val) return list(result)"},{"prompt":"You are in a city that consists of `n` intersections numbered from `0` to `n 1` with **bidirectional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections. You are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n 1` in the **shortest amount of time**. Return _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`. **Example 1:** **Input:** n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] **Output:** 4 **Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes. The four ways to get there in 7 minutes are: 0 ➝ 6 0 ➝ 4 ➝ 6 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6 **Example 2:** **Input:** n = 2, roads = [[1,0,10]] **Output:** 1 **Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes. **Constraints:** * `1 <= n <= 200` * `n 1 <= roads.length <= n * (n 1) / 2` * `roads[i].length == 3` * `0 <= ui, vi <= n 1` * `1 <= timei <= 109` * `ui != vi` * There is at most one road connecting any two intersections. * You can reach any intersection from any other intersection.","completion":"def can_split_string(s: str) -> bool: count = [0] * 10 for c in s: count[int(c)] += 1 for i in range(1, 10): if count[i] > 0 and count[i] == count[i - 1]: return True return False"},{"prompt":"Given a string `s` and an array of strings `words`, determine whether `s` is a **prefix string** of `words`. A string `s` is a **prefix string** of `words` if `s` can be made by concatenating the first `k` strings in `words` for some **positive** `k` no larger than `words.length`. Return `true` _if_ `s` _is a **prefix string** of_ `words`_, or_ `false` _otherwise_. **Example 1:** **Input:** s = iloveleetcode , words = [ i , love , leetcode , apples ] **Output:** true **Explanation:** s can be made by concatenating i , love , and leetcode together. **Example 2:** **Input:** s = iloveleetcode , words = [ apples , i , love , leetcode ] **Output:** false **Explanation:** It is impossible to make s using a prefix of arr. **Constraints:** * `1 <= words.length <= 100` * `1 <= words[i].length <= 20` * `1 <= s.length <= 1000` * `words[i]` and `s` consist of only lowercase English letters.","completion":"def max_ice_cream(costs, coins): costs.sort() count = 0 for cost in costs: if coins >= cost: coins -= cost count += 1 else: break return count"},{"prompt":"You are given a **0indexed** integer array `nums`. You have to partition the array into one or more **contiguous** subarrays. We call a partition of the array **valid** if each of the obtained subarrays satisfies **one** of the following conditions: 1. The subarray consists of **exactly** `2` equal elements. For example, the subarray `[2,2]` is good. 2. The subarray consists of **exactly** `3` equal elements. For example, the subarray `[4,4,4]` is good. 3. The subarray consists of **exactly** `3` consecutive increasing elements, that is, the difference between adjacent elements is `1`. For example, the subarray `[3,4,5]` is good, but the subarray `[1,3,5]` is not. Return `true` _if the array has **at least** one valid partition_. Otherwise, return `false`. **Example 1:** **Input:** nums = [4,4,4,5,6] **Output:** true **Explanation:** The array can be partitioned into the subarrays [4,4] and [4,5,6]. This partition is valid, so we return true. **Example 2:** **Input:** nums = [1,1,1,2] **Output:** false **Explanation:** There is no valid partition for this array. **Constraints:** * `2 <= nums.length <= 105` * `1 <= nums[i] <= 106`","completion":"def valid_partition(nums): count = {} for num in nums: count[num] = count.get(num, 0) + 1 for num, cnt in count.items(): if cnt == 2 or cnt == 3 or (num - 1 in count and num + 1 in count): return True return False"},{"prompt":"You are given a string `s` representing a list of words. Each letter in the word has one or more options. * If there is one option, the letter is represented as is. * If there is more than one option, then curly braces delimit the options. For example, `{a,b,c} ` represents options `[ a , b , c ]`. For example, if `s = a{b,c} `, the first character is always `\'a\'`, but the second character can be `\'b\'` or `\'c\'`. The original list is `[ ab , ac ]`. Return all words that can be formed in this manner, **sorted** in lexicographical order. **Example 1:** **Input:** s = {a,b}c{d,e}f **Output:** [acdf,acef,bcdf,bcef] **Example 2:** **Input:** s = abcd **Output:** [abcd] **Constraints:** * `1 <= s.length <= 50` * `s` consists of curly brackets `\'{}\'`, commas `\',\'`, and lowercase English letters. * `s` is guaranteed to be a valid input. * There are no nested curly brackets. * All characters inside a pair of consecutive opening and ending curly brackets are different.","completion":"def longestArithSeqLength(nums): n = len(nums) longest = 0 dp = [{} for _ in range(n)] for i in range(n): for j in range(i): diff = nums[i] - nums[j] dp[i][diff] = dp[j].get(diff, 1) + 1 longest = max(longest, dp[i][diff]) return longest"},{"prompt":"There is a **hidden** integer array `arr` that consists of `n` nonnegative integers. It was encoded into another integer array `encoded` of length `n 1`, such that `encoded[i] = arr[i] XOR arr[i + 1]`. For example, if `arr = [1,0,2,1]`, then `encoded = [1,2,3]`. You are given the `encoded` array. You are also given an integer `first`, that is the first element of `arr`, i.e. `arr[0]`. Return _the original array_ `arr`. It can be proved that the answer exists and is unique. **Example 1:** **Input:** encoded = [1,2,3], first = 1 **Output:** [1,0,2,1] **Explanation:** If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] **Example 2:** **Input:** encoded = [6,2,7,3], first = 4 **Output:** [4,2,0,7,4] **Constraints:** * `2 <= n <= 104` * `encoded.length == n 1` * `0 <= encoded[i] <= 105` * `0 <= first <= 105`","completion":"def minOperations(logs): depth = 0 for log in logs: if log == \\"../\\": if depth > 0: depth -= 1 elif log != \\"./\\": depth += 1 return depth"},{"prompt":"A robot on an infinite XYplane starts at point `(0, 0)` facing north. The robot can receive a sequence of these three possible types of `commands`: * `2`: Turn left `90` degrees. * `1`: Turn right `90` degrees. * `1 <= k <= 9`: Move forward `k` units, one unit at a time. Some of the grid squares are `obstacles`. The `ith` obstacle is at grid point `obstacles[i] = (xi, yi)`. If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command. Return _the **maximum Euclidean distance** that the robot ever gets from the origin **squared** (i.e. if the distance is_ `5`_, return_ `25`_)_. **Note:** * North means +Y direction. * East means +X direction. * South means Y direction. * West means X direction. **Example 1:** **Input:** commands = [4,1,3], obstacles = [] **Output:** 25 **Explanation:** The robot starts at (0, 0): 1. Move north 4 units to (0, 4). 2. Turn right. 3. Move east 3 units to (3, 4). The furthest point the robot ever gets from the origin is (3, 4), which squared is 32 + 42 = 25 units away. **Example 2:** **Input:** commands = [4,1,4,2,4], obstacles = [[2,4]] **Output:** 65 **Explanation:** The robot starts at (0, 0): 1. Move north 4 units to (0, 4). 2. Turn right. 3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4). 4. Turn left. 5. Move north 4 units to (1, 8). The furthest point the robot ever gets from the origin is (1, 8), which squared is 12 + 82 = 65 units away. **Example 3:** **Input:** commands = [6,1,1,6], obstacles = [] **Output:** 36 **Explanation:** The robot starts at (0, 0): 1. Move north 6 units to (0, 6). 2. Turn right. 3. Turn right. 4. Move south 6 units to (0, 0). The furthest point the robot ever gets from the origin is (0, 6), which squared is 62 = 36 units away. **Constraints:** * `1 <= commands.length <= 104` * `commands[i]` is either `2`, `1`, or an integer in the range `[1, 9]`. * `0 <= obstacles.length <= 104` * `3 * 104 <= xi, yi <= 3 * 104` * The answer is guaranteed to be less than `231`.","completion":"def backspace_compare(s, t): def process_backspaces(string): stack = [] for c in string: if c != \'#\': stack.append(c) elif stack: stack.pop() return stack return process_backspaces(s) == process_backspaces(t)"},{"prompt":"You are given a **0indexed** 2D integer array `pairs` where `pairs[i] = [starti, endi]`. An arrangement of `pairs` is **valid** if for every index `i` where `1 <= i < pairs.length`, we have `endi1 == starti`. Return _**any** valid arrangement of_ `pairs`. **Note:** The inputs will be generated such that there exists a valid arrangement of `pairs`. **Example 1:** **Input:** pairs = [[5,1],[4,5],[11,9],[9,4]] **Output:** [[11,9],[9,4],[4,5],[5,1]] **Explanation:** This is a valid arrangement since endi1 always equals starti. end0 = 9 == 9 = start1 end1 = 4 == 4 = start2 end2 = 5 == 5 = start3 **Example 2:** **Input:** pairs = [[1,3],[3,2],[2,1]] **Output:** [[1,3],[3,2],[2,1]] **Explanation:** This is a valid arrangement since endi1 always equals starti. end0 = 3 == 3 = start1 end1 = 2 == 2 = start2 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid. **Example 3:** **Input:** pairs = [[1,2],[1,3],[2,1]] **Output:** [[1,2],[2,1],[1,3]] **Explanation:** This is a valid arrangement since endi1 always equals starti. end0 = 2 == 2 = start1 end1 = 1 == 1 = start2 **Constraints:** * `1 <= pairs.length <= 105` * `pairs[i].length == 2` * `0 <= starti, endi <= 109` * `starti != endi` * No two pairs are exactly the same. * There **exists** a valid arrangement of `pairs`.","completion":"def valid_arrangement(pairs): graph = {} for start, end in pairs: if start not in graph: graph[start] = [] graph[start].append(end) result = [] current = pairs[0][0] while graph: pair = [current, graph[current].pop()] if not graph[current]: del graph[current] result.append(pair) current = pair[1] return result"},{"prompt":"Given a list of strings `words` and a string `pattern`, return _a list of_ `words[i]` _that match_ `pattern`. You may return the answer in **any order**. A word matches the pattern if there exists a permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter. **Example 1:** **Input:** words = [ abc , deq , mee , aqq , dkd , ccc ], pattern = abb **Output:** [ mee , aqq ] **Explanation:** mee matches the pattern because there is a permutation {a > m, b > e, ...}. ccc does not match the pattern because {a > c, b > c, ...} is not a permutation, since a and b map to the same letter. **Example 2:** **Input:** words = [ a , b , c ], pattern = a **Output:** [ a , b , c ] **Constraints:** * `1 <= pattern.length <= 20` * `1 <= words.length <= 50` * `words[i].length == pattern.length` * `pattern` and `words[i]` are lowercase English letters.","completion":"def lemonadeChange(bills): five, ten = 0, 0 for bill in bills: if bill == 5: five += 1 elif bill == 10: if not five: return False five -= 1 ten += 1 else: if ten and five: ten -= 1 five -= 1 elif five >= 3: five -= 3 else: return False return True"},{"prompt":"You have `n` gardens, labeled from `1` to `n`, and an array `paths` where `paths[i] = [xi, yi]` describes a bidirectional path between garden `xi` to garden `yi`. In each garden, you want to plant one of 4 types of flowers. All gardens have **at most 3** paths coming into or leaving it. Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers. Return _**any** such a choice as an array_ `answer`_, where_ `answer[i]` _is the type of flower planted in the_ `(i+1)th` _garden. The flower types are denoted_ `1`_,_ `2`_,_ `3`_, or_ `4`_. It is guaranteed an answer exists._ **Example 1:** **Input:** n = 3, paths = [[1,2],[2,3],[3,1]] **Output:** [1,2,3] **Explanation:** Gardens 1 and 2 have different types. Gardens 2 and 3 have different types. Gardens 3 and 1 have different types. Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1]. **Example 2:** **Input:** n = 4, paths = [[1,2],[3,4]] **Output:** [1,2,1,2] **Example 3:** **Input:** n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] **Output:** [1,2,3,4] **Constraints:** * `1 <= n <= 104` * `0 <= paths.length <= 2 * 104` * `paths[i].length == 2` * `1 <= xi, yi <= n` * `xi != yi` * Every garden has **at most 3** paths coming into or leaving it.","completion":"def mergeStones(stones, k): n = len(stones) if (n - 1) % (k - 1) != 0: return -1 prefixSum = [0] * (n + 1) dp = [[[-1] * (k + 1) for _ in range(n)] for _ in range(n)] for i in range(n): prefixSum[i + 1] = prefixSum[i] + stones[i] for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 for m in range(2, k + 1): for p in range(i, j + 1 - m + 1, k - 1): dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1e9 + 7) if (j - i) % (k - 1) == 0: dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1e9 + 7) return dp[0][n - 1][1]"},{"prompt":"There are `n` people that are split into some unknown number of groups. Each person is labeled with a **unique ID** from `0` to `n 1`. You are given an integer array `groupSizes`, where `groupSizes[i]` is the size of the group that person `i` is in. For example, if `groupSizes[1] = 3`, then person `1` must be in a group of size `3`. Return _a list of groups such that each person `i` is in a group of size `groupSizes[i]`_. Each person should appear in **exactly one group**, and every person must be in a group. If there are multiple answers, **return any of them**. It is **guaranteed** that there will be **at least one** valid solution for the given input. **Example 1:** **Input:** groupSizes = [3,3,3,3,3,1,3] **Output:** [[5],[0,1,2],[3,4,6]] **Explanation:** The first group is [5]. The size is 1, and groupSizes[5] = 1. The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3. The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3. Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. **Example 2:** **Input:** groupSizes = [2,1,3,3,3,2] **Output:** [[1],[0,5],[2,3,4]] **Constraints:** * `groupSizes.length == n` * `1 <= n <= 500` * `1 <= groupSizes[i] <= n`","completion":"from collections import defaultdict def groupThePeople(groupSizes): groups = defaultdict(list) result = [] for i, size in enumerate(groupSizes): groups[size].append(i) if len(groups[size]) == size: result.append(groups[size]) groups[size] = [] return result"},{"prompt":"Given an `m x n` `matrix`, return _a new matrix_ `answer` _where_ `answer[row][col]` _is the_ _**rank** of_ `matrix[row][col]`. The **rank** is an **integer** that represents how large an element is compared to other elements. It is calculated using the following rules: * The rank is an integer starting from `1`. * If two elements `p` and `q` are in the **same row or column**, then: * If `p < q` then `rank(p) < rank(q)` * If `p == q` then `rank(p) == rank(q)` * If `p > q` then `rank(p) > rank(q)` * The **rank** should be as **small** as possible. The test cases are generated so that `answer` is unique under the given rules. **Example 1:** **Input:** matrix = [[1,2],[3,4]] **Output:** [[1,2],[2,3]] **Explanation:** The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column. The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1. The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1. The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2. **Example 2:** **Input:** matrix = [[7,7],[7,7]] **Output:** [[1,1],[1,1]] **Example 3:** **Input:** matrix = [[20,21,14],[19,4,19],[22,47,24],[19,4,19]] **Output:** [[4,2,3],[1,3,4],[5,1,6],[1,3,4]] **Constraints:** * `m == matrix.length` * `n == matrix[i].length` * `1 <= m, n <= 500` * `109 <= matrix[row][col] <= 109`","completion":"def numSplits(s: str) -> int: left_set, right_set = set(), set() left, right = [0] * len(s), [0] * len(s) count = 0 for i, char in enumerate(s): left_set.add(char) left[i] = len(left_set) for i in range(len(s) - 1, 0, -1): right_set.add(s[i]) right[i] = len(right_set) for i in range(len(s) - 1): if left[i] == right[i + 1]: count += 1 return count"},{"prompt":"A tree rooted at node 0 is given as follows: * The number of nodes is `nodes`; * The value of the `ith` node is `value[i]`; * The parent of the `ith` node is `parent[i]`. Remove every subtree whose sum of values of nodes is zero. Return _the number of the remaining nodes in the tree_. **Example 1:** **Input:** nodes = 7, parent = [1,0,0,1,2,2,2], value = [1,2,4,0,2,1,1] **Output:** 2 **Example 2:** **Input:** nodes = 7, parent = [1,0,0,1,2,2,2], value = [1,2,4,0,2,1,2] **Output:** 6 **Constraints:** * `1 <= nodes <= 104` * `parent.length == nodes` * `0 <= parent[i] <= nodes 1` * `parent[0] == 1` which indicates that `0` is the root. * `value.length == nodes` * `105 <= value[i] <= 105` * The given input is **guaranteed** to represent a **valid tree**.","completion":"def countSmallerFrequencies(words, queries): freqWords = [word.count(min(word)) for word in words] ans = [] for query in queries: freqQuery = query.count(min(query)) ans.append(sum(f > freqQuery for f in freqWords)) return ans"},{"prompt":"There are `n` cities numbered from `0` to `n1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`. Return the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number. Notice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges\' weights along that path. **Example 1:** **Input:** n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 **Output:** 3 **Explanation:** The figure above describes the graph. The neighboring cities at a distanceThreshold = 4 for each city are: City 0 > [City 1, City 2] City 1 > [City 0, City 2, City 3] City 2 > [City 0, City 1, City 3] City 3 > [City 1, City 2] Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number. **Example 2:** **Input:** n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 **Output:** 0 **Explanation:** The figure above describes the graph. The neighboring cities at a distanceThreshold = 2 for each city are: City 0 > [City 1] City 1 > [City 0, City 4] City 2 > [City 3, City 4] City 3 > [City 2, City 4] City 4 > [City 1, City 2, City 3] The city 0 has 1 neighboring city at a distanceThreshold = 2. **Constraints:** * `2 <= n <= 100` * `1 <= edges.length <= n * (n 1) / 2` * `edges[i].length == 3` * `0 <= fromi < toi < n` * `1 <= weighti, distanceThreshold <= 10^4` * All pairs `(fromi, toi)` are distinct.","completion":"def findTheCity(n, edges, distanceThreshold): distance = [[1e5] * n for _ in range(n)] for edge in edges: distance[edge[0]][edge[1]] = edge[2] distance[edge[1]][edge[0]] = edge[2] for i in range(n): distance[i][i] = 0 for k in range(n): for i in range(n): for j in range(n): distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]) res, minReachable = 0, n for i in range(n): reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold) if reachable <= minReachable: minReachable = reachable res = i return res"},{"prompt":"On a campus represented on the XY plane, there are `n` workers and `m` bikes, with `n <= m`. You are given an array `workers` of length `n` where `workers[i] = [xi, yi]` is the position of the `ith` worker. You are also given an array `bikes` of length `m` where `bikes[j] = [xj, yj]` is the position of the `jth` bike. All the given positions are **unique**. Assign a bike to each worker. Among the available bikes and workers, we choose the `(workeri, bikej)` pair with the shortest **Manhattan distance** between each other and assign the bike to that worker. If there are multiple `(workeri, bikej)` pairs with the same shortest **Manhattan distance**, we choose the pair with **the smallest worker index**. If there are multiple ways to do that, we choose the pair with **the smallest bike index**. Repeat this process until there are no available workers. Return _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the index (**0indexed**) of the bike that the_ `ith` _worker is assigned to_. The **Manhattan distance** between two points `p1` and `p2` is `Manhattan(p1, p2) = |p1.x p2.x| + |p1.y p2.y|`. **Example 1:** **Input:** workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]] **Output:** [1,0] **Explanation:** Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0]. **Example 2:** **Input:** workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]] **Output:** [0,2,1] **Explanation:** Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1]. **Constraints:** * `n == workers.length` * `m == bikes.length` * `1 <= n <= m <= 1000` * `workers[i].length == bikes[j].length == 2` * `0 <= xi, yi < 1000` * `0 <= xj, yj < 1000` * All worker and bike locations are **unique**.","completion":"def num_dup_digits_at_most_n(n): count = 0 for i in range(1, n + 1): digits = set() num = i while num != 0: digit = num % 10 if digit in digits: count += 1 break else: digits.add(digit) num //= 10 return count"},{"prompt":"There is a bag that consists of items, each item has a number `1`, `0`, or `1` written on it. You are given four **nonnegative** integers `numOnes`, `numZeros`, `numNegOnes`, and `k`. The bag initially contains: * `numOnes` items with `1`s written on them. * `numZeroes` items with `0`s written on them. * `numNegOnes` items with `1`s written on them. We want to pick exactly `k` items among the available items. Return _the **maximum** possible sum of numbers written on the items_. **Example 1:** **Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2 **Output:** 2 **Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2. It can be proven that 2 is the maximum possible sum. **Example 2:** **Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4 **Output:** 3 **Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3. It can be proven that 3 is the maximum possible sum. **Constraints:** * `0 <= numOnes, numZeros, numNegOnes <= 50` * `0 <= k <= numOnes + numZeros + numNegOnes`","completion":"def max_sum(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int: max_sum = 0 for i in range(k + 1): ones = min(i, numOnes) neg_ones = min(k - i, numNegOnes) max_sum = max(max_sum, ones - neg_ones) return max_sum"},{"prompt":"A **stepping number** is an integer such that all of its adjacent digits have an absolute difference of exactly `1`. * For example, `321` is a **stepping number** while `421` is not. Given two integers `low` and `high`, return _a sorted list of all the **stepping numbers** in the inclusive range_ `[low, high]`. **Example 1:** **Input:** low = 0, high = 21 **Output:** [0,1,2,3,4,5,6,7,8,9,10,12,21] **Example 2:** **Input:** low = 10, high = 15 **Output:** [10,12] **Constraints:** * `0 <= low <= high <= 2 * 109`","completion":"def countSteppingNumbers(low, high): results = [] for i in range(low, high+1): prev = -1 j = i is_stepping = True while j > 0: digit = j % 10 if prev != -1 and abs(prev - digit) != 1: is_stepping = False break prev = digit j //= 10 if is_stepping: results.append(i) return results"},{"prompt":"You are given an integer array `arr`. You can choose a set of integers and remove all the occurrences of these integers in the array. Return _the minimum size of the set so that **at least** half of the integers of the array are removed_. **Example 1:** **Input:** arr = [3,3,3,3,5,5,5,2,2,7] **Output:** 2 **Explanation:** Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array). Possible sets of size 2 are {3,5},{3,2},{5,2}. Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array. **Example 2:** **Input:** arr = [7,7,7,7,7,7] **Output:** 1 **Explanation:** The only possible set you can choose is {7}. This will make the new array empty. **Constraints:** * `2 <= arr.length <= 105` * `arr.length` is even. * `1 <= arr[i] <= 105`","completion":"from collections import Counter import heapq def minSetSize(arr): freq_map = Counter(arr) max_heap = [-cnt for cnt in freq_map.values()] heapq.heapify(max_heap) half = len(arr) // 2 cnt = 0 size = 0 while size < half: size -= heapq.heappop(max_heap) cnt += 1 return cnt"},{"prompt":"There is a restaurant with a single chef. You are given an array `customers`, where `customers[i] = [arrivali, timei]:` * `arrivali` is the arrival time of the `ith` customer. The arrival times are sorted in **nondecreasing** order. * `timei` is the time needed to prepare the order of the `ith` customer. When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers **in the order they were given in the input**. Return _the **average** waiting time of all customers_. Solutions within `105` from the actual answer are considered accepted. **Example 1:** **Input:** customers = [[1,2],[2,5],[4,3]] **Output:** 5.00000 **Explanation:** 1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 1 = 2. 2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 2 = 6. 3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 4 = 7. So the average waiting time = (2 + 6 + 7) / 3 = 5. **Example 2:** **Input:** customers = [[5,2],[5,4],[10,3],[20,1]] **Output:** 3.25000 **Explanation:** 1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 5 = 2. 2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 5 = 6. 3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 10 = 4. 4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 20 = 1. So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25. **Constraints:** * `1 <= customers.length <= 105` * `1 <= arrivali, timei <= 104` * `arrivali <= arrivali+1`","completion":"def maxNumEdgesToRemove(n, edges): def find(u): if parent[u] == u: return u else: parent[u] = find(parent[u]) return parent[u] def unite(u, v): u = find(u) v = find(v) if u != v: parent[u] = v return True return False parent = list(range(2 * n + 1)) ct = [0, 0] both = n - 1 edges.sort(reverse=True) for edge in edges: type, u, v = edge if type == 3 and unite(u, v + n): both -= 1 if both == 0: break for type in range(1, 3): for edge in edges: a, u, v = edge if a == type and unite(u, v + n): ct[type - 1] += 1 if both + ct[type - 1] < n - 1: return -1 return ct[0] + ct[1] - n + 1"},{"prompt":"You are given `coordinates`, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference. Return `true` _if the square is white, and_ `false` _if the square is black_. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second. **Example 1:** **Input:** coordinates = a1 **Output:** false **Explanation:** From the chessboard above, the square with coordinates a1 is black, so return false. **Example 2:** **Input:** coordinates = h3 **Output:** true **Explanation:** From the chessboard above, the square with coordinates h3 is white, so return true. **Example 3:** **Input:** coordinates = c7 **Output:** false **Constraints:** * `coordinates.length == 2` * `\'a\' <= coordinates[0] <= \'h\'` * `\'1\' <= coordinates[1] <= \'8\'`","completion":"def reformat_number(number): cleaned_number = \'\'.join(c for c in number if c.isdigit()) blocks = [] n = len(cleaned_number) i = 0 while i < n: if n - i == 2 or n - i == 4: blocks.append(cleaned_number[i:i + 2]) i += 2 else: blocks.append(cleaned_number[i:i + 3]) i += 3 return \'-\'.join(blocks)"},{"prompt":"There is an undirected tree with `n` nodes labeled from `0` to `n 1`, rooted at node `0`. You are given a 2D integer array `edges` of length `n 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. At every node `i`, there is a gate. You are also given an array of even integers `amount`, where `amount[i]` represents: * the price needed to open the gate at node `i`, if `amount[i]` is negative, or, * the cash reward obtained on opening the gate at node `i`, otherwise. The game goes on as follows: * Initially, Alice is at node `0` and Bob is at node `bob`. * At every second, Alice and Bob **each** move to an adjacent node. Alice moves towards some **leaf node**, while Bob moves towards node `0`. * For **every** node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that: * If the gate is **already open**, no price will be required, nor will there be any cash reward. * If Alice and Bob reach the node **simultaneously**, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each. * If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are **independent** of each other. Return _the **maximum** net income Alice can have if she travels towards the optimal leaf node._ **Example 1:** **Input:** edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [2,4,2,4,6] **Output:** 6 **Explanation:** The above diagram represents the given tree. The game goes as follows: Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes. Alice\'s net income is now 2. Both Alice and Bob move to node 1. Since they reach here simultaneously, they open the gate together and share the reward. Alice\'s net income becomes 2 + (4 / 2) = 0. Alice moves on to node 3. Since Bob already opened its gate, Alice\'s income remains unchanged. Bob moves on to node 0, and stops moving. Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6. Now, neither Alice nor Bob can make any further moves, and the game ends. It is not possible for Alice to get a higher net income. **Example 2:** **Input:** edges = [[0,1]], bob = 1, amount = [7280,2350] **Output:** 7280 **Explanation:** Alice follows the path 0>1 whereas Bob follows the path 1>0. Thus, Alice opens the gate at node 0 only. Hence, her net income is 7280. **Constraints:** * `2 <= n <= 105` * `edges.length == n 1` * `edges[i].length == 2` * `0 <= ai, bi < n` * `ai != bi` * `edges` represents a valid tree. * `1 <= bob < n` * `amount.length == n` * `amount[i]` is an **even** integer in the range `[104, 104]`.","completion":"from collections import defaultdict def dfs(node, parent, bob, time, alice_income, res, amount, tree): if time < bob or amount[node] >= 0: alice_income += amount[node] else: alice_income += amount[node] // 2 amount[node] = 0 is_leaf = True for child in tree[node]: if child != parent: is_leaf = False dfs(child, node, bob, time + 1, alice_income, res, amount, tree) if is_leaf: res[0] = max(res[0], alice_income) def maxNetIncome(edges, bob, amount): tree = defaultdict(list) for edge in edges: tree[edge[0]].append(edge[1]) tree[edge[1]].append(edge[0]) res = [-100000] dfs(0, -1, bob, 0, 0, res, amount, tree) return res[0]"},{"prompt":"Given an integer array `arr` of **distinct** integers and an integer `k`. A game will be played between the first two elements of the array (i.e. `arr[0]` and `arr[1]`). In each round of the game, we compare `arr[0]` with `arr[1]`, the larger integer wins and remains at position `0`, and the smaller integer moves to the end of the array. The game ends when an integer wins `k` consecutive rounds. Return _the integer which will win the game_. It is **guaranteed** that there will be a winner of the game. **Example 1:** **Input:** arr = [2,1,3,5,4,6,7], k = 2 **Output:** 5 **Explanation:** Let\'s see the rounds of the game: Round | arr | winner | win_count 1 | [2,1,3,5,4,6,7] | 2 | 1 2 | [2,3,5,4,6,7,1] | 3 | 1 3 | [3,5,4,6,7,1,2] | 5 | 1 4 | [5,4,6,7,1,2,3] | 5 | 2 So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games. **Example 2:** **Input:** arr = [3,2,1], k = 10 **Output:** 3 **Explanation:** 3 will win the first 10 rounds consecutively. **Constraints:** * `2 <= arr.length <= 105` * `1 <= arr[i] <= 106` * `arr` contains **distinct** integers. * `1 <= k <= 109`","completion":"def number_of_ways(n, m, k, mod=1_000_000_007): if k > 1: result = 1 for _ in range(n): result = (result * m) % mod return result return 1 if n % 2 == 0 else m"},{"prompt":"There are `n` dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. You are given a string `dominoes` representing the initial state where: * `dominoes[i] = \'L\'`, if the `ith` domino has been pushed to the left, * `dominoes[i] = \'R\'`, if the `ith` domino has been pushed to the right, and * `dominoes[i] = \'.\'`, if the `ith` domino has not been pushed. Return _a string representing the final state_. **Example 1:** **Input:** dominoes = RR.L **Output:** RR.L **Explanation:** The first domino expends no additional force on the second domino. **Example 2:** **Input:** dominoes = .L.R...LR..L.. **Output:** LL.RR.LLRRLL.. **Constraints:** * `n == dominoes.length` * `1 <= n <= 105` * `dominoes[i]` is either `\'L\'`, `\'R\'`, or `\'.\'`.","completion":"def pushDominoes(dominoes: str) -> str: n = len(dominoes) forces = [0] * n force = 0 for i in range(n): if dominoes[i] == \'R\': force = n elif dominoes[i] == \'L\': force = 0 else: force = max(force - 1, 0) forces[i] += force force = 0 for i in range(n - 1, -1, -1): if dominoes[i] == \'L\': force = n elif dominoes[i] == \'R\': force = 0 else: force = max(force - 1, 0) forces[i] -= force return \\"\\".join([\'R\' if f > 0 else \'L\' if f < 0 else \'.\' for f in forces])"},{"prompt":"You are given an integer array `ranks` representing the **ranks** of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank `r` can repair n cars in `r * n2` minutes. You are also given an integer `cars` representing the total number of cars waiting in the garage to be repaired. Return _the **minimum** time taken to repair all the cars._ **Note:** All the mechanics can repair the cars simultaneously. **Example 1:** **Input:** ranks = [4,2,3,1], cars = 10 **Output:** 16 **Explanation:** The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes. The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes. The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes. The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes. It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​ **Example 2:** **Input:** ranks = [5,1,8], cars = 6 **Output:** 16 **Explanation:** The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes. The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes. The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes. It can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​ **Constraints:** * `1 <= ranks.length <= 105` * `1 <= ranks[i] <= 100` * `1 <= cars <= 106`","completion":"def min_time_to_repair(ranks, cars): ranks.sort() low, high = 0, 100 * cars * cars while low < high: mid = low + (high - low) // 2 total_cars_repaired = 0 for rank in ranks: cars_repaired = min(cars, mid // (rank * rank)) total_cars_repaired += cars_repaired if total_cars_repaired >= cars: break if total_cars_repaired >= cars: high = mid else: low = mid + 1 return low"},{"prompt":"You are given a positive integer `n`. Each digit of `n` has a sign according to the following rules: * The **most significant digit** is assigned a **positive** sign. * Each other digit has an opposite sign to its adjacent digits. Return _the sum of all digits with their corresponding sign_. **Example 1:** **Input:** n = 521 **Output:** 4 **Explanation:** (+5) + (2) + (+1) = 4. **Example 2:** **Input:** n = 111 **Output:** 1 **Explanation:** (+1) + (1) + (+1) = 1. **Example 3:** **Input:** n = 886996 **Output:** 0 **Explanation:** (+8) + (8) + (+6) + (9) + (+9) + (6) = 0. **Constraints:** * `1 <= n <= 109` .spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; fontsize:150%; fontweight: bold; color:#000000; backgroundcolor:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {webkittransition: all 0s ease;moztransition: margin 0s ease;otransition: all 0s ease;transition: margin 0s ease;} .spoilerbutton[value=Show Message] + .spoiler > div {margintop:500%;} .spoilerbutton[value=Hide Message] + .spoiler {padding:5px;}","completion":"def sum_of_digits(n: int) -> int: total = 0 positive = True while n > 0: digit = n % 10 n //= 10 if positive: total += digit else: total -= digit positive = not positive return total"},{"prompt":"You are given a **0indexed** array `nums` of `n` integers, and an integer `k`. The **kradius average** for a subarray of `nums` **centered** at some index `i` with the **radius** `k` is the average of **all** elements in `nums` between the indices `i k` and `i + k` (**inclusive**). If there are less than `k` elements before **or** after the index `i`, then the **kradius average** is `1`. Build and return _an array_ `avgs` _of length_ `n` _where_ `avgs[i]` _is the **kradius average** for the subarray centered at index_ `i`. The **average** of `x` elements is the sum of the `x` elements divided by `x`, using **integer division**. The integer division truncates toward zero, which means losing its fractional part. * For example, the average of four elements `2`, `3`, `1`, and `5` is `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75`, which truncates to `2`. **Example 1:** **Input:** nums = [7,4,3,9,1,8,5,2,6], k = 3 **Output:** [1,1,1,5,4,4,1,1,1] **Explanation:** avg[0], avg[1], and avg[2] are 1 because there are less than k elements **before** each index. The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37. Using **integer division**, avg[3] = 37 / 7 = 5. For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4. For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4. avg[6], avg[7], and avg[8] are 1 because there are less than k elements **after** each index. **Example 2:** **Input:** nums = [100000], k = 0 **Output:** [100000] **Explanation:** The sum of the subarray centered at index 0 with radius 0 is: 100000. avg[0] = 100000 / 1 = 100000. **Example 3:** **Input:** nums = [8], k = 100000 **Output:** [1] **Explanation:** avg[0] is 1 because there are less than k elements before and after index 0. **Constraints:** * `n == nums.length` * `1 <= n <= 105` * `0 <= nums[i], k <= 105`","completion":"from heapq import heappush, heappop MODULO = 1000000007 def countPaths(n, roads): adj_list = [[] for _ in range(n)] for u, v, time in roads: adj_list[u].append((v, time)) adj_list[v].append((u, time)) dist = [float(\'inf\')] * n dist[0] = 0 count = [0] * n count[0] = 1 pq = [(0, 0)] while pq: distance, node = heappop(pq) if distance > dist[node]: continue for next_node, edge_distance in adj_list[node]: if distance + edge_distance > dist[next_node]: continue if distance + edge_distance == dist[next_node]: count[next_node] = (count[next_node] + count[node]) % MODULO else: count[next_node] = count[node] dist[next_node] = distance + edge_distance heappush(pq, (dist[next_node], next_node)) return count[n - 1]"},{"prompt":"You have a video sharing platform where users can upload and delete videos. Each `video` is a **string** of digits, where the `ith` digit of the string represents the content of the video at minute `i`. For example, the first digit represents the content at minute `0` in the video, the second digit represents the content at minute `1` in the video, and so on. Viewers of videos can also like and dislike videos. Internally, the platform keeps track of the **number of views, likes, and dislikes** on each video. When a video is uploaded, it is associated with the smallest available integer `videoId` starting from `0`. Once a video is deleted, the `videoId` associated with that video can be reused for another video. Implement the `VideoSharingPlatform` class: * `VideoSharingPlatform()` Initializes the object. * `int upload(String video)` The user uploads a `video`. Return the `videoId` associated with the video. * `void remove(int videoId)` If there is a video associated with `videoId`, remove the video. * `String watch(int videoId, int startMinute, int endMinute)` If there is a video associated with `videoId`, increase the number of views on the video by `1` and return the substring of the video string starting at `startMinute` and ending at `min(endMinute, video.length 1``)` (**inclusive**). Otherwise, return `1 `. * `void like(int videoId)` Increases the number of likes on the video associated with `videoId` by `1` if there is a video associated with `videoId`. * `void dislike(int videoId)` Increases the number of dislikes on the video associated with `videoId` by `1` if there is a video associated with `videoId`. * `int[] getLikesAndDislikes(int videoId)` Return a **0indexed** integer array `values` of length `2` where `values[0]` is the number of likes and `values[1]` is the number of dislikes on the video associated with `videoId`. If there is no video associated with `videoId`, return `[1]`. * `int getViews(int videoId)` Return the number of views on the video associated with `videoId`, if there is no video associated with `videoId`, return `1`. **Example 1:** **Input** [ VideoSharingPlatform , upload , upload , remove , remove , upload , watch , watch , like , dislike , dislike , getLikesAndDislikes , getViews ] [[], [ 123 ], [ 456 ], [4], [0], [ 789 ], [1, 0, 5], [1, 0, 1], [1], [1], [1], [1], [1]] **Output** [null, 0, 1, null, null, 0, 456 , 45 , null, null, null, [1, 2], 2] **Explanation** VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform(); videoSharingPlatform.upload( 123 ); // The smallest available videoId is 0, so return 0. videoSharingPlatform.upload( 456 ); // The smallest available `videoId` is 1, so return 1. videoSharingPlatform.remove(4); // There is no video associated with videoId 4, so do nothing. videoSharingPlatform.remove(0); // Remove the video associated with videoId 0. videoSharingPlatform.upload( 789 ); // Since the video associated with videoId 0 was deleted, // 0 is the smallest available `videoId`, so return 0. videoSharingPlatform.watch(1, 0, 5); // The video associated with videoId 1 is 456 . // The video from minute 0 to min(5, 3 1) = 2 is 456 , so return 453 . videoSharingPlatform.watch(1, 0, 1); // The video associated with videoId 1 is 456 . // The video from minute 0 to min(1, 3 1) = 1 is 45 , so return 45 . videoSharingPlatform.like(1); // Increase the number of likes on the video associated with videoId 1. videoSharingPlatform.dislike(1); // Increase the number of dislikes on the video associated with videoId 1. videoSharingPlatform.dislike(1); // Increase the number of dislikes on the video associated with videoId 1. videoSharingPlatform.getLikesAndDislikes(1); // There is 1 like and 2 dislikes on the video associated with videoId 1, so return [1, 2]. videoSharingPlatform.getViews(1); // The video associated with videoId 1 has 2 views, so return 2. **Example 2:** **Input** [ VideoSharingPlatform , remove , watch , like , dislike , getLikesAndDislikes , getViews ] [[], [0], [0, 0, 1], [0], [0], [0], [0]] **Output** [null, null, 1 , null, null, [1], 1] **Explanation** VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform(); videoSharingPlatform.remove(0); // There is no video associated with videoId 0, so do nothing. videoSharingPlatform.watch(0, 0, 1); // There is no video associated with videoId 0, so return 1 . videoSharingPlatform.like(0); // There is no video associated with videoId 0, so do nothing. videoSharingPlatform.dislike(0); // There is no video associated with videoId 0, so do nothing. videoSharingPlatform.getLikesAndDislikes(0); // There is no video associated with videoId 0, so return [1]. videoSharingPlatform.getViews(0); // There is no video associated with videoId 0, so return 1. **Constraints:** * `1 <= video.length <= 105` * The sum of `video.length` over all calls to `upload` does not exceed `105` * `video` consists of digits. * `0 <= videoId <= 105` * `0 <= startMinute < endMinute < 105` * `startMinute < video.length` * The sum of `endMinute startMinute` over all calls to `watch` does not exceed `105`. * At most `105` calls **in total** will be made to all functions.","completion":"def isValidMatrix(matrix): n = len(matrix) for i in range(n): row = set(matrix[i]) col = set(matrix[j][i] for j in range(n)) if len(row) != n or len(col) != n: return False return True"},{"prompt":"You are given an `m x n` matrix `maze` (**0indexed**) with empty cells (represented as `\'.\'`) and walls (represented as `\'+\'`). You are also given the `entrance` of the maze, where `entrance = [entrancerow, entrancecol]` denotes the row and column of the cell you are initially standing at. In one step, you can move one cell **up**, **down**, **left**, or **right**. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the **nearest exit** from the `entrance`. An **exit** is defined as an **empty cell** that is at the **border** of the `maze`. The `entrance` **does not count** as an exit. Return _the **number of steps** in the shortest path from the_ `entrance` _to the nearest exit, or_ `1` _if no such path exists_. **Example 1:** **Input:** maze = [[ + , + , . , + ],[ . , . , . , + ],[ + , + , + , . ]], entrance = [1,2] **Output:** 1 **Explanation:** There are 3 exits in this maze at [1,0], [0,2], and [2,3]. Initially, you are at the entrance cell [1,2]. You can reach [1,0] by moving 2 steps left. You can reach [0,2] by moving 1 step up. It is impossible to reach [2,3] from the entrance. Thus, the nearest exit is [0,2], which is 1 step away. **Example 2:** **Input:** maze = [[ + , + , + ],[ . , . , . ],[ + , + , + ]], entrance = [1,0] **Output:** 2 **Explanation:** There is 1 exit in this maze at [1,2]. [1,0] does not count as an exit since it is the entrance cell. Initially, you are at the entrance cell [1,0]. You can reach [1,2] by moving 2 steps right. Thus, the nearest exit is [1,2], which is 2 steps away. **Example 3:** **Input:** maze = [[ . , + ]], entrance = [0,0] **Output:** 1 **Explanation:** There are no exits in this maze. **Constraints:** * `maze.length == m` * `maze[i].length == n` * `1 <= m, n <= 100` * `maze[i][j]` is either `\'.\'` or `\'+\'`. * `entrance.length == 2` * `0 <= entrancerow < m` * `0 <= entrancecol < n` * `entrance` will always be an empty cell.","completion":"from collections import deque def nearest_exit(maze, entrance): m, n = len(maze), len(maze[0]) moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] q = deque([tuple(entrance)]) steps = -1 while q: steps += 1 for _ in range(len(q)): r, c = q.popleft() if maze[r][c] == \'+\': continue if r == 0 or r == m-1 or c == 0 or c == n-1: if r != entrance[0] or c != entrance[1]: return steps maze[r][c] = \'+\' for dr, dc in moves: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n: q.append((nr, nc)) return -1"},{"prompt":"You are playing a game of tag with your friends. In tag, people are divided into two teams: people who are it , and people who are not it . The people who are it want to catch as many people as possible who are not it . You are given a **0indexed** integer array `team` containing only zeros (denoting people who are **not** it ) and ones (denoting people who are it ), and an integer `dist`. A person who is it at index `i` can catch any **one** person whose index is in the range `[i dist, i + dist]` (**inclusive**) and is **not** it . Return _the **maximum** number of people that the people who are it can catch_. **Example 1:** **Input:** team = [0,1,0,1,0], dist = 3 **Output:** 2 **Explanation:** The person who is it at index 1 can catch people in the range [idist, i+dist] = [13, 1+3] = [2, 4]. They can catch the person who is not it at index 2. The person who is it at index 3 can catch people in the range [idist, i+dist] = [33, 3+3] = [0, 6]. They can catch the person who is not it at index 0. The person who is not it at index 4 will not be caught because the people at indices 1 and 3 are already catching one person. **Example 2:** **Input:** team = [1], dist = 1 **Output:** 0 **Explanation:** There are no people who are not it to catch. **Example 3:** **Input:** team = [0], dist = 1 **Output:** 0 **Explanation:** There are no people who are it to catch people. **Constraints:** * `1 <= team.length <= 105` * `0 <= team[i] <= 1` * `1 <= dist <= team.length`","completion":"def minimum_xor_sum(nums1, nums2): nums2.sort() xor_sum = 0 for i in range(len(nums1)): xor_sum += nums1[i] ^ nums2[i] return xor_sum"},{"prompt":"An integer has **monotone increasing digits** if and only if each pair of adjacent digits `x` and `y` satisfy `x <= y`. Given an integer `n`, return _the largest number that is less than or equal to_ `n` _with **monotone increasing digits**_. **Example 1:** **Input:** n = 10 **Output:** 9 **Example 2:** **Input:** n = 1234 **Output:** 1234 **Example 3:** **Input:** n = 332 **Output:** 299 **Constraints:** * `0 <= n <= 109`","completion":"def monotoneIncreasingDigits(n: int) -> int: n_str = [c for c in str(n)] i = len(n_str) - 1 while i > 0: if n_str[i] < n_str[i - 1]: n_str[i - 1] = chr(ord(n_str[i - 1]) - 1) for j in range(i, len(n_str)): n_str[j] = \'9\' i -= 1 return int(\'\'.join(n_str))"},{"prompt":"There is a city composed of `n x n` blocks, where each block contains a single building shaped like a vertical square prism. You are given a **0indexed** `n x n` integer matrix `grid` where `grid[r][c]` represents the **height** of the building located in the block at row `r` and column `c`. A city\'s **skyline** is the outer contour formed by all the building when viewing the side of the city from a distance. The **skyline** from each cardinal direction north, east, south, and west may be different. We are allowed to increase the height of **any number of buildings by any amount** (the amount can be different per building). The height of a `0`height building can also be increased. However, increasing the height of a building should **not** affect the city\'s **skyline** from any cardinal direction. Return _the **maximum total sum** that the height of the buildings can be increased by **without** changing the city\'s **skyline** from any cardinal direction_. **Example 1:** **Input:** grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] **Output:** 35 **Explanation:** The building heights are shown in the center of the above image. The skylines when viewed from each cardinal direction are drawn in red. The grid after increasing the height of buildings without affecting skylines is: gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] **Example 2:** **Input:** grid = [[0,0,0],[0,0,0],[0,0,0]] **Output:** 0 **Explanation:** Increasing the height of any building will result in the skyline changing. **Constraints:** * `n == grid.length` * `n == grid[r].length` * `2 <= n <= 50` * `0 <= grid[r][c] <= 100`","completion":"def custom_sort_string(order, s): return \'\'.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))"},{"prompt":"You are given an integer array `nums` and a **positive** integer `k`. The **frequency score** of an array is the sum of the **distinct** values in the array raised to the power of their **frequencies**, taking the sum **modulo** `109 + 7`. * For example, the frequency score of the array `[5,4,5,7,4,4]` is `(43 + 52 + 71) modulo (109 + 7) = 96`. Return _the **maximum** frequency score of a **subarray** of size_ `k` _in_ `nums`. You should maximize the value under the modulo and not the actual value. A **subarray** is a contiguous part of an array. **Example 1:** **Input:** nums = [1,1,1,2,1,2], k = 3 **Output:** 5 **Explanation:** The subarray [2,1,2] has a frequency score equal to 5. It can be shown that it is the maximum frequency score we can have. **Example 2:** **Input:** nums = [1,1,1,1,1,1], k = 4 **Output:** 1 **Explanation:** All the subarrays of length 4 have a frequency score equal to 1. **Constraints:** * `1 <= k <= nums.length <= 105` * `1 <= nums[i] <= 106`","completion":"def maxFrequencyScore(nums, k): n = len(nums) right = 0 count = 0 max_score = 0 score = 0 freq_map = {} for left in range(n): while right < n and count < k: score = (score + nums[right] * freq_map.get(nums[right], 0)) % 1000000007 freq_map[nums[right]] = freq_map.get(nums[right], 0) + 1 count += 1 right += 1 max_score = max(max_score, score) if count == k: score -= nums[left] * (freq_map[nums[left]] - 1) freq_map[nums[left]] -= 1 count -= 1 return max_score"},{"prompt":"Given two numbers, `hour` and `minutes`, return _the smaller angle (in degrees) formed between the_ `hour` _and the_ `minute` _hand_. Answers within `105` of the actual value will be accepted as correct. **Example 1:** **Input:** hour = 12, minutes = 30 **Output:** 165 **Example 2:** **Input:** hour = 3, minutes = 30 **Output:** 75 **Example 3:** **Input:** hour = 3, minutes = 15 **Output:** 7.5 **Constraints:** * `1 <= hour <= 12` * `0 <= minutes <= 59`","completion":"def maxEqualFreq(nums): count, freq = {}, {} max_len, max_freq = 0, 0 for i, num in enumerate(nums): count[num] = count.get(num, 0) + 1 freq[count[num] - 1] = freq.get(count[num] - 1, 0) - 1 freq[count[num]] = freq.get(count[num], 0) + 1 max_freq = max(max_freq, count[num]) if max_freq * (i + 1) == i or max_freq * (freq.get(max_freq - 1, 0) + 1) + (max_freq - 1) * freq.get(max_freq - 1, 0) == i: max_len = i + 1 return max_len"},{"prompt":"There are several cards **arranged in a row**, and each card has an associated number of points. The points are given in the integer array `cardPoints`. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly `k` cards. Your score is the sum of the points of the cards you have taken. Given the integer array `cardPoints` and the integer `k`, return the _maximum score_ you can obtain. **Example 1:** **Input:** cardPoints = [1,2,3,4,5,6,1], k = 3 **Output:** 12 **Explanation:** After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. **Example 2:** **Input:** cardPoints = [2,2,2], k = 2 **Output:** 4 **Explanation:** Regardless of which two cards you take, your score will always be 4. **Example 3:** **Input:** cardPoints = [9,7,7,9,7,7,9], k = 7 **Output:** 55 **Explanation:** You have to take all the cards. Your score is the sum of points of all cards. **Constraints:** * `1 <= cardPoints.length <= 105` * `1 <= cardPoints[i] <= 104` * `1 <= k <= cardPoints.length` 1. The number of unique characters in the substring must not exceed k. 2. The substring must not contain more than one instance of the same character. 3. The length of the substring must not exceed the length of the original string.","completion":"def max_substring_occurrences(s: str, k: int) -> int: freq = {} res = 0 for c in s: freq[c] = freq.get(c, 0) + 1 if len(freq) <= k: res = max(res, freq[c]) return 0 if len(freq) > k else res"},{"prompt":"The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers `0` and `1` respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a **stack**. At each step: * If the student at the front of the queue **prefers** the sandwich on the top of the stack, they will **take it** and leave the queue. * Otherwise, they will **leave it** and go to the queue\'s end. This continues until none of the queue students want to take the top sandwich and are thus unable to eat. You are given two integer arrays `students` and `sandwiches` where `sandwiches[i]` is the type of the `i​​​​​​th` sandwich in the stack (`i = 0` is the top of the stack) and `students[j]` is the preference of the `j​​​​​​th` student in the initial queue (`j = 0` is the front of the queue). Return _the number of students that are unable to eat._ **Example 1:** **Input:** students = [1,1,0,0], sandwiches = [0,1,0,1] **Output:** 0 **Explanation:** Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1]. Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1]. Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1]. Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0]. Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1]. Front student leaves the top sandwich and returns to the end of the line making students = [0,1]. Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1]. Front student takes the top sandwich and leaves the line making students = [] and sandwiches = []. Hence all students are able to eat. **Example 2:** **Input:** students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1] **Output:** 3 **Constraints:** * `1 <= students.length, sandwiches.length <= 100` * `students.length == sandwiches.length` * `sandwiches[i]` is `0` or `1`. * `students[i]` is `0` or `1`.","completion":"def min_time_to_remove_balloons(colors, neededTime): n = len(colors) INF = 10**9 dp = [[INF] * 26 for _ in range(n)] for color in range(26): if colors[0] != chr(ord(\'A\') + color): dp[0][color] = neededTime[0] for i in range(1, n): for color1 in range(26): for color2 in range(26): if color1 != color2 and colors[i] != chr(ord(\'A\') + color1): dp[i][color1] = min(dp[i][color1], dp[i-1][color2] + neededTime[i]) ans = INF for color in range(26): ans = min(ans, dp[n-1][color]) return ans"},{"prompt":"There are `n` buildings in a line. You are given an integer array `heights` of size `n` that represents the heights of the buildings in the line. The ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a **smaller** height. Return a list of indices **(0indexed)** of buildings that have an ocean view, sorted in increasing order. **Example 1:** **Input:** heights = [4,2,3,1] **Output:** [0,2,3] **Explanation:** Building 1 (0indexed) does not have an ocean view because building 2 is taller. **Example 2:** **Input:** heights = [4,3,2,1] **Output:** [0,1,2,3] **Explanation:** All the buildings have an ocean view. **Example 3:** **Input:** heights = [1,3,2,4] **Output:** [3] **Explanation:** Only building 3 has an ocean view. **Constraints:** * `1 <= heights.length <= 105` * `1 <= heights[i] <= 109`","completion":"import heapq def furthest_building(heights, bricks, ladders): min_heap = [] for i in range(len(heights) - 1): diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(min_heap, diff) if len(min_heap) > ladders: bricks -= heapq.heappop(min_heap) if bricks < 0: return i return len(heights) - 1"},{"prompt":"You are given two integer arrays of equal length `target` and `arr`. In one step, you can select any **nonempty subarray** of `arr` and reverse it. You are allowed to make any number of steps. Return `true` _if you can make_ `arr` _equal to_ `target` _or_ `false` _otherwise_. **Example 1:** **Input:** target = [1,2,3,4], arr = [2,4,1,3] **Output:** true **Explanation:** You can follow the next steps to convert arr to target: 1 Reverse subarray [2,4,1], arr becomes [1,4,2,3] 2 Reverse subarray [4,2], arr becomes [1,2,4,3] 3 Reverse subarray [4,3], arr becomes [1,2,3,4] There are multiple ways to convert arr to target, this is not the only way to do so. **Example 2:** **Input:** target = [7], arr = [7] **Output:** true **Explanation:** arr is equal to target without any reverses. **Example 3:** **Input:** target = [3,7,9], arr = [3,7,11] **Output:** false **Explanation:** arr does not have value 9 and it can never be converted to target. **Constraints:** * `target.length == arr.length` * `1 <= target.length <= 1000` * `1 <= target[i] <= 1000` * `1 <= arr[i] <= 1000`","completion":"def numberOfSubstrings(s: str) -> int: res, i, count = 0, 0, [0, 0, 0] for j, ch in enumerate(s): count[ord(ch) - ord(\'a\')] += 1 while count[0] > 0 and count[1] > 0 and count[2] > 0: count[ord(s[i]) - ord(\'a\')] -= 1 i += 1 res += i return res"},{"prompt":"An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image. You are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`. To perform a **flood fill**, consider the starting pixel, plus any pixels connected **4directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`. Return _the modified image after performing the flood fill_. **Example 1:** **Input:** image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2 **Output:** [[2,2,2],[2,2,0],[2,0,1]] **Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not 4directionally connected to the starting pixel. **Example 2:** **Input:** image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0 **Output:** [[0,0,0],[0,0,0]] **Explanation:** The starting pixel is already colored 0, so no changes are made to the image. **Constraints:** * `m == image.length` * `n == image[i].length` * `1 <= m, n <= 50` * `0 <= image[i][j], color < 216` * `0 <= sr < m` * `0 <= sc < n`","completion":"def floodFill(image, sr, sc, newColor): startColor = image[sr][sc] def fill(sr, sc): if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: return image[sr][sc] = newColor fill(sr - 1, sc) fill(sr + 1, sc) fill(sr, sc - 1) fill(sr, sc + 1) fill(sr, sc) return image"},{"prompt":"You are given a **0indexed** integer array `nums` and two integers `key` and `k`. A **kdistant index** is an index `i` of `nums` for which there exists at least one index `j` such that `|i j| <= k` and `nums[j] == key`. Return _a list of all kdistant indices sorted in **increasing order**_. **Example 1:** **Input:** nums = [3,4,9,1,3,9,5], key = 9, k = 1 **Output:** [1,2,3,4,5,6] **Explanation:** Here, `nums[2] == key` and `nums[5] == key. For index 0, |0 2| > k and |0 5| > k, so there is no j` where `|0 j| <= k` and `nums[j] == key. Thus, 0 is not a kdistant index. For index 1, |1 2| <= k and nums[2] == key, so 1 is a kdistant index. For index 2, |2 2| <= k and nums[2] == key, so 2 is a kdistant index. For index 3, |3 2| <= k and nums[2] == key, so 3 is a kdistant index. For index 4, |4 5| <= k and nums[5] == key, so 4 is a kdistant index. For index 5, |5 5| <= k and nums[5] == key, so 5 is a kdistant index. For index 6, |6 5| <= k and nums[5] == key, so 6 is a kdistant index.` Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. **Example 2:** **Input:** nums = [2,2,2,2,2], key = 2, k = 2 **Output:** [0,1,2,3,4] **Explanation:** For all indices i in nums, there exists some index j such that |i j| <= k and nums[j] == key, so every index is a kdistant index. Hence, we return [0,1,2,3,4]. **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i] <= 1000` * `key` is an integer from the array `nums`. * `1 <= k <= nums.length`","completion":"def can_fit_stamps(grid, stampHeight, stampWidth): m, n = len(grid), len(grid[0]) for i in range(m - stampHeight + 1): for j in range(n - stampWidth + 1): canFit = True for x in range(stampHeight): for y in range(stampWidth): if grid[i + x][j + y] == 1: canFit = False break if not canFit: break if canFit: return True return False"},{"prompt":"a string `s` of lowercase letters, these letters form consecutive groups of the same character. For example, a string like `s = abbxxxxzyy ` has the groups `a `, `bb `, `xxxx `, `z `, and `yy `. A group is identified by an interval `[start, end]`, where `start` and `end` denote the start and end indices (inclusive) of the group. In the above example, `xxxx ` has the interval `[3,6]`. A group is considered **large** if it has 3 or more characters. Return _the intervals of every **large** group sorted in **increasing order by start index**_. **Example 1:** **Input:** s = abbxxxxzzy **Output:** [[3,6]] **Explanation:** `xxxx is the only` large group with start index 3 and end index 6. **Example 2:** **Input:** s = abc **Output:** [] **Explanation:** We have groups a , b , and c , none of which are large groups. **Example 3:** **Input:** s = abcdddeeeeaabbbcd **Output:** [[3,5],[6,9],[12,14]] **Explanation:** The large groups are ddd , eeee , and bbb . **Constraints:** * `1 <= s.length <= 1000` * `s` contains lowercase English letters only.","completion":"from itertools import combinations def largestTriangleArea(points): return max(0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3))"},{"prompt":"You are given the string `croakOfFrogs`, which represents a combination of the string `croak ` from different frogs, that is, multiple frogs can croak at the same time, so multiple `croak ` are mixed. _Return the minimum number of_ different _frogs to finish all the croaks in the given string._ A valid `croak ` means a frog is printing five letters `\'c\'`, `\'r\'`, `\'o\'`, `\'a\'`, and `\'k\'` **sequentially**. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid `croak ` return `1`. **Example 1:** **Input:** croakOfFrogs = croakcroak **Output:** 1 **Explanation:** One frog yelling croak **** twice. **Example 2:** **Input:** croakOfFrogs = crcoakroak **Output:** 2 **Explanation:** The minimum number of frogs is two. The first frog could yell **cr**c**oak**roak . The second frog could yell later cr**c**oak**roak** . **Example 3:** **Input:** croakOfFrogs = croakcrook **Output:** 1 **Explanation:** The given string is an invalid combination of croak **** from different frogs. **Constraints:** * `1 <= croakOfFrogs.length <= 105` * `croakOfFrogs` is either `\'c\'`, `\'r\'`, `\'o\'`, `\'a\'`, or `\'k\'`.","completion":"def minNumberOfFrogs(croakOfFrogs: str) -> int: counter = [0] * 5 frogs = max_frogs = 0 for ch in croakOfFrogs: idx = \'croak\'.index(ch) counter[idx] += 1 if idx == 0: max_frogs = max(max_frogs, frogs + 1) frogs += 1 else: counter[idx - 1] -= 1 if counter[idx - 1] < 0: return -1 if idx == 4: frogs -= 1 return max_frogs if all(count == counter[0] for count in counter) else -1"},{"prompt":"On a **singlethreaded** CPU, we execute a program containing `n` functions. Each function has a unique ID between `0` and `n1`. Function calls are **stored in a [call stack](https://en.wikipedia.org/wiki/Call_stack)**: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is **the current function being executed**. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list `logs`, where `logs[i]` represents the `ith` log message formatted as a string `{function_id}:{ start | end }:{timestamp} `. For example, `0:start:3 ` means a function call with function ID `0` **started at the beginning** of timestamp `3`, and `1:end:2 ` means a function call with function ID `1` **ended at the end** of timestamp `2`. Note that a function can be called **multiple times, possibly recursively**. A function\'s **exclusive time** is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for `2` time units and another call executing for `1` time unit, the **exclusive time** is `2 + 1 = 3`. Return _the **exclusive time** of each function in an array, where the value at the_ `ith` _index represents the exclusive time for the function with ID_ `i`. **Example 1:** **Input:** n = 2, logs = [ 0:start:0 , 1:start:2 , 1:end:5 , 0:end:6 ] **Output:** [3,4] **Explanation:** Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1. Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5. Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time. So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing. **Example 2:** **Input:** n = 1, logs = [ 0:start:0 , 0:start:2 , 0:end:5 , 0:start:6 , 0:end:6 , 0:end:7 ] **Output:** [8] **Explanation:** Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls itself again. Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time. Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time. So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing. **Example 3:** **Input:** n = 2, logs = [ 0:start:0 , 0:start:2 , 0:end:5 , 1:start:6 , 1:end:6 , 0:end:7 ] **Output:** [7,1] **Explanation:** Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls function 1. Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6. Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time. So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing. **Constraints:** * `1 <= n <= 100` * `1 <= logs.length <= 500` * `0 <= function_id < n` * `0 <= timestamp <= 109` * No two start events will happen at the same timestamp. * No two end events will happen at the same timestamp. * Each function has an `end ` log for each `start ` log.","completion":"def exclusiveTime(n, logs): res = [0] * n stack = [] prev_time = 0 for log in logs: parts = log.split(\':\') id = int(parts[0]) type = parts[1] time = int(parts[2]) if type == \\"start\\": if stack: res[stack[-1]] += time - prev_time stack.append(id) prev_time = time else: res[stack.pop()] += time - prev_time + 1 prev_time = time + 1 return res"},{"prompt":"There is an `8 x 8` chessboard containing `n` pieces (rooks, queens, or bishops). You are given a string array `pieces` of length `n`, where `pieces[i]` describes the type (rook, queen, or bishop) of the `ith` piece. In addition, you are given a 2D integer array `positions` also of length `n`, where `positions[i] = [ri, ci]` indicates that the `ith` piece is currently at the **1based** coordinate `(ri, ci)` on the chessboard. When making a **move** for a piece, you choose a **destination** square that the piece will travel toward and stop on. * A rook can only travel **horizontally or vertically** from `(r, c)` to the direction of `(r+1, c)`, `(r1, c)`, `(r, c+1)`, or `(r, c1)`. * A queen can only travel **horizontally, vertically, or diagonally** from `(r, c)` to the direction of `(r+1, c)`, `(r1, c)`, `(r, c+1)`, `(r, c1)`, `(r+1, c+1)`, `(r+1, c1)`, `(r1, c+1)`, `(r1, c1)`. * A bishop can only travel **diagonally** from `(r, c)` to the direction of `(r+1, c+1)`, `(r+1, c1)`, `(r1, c+1)`, `(r1, c1)`. You must make a **move** for every piece on the board simultaneously. A **move combination** consists of all the **moves** performed on all the given pieces. Every second, each piece will instantaneously travel **one square** towards their destination if they are not already at it. All pieces start traveling at the `0th` second. A move combination is **invalid** if, at a given time, **two or more** pieces occupy the same square. Return _the number of **valid** move combinations_​​​​​. **Notes:** * **No two pieces** will start in the **same** square. * You may choose the square a piece is already on as its **destination**. * If two pieces are **directly adjacent** to each other, it is valid for them to **move past each other** and swap positions in one second. **Example 1:** **Input:** pieces = [ rook ], positions = [[1,1]] **Output:** 15 **Explanation:** The image above shows the possible squares the piece can move to. **Example 2:** **Input:** pieces = [ queen ], positions = [[1,1]] **Output:** 22 **Explanation:** The image above shows the possible squares the piece can move to. **Example 3:** **Input:** pieces = [ bishop ], positions = [[4,3]] **Output:** 12 **Explanation:** The image above shows the possible squares the piece can move to. **Constraints:** * `n == pieces.length` * `n == positions.length` * `1 <= n <= 4` * `pieces` only contains the strings `rook `, `queen `, and `bishop `. * There will be at most one queen on the chessboard. * `1 <= xi, yi <= 8` * Each `positions[i]` is distinct.","completion":"def count_valid_combos(pieces, positions, index=0): if index == len(pieces): return 1 r, c = positions[index] dr = [0, 1, 0, -1, 1, 1, -1, -1] dc = [1, 0, -1, 0, 1, -1, 1, -1] valids = 0 for x in range(8): if pieces[index] == \\"bishop\\" and x < 4: continue if pieces[index] == \\"rook\\" and x >= 4: break for dist in range(1, 9): nr, nc = r + dr[x] * dist, c + dc[x] * dist if nr < 1 or nr > 8 or nc < 1 or nc > 8: break if nr == r and nc == c: continue valid = True for other in range(len(positions)): if other == index: continue orr, occ = positions[other] if orr == nr and occ == nc: valid = False break if orr + occ == nr + nc or orr - occ == nr - nc: valid = False break if orr == nr or occ == nc: valid = False break if valid: positions[index] = [nr, nc] valids += count_valid_combos(pieces, positions, index + 1) positions[index] = [r, c] return valids"},{"prompt":"Given an array of strings `names` of size `n`. You will create `n` folders in your file system **such that**, at the `ith` minute, you will create a folder with the name `names[i]`. Since two files **cannot** have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of `(k)`, where, `k` is the **smallest positive integer** such that the obtained name remains unique. Return _an array of strings of length_ `n` where `ans[i]` is the actual name the system will assign to the `ith` folder when you create it. **Example 1:** **Input:** names = [ pes , fifa , gta , pes(2019) ] **Output:** [ pes , fifa , gta , pes(2019) ] **Explanation:** Let\'s see how the file system creates folder names: pes > not assigned before, remains pes fifa > not assigned before, remains fifa gta > not assigned before, remains gta pes(2019) > not assigned before, remains pes(2019) **Example 2:** **Input:** names = [ gta , gta(1) , gta , avalon ] **Output:** [ gta , gta(1) , gta(2) , avalon ] **Explanation:** Let\'s see how the file system creates folder names: gta > not assigned before, remains gta gta(1) > not assigned before, remains gta(1) gta > the name is reserved, system adds (k), since gta(1) is also reserved, systems put k = 2. it becomes gta(2) avalon > not assigned before, remains avalon **Example 3:** **Input:** names = [ onepiece , onepiece(1) , onepiece(2) , onepiece(3) , onepiece ] **Output:** [ onepiece , onepiece(1) , onepiece(2) , onepiece(3) , onepiece(4) ] **Explanation:** When the last folder is created, the smallest positive valid k is 4, and it becomes onepiece(4) . **Constraints:** * `1 <= names.length <= 5 * 104` * `1 <= names[i].length <= 20` * `names[i]` consists of lowercase English letters, digits, and/or round brackets.","completion":"def maxNumberOfFamilies(n, reservedSeats): rows = {} for seat in reservedSeats: rows[seat[0]] = rows.get(seat[0], 0) | (1 << (seat[1] - 1)) max_groups = (n - len(rows)) * 2 for row_mask in rows.values(): seats = ~(row_mask | (row_mask >> 1) | (row_mask >> 2) | (row_mask >> 3)) & 0x3FF max_groups += (seats & (seats >> 1) & (seats >> 2) & (seats >> 3)) != 0 return max_groups"},{"prompt":"Given two integers `tomatoSlices` and `cheeseSlices`. The ingredients of different burgers are as follows: * **Jumbo Burger:** `4` tomato slices and `1` cheese slice. * **Small Burger:** `2` Tomato slices and `1` cheese slice. Return `[total_jumbo, total_small]` so that the number of remaining `tomatoSlices` equal to `0` and the number of remaining `cheeseSlices` equal to `0`. If it is not possible to make the remaining `tomatoSlices` and `cheeseSlices` equal to `0` return `[]`. **Example 1:** **Input:** tomatoSlices = 16, cheeseSlices = 7 **Output:** [1,6] **Explantion:** To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese. There will be no remaining ingredients. **Example 2:** **Input:** tomatoSlices = 17, cheeseSlices = 4 **Output:** [] **Explantion:** There will be no way to use all ingredients to make small and jumbo burgers. **Example 3:** **Input:** tomatoSlices = 4, cheeseSlices = 17 **Output:** [] **Explantion:** Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining. **Constraints:** * `0 <= tomatoSlices, cheeseSlices <= 107`","completion":"def closest_factors(num): factor1 = int((num + 2) ** 0.5) while True: factor2 = (num + 2) // factor1 if factor1 * factor2 == num + 2: return factor1, factor2 factor2 = (num + 1) // factor1 if factor1 * factor2 == num + 1: return factor1, factor2 factor1 -= 1"},{"prompt":"Given an integer `num`, return _the number of digits in `num` that divide_ `num`. An integer `val` divides `nums` if `nums % val == 0`. **Example 1:** **Input:** num = 7 **Output:** 1 **Explanation:** 7 divides itself, hence the answer is 1. **Example 2:** **Input:** num = 121 **Output:** 2 **Explanation:** 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2. **Example 3:** **Input:** num = 1248 **Output:** 4 **Explanation:** 1248 is divisible by all of its digits, hence the answer is 4. **Constraints:** * `1 <= num <= 109` * `num` does not contain `0` as one of its digits.","completion":"def digits_dividing_num(num): count = 0 temp = num while temp > 0: digit = temp % 10 if num % digit == 0: count += 1 temp //= 10 return count"},{"prompt":"You are given a **0indexed** integer array `nums` of **even** length consisting of an **equal** number of positive and negative integers. You should **rearrange** the elements of `nums` such that the modified array follows the given conditions: 1. Every **consecutive pair** of integers have **opposite signs**. 2. For all integers with the same sign, the **order** in which they were present in `nums` is **preserved**. 3. The rearranged array begins with a positive integer. Return _the modified array after rearranging the elements to satisfy the aforementioned conditions_. **Example 1:** **Input:** nums = [3,1,2,5,2,4] **Output:** [3,2,1,5,2,4] **Explanation:** The positive integers in nums are [3,1,2]. The negative integers are [2,5,4]. The only possible way to rearrange them such that they satisfy all conditions is [3,2,1,5,2,4]. Other ways such as [1,2,2,5,3,4], [3,1,2,2,5,4], [2,3,5,1,4,2] are incorrect because they do not satisfy one or more conditions. **Example 2:** **Input:** nums = [1,1] **Output:** [1,1] **Explanation:** 1 is the only positive integer and 1 the only negative integer in nums. So nums is rearranged to [1,1]. **Constraints:** * `2 <= nums.length <= 2 * 105` * `nums.length` is **even** * `1 <= |nums[i]| <= 105` * `nums` consists of **equal** number of positive and negative integers.","completion":"def solve_puzzle(colors: str) -> bool: return colors.count(\'A\') % 2 == 1"},{"prompt":"Given an array of integers `arr`, return `true` if we can partition the array into three **nonempty** parts with equal sums. Formally, we can partition the array if we can find indexes `i + 1 < j` with `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j 1] == arr[j] + arr[j + 1] + ... + arr[arr.length 1])` **Example 1:** **Input:** arr = [0,2,1,6,6,7,9,1,2,0,1] **Output:** true **Explanation:** 0 + 2 + 1 = 6 + 6 7 + 9 + 1 = 2 + 0 + 1 **Example 2:** **Input:** arr = [0,2,1,6,6,7,9,1,2,0,1] **Output:** false **Example 3:** **Input:** arr = [3,3,6,5,2,2,5,1,9,4] **Output:** true **Explanation:** 3 + 3 = 6 = 5 2 + 2 + 5 + 1 9 + 4 **Constraints:** * `3 <= arr.length <= 5 * 104` * `104 <= arr[i] <= 104`","completion":"def fib(n): if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"prompt":"You\'re given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so `a ` is considered a different type of stone from `A `. **Example 1:** **Input:** jewels = aA, stones = aAAbbbb **Output:** 3 **Example 2:** **Input:** jewels = z, stones = ZZ **Output:** 0 **Constraints:** * `1 <= jewels.length, stones.length <= 50` * `jewels` and `stones` consist of only English letters. * All the characters of `jewels` are **unique**.","completion":"def num_jewels_in_stones(jewels: str, stones: str) -> int: count = 0 for stone in stones: if stone in jewels: count += 1 return count"},{"prompt":"You are given an integer array `nums`. A subsequence of `nums` is called a **square streak** if: * The length of the subsequence is at least `2`, and * **after** sorting the subsequence, each element (except the first element) is the **square** of the previous number. Return _the length of the **longest square streak** in_ `nums`_, or return_ `1` _if there is no **square streak**._ A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. **Example 1:** **Input:** nums = [4,3,6,16,8,2] **Output:** 3 **Explanation:** Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16]. 4 = 2 * 2. 16 = 4 * 4. Therefore, [4,16,2] is a square streak. It can be shown that every subsequence of length 4 is not a square streak. **Example 2:** **Input:** nums = [2,3,5,6,7] **Output:** 1 **Explanation:** There is no square streak in nums so return 1. **Constraints:** * `2 <= nums.length <= 105` * `2 <= nums[i] <= 105`","completion":"def longest_square_streak(nums): num_set = set(nums) longest_streak = -1 for num in num_set: streak = 1 while int(num ** 0.5) in num_set: streak += 1 num = int(num ** 0.5) longest_streak = max(longest_streak, streak) return longest_streak if longest_streak >= 2 else -1"},{"prompt":"You are given an integer array `bloomDay`, an integer `m` and an integer `k`. You want to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return _the minimum number of days you need to wait to be able to make_ `m` _bouquets from the garden_. If it is impossible to make m bouquets return `1`. **Example 1:** **Input:** bloomDay = [1,10,3,10,2], m = 3, k = 1 **Output:** 3 **Explanation:** Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. **Example 2:** **Input:** bloomDay = [1,10,3,10,2], m = 3, k = 2 **Output:** 1 **Explanation:** We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return 1. **Example 3:** **Input:** bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 **Output:** 12 **Explanation:** We need 2 bouquets each should have 3 flowers. Here is the garden after the 7 and 12 days: After day 7: [x, x, x, x, _, x, x] We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent. After day 12: [x, x, x, x, x, x, x] It is obvious that we can make two bouquets in different ways. **Constraints:** * `bloomDay.length == n` * `1 <= n <= 105` * `1 <= bloomDay[i] <= 109` * `1 <= m <= 106` * `1 <= k <= n`","completion":"def smallerNumbersThanCurrent(nums): result = [0] * len(nums) for i in range(len(nums)): for j in range(len(nums)): if nums[j] < nums[i]: result[i] += 1 return result"},{"prompt":"A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in **nondecreasing order** by height. Let this ordering be represented by the integer array `expected` where `expected[i]` is the expected height of the `ith` student in line. You are given an integer array `heights` representing the **current order** that the students are standing in. Each `heights[i]` is the height of the `ith` student in line (**0indexed**). Return _the **number of indices** where_ `heights[i] != expected[i]`. **Example 1:** **Input:** heights = [1,1,4,2,1,3] **Output:** 3 **Explanation:** heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. **Example 2:** **Input:** heights = [5,1,2,3,4] **Output:** 5 **Explanation:** heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. **Example 3:** **Input:** heights = [1,2,3,4,5] **Output:** 0 **Explanation:** heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. **Constraints:** * `1 <= heights.length <= 100` * `1 <= heights[i] <= 100`","completion":"def height_checker(heights): expected = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != expected[i]: count += 1 return count"},{"prompt":"You are given an `m x n` binary matrix `grid`. A **move** consists of choosing any row or column and toggling each value in that row or column (i.e., changing all `0`\'s to `1`\'s, and all `1`\'s to `0`\'s). Every row of the matrix is interpreted as a binary number, and the **score** of the matrix is the sum of these numbers. Return _the highest possible **score** after making any number of **moves** (including zero moves)_. **Example 1:** **Input:** grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] **Output:** 39 **Explanation:** 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 **Example 2:** **Input:** grid = [[0]] **Output:** 1 **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 20` * `grid[i][j]` is either `0` or `1`.","completion":"def flipAndInvertImage(image): for row in image: row.reverse() for j in range(len(row)): row[j] = 1 - row[j] return image"},{"prompt":"Given a list of the scores of different students, `items`, where `items[i] = [IDi, scorei]` represents one score from a student with `IDi`, calculate each student\'s **top five average**. Return _the answer as an array of pairs_ `result`_, where_ `result[j] = [IDj, topFiveAveragej]` _represents the student with_ `IDj` _and their **top five average**. Sort_ `result` _by_ `IDj` _in **increasing order**._ A student\'s **top five average** is calculated by taking the sum of their top five scores and dividing it by `5` using **integer division**. **Example 1:** **Input:** items = [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]] **Output:** [[1,87],[2,88]] **Explanation:** The student with ID = 1 got scores 91, 92, 60, 65, 87, and 100. Their top five average is (100 + 92 + 91 + 87 + 65) / 5 = 87. The student with ID = 2 got scores 93, 97, 77, 100, and 76. Their top five average is (100 + 97 + 93 + 77 + 76) / 5 = 88.6, but with integer division their average converts to 88. **Example 2:** **Input:** items = [[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100]] **Output:** [[1,100],[7,100]] **Constraints:** * `1 <= items.length <= 1000` * `items[i].length == 2` * `1 <= IDi <= 1000` * `0 <= scorei <= 100` * For each `IDi`, there will be **at least** five scores.","completion":"def alice_win(n): return n % 2 == 0"},{"prompt":"Given an array of positive integers `arr`, find a pattern of length `m` that is repeated `k` or more times. A **pattern** is a subarray (consecutive subsequence) that consists of one or more values, repeated multiple times **consecutively** without overlapping. A pattern is defined by its length and the number of repetitions. Return `true` _if there exists a pattern of length_ `m` _that is repeated_ `k` _or more times, otherwise return_ `false`. **Example 1:** **Input:** arr = [1,2,4,4,4,4], m = 1, k = 3 **Output:** true **Explanation:** The pattern **(4)** of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less. **Example 2:** **Input:** arr = [1,2,1,2,1,1,1,3], m = 2, k = 2 **Output:** true **Explanation:** The pattern **(1,2)** of length 2 is repeated 2 consecutive times. Another valid pattern **(2,1) is** also repeated 2 times. **Example 3:** **Input:** arr = [1,2,1,2,1,3], m = 2, k = 3 **Output:** false **Explanation:** The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times. **Constraints:** * `2 <= arr.length <= 100` * `1 <= arr[i] <= 100` * `1 <= m <= 100` * `2 <= k <= 100`","completion":"def is_prefix_of_word(sentence: str, search_word: str) -> int: words = sentence.split(\' \') for index, word in enumerate(words, start=1): if word.startswith(search_word): return index return -1"},{"prompt":"Given a string `s`, determine if it is **valid**. A string `s` is **valid** if, starting with an empty string `t = `, you can **transform** `t` **into** `s` after performing the following operation **any number of times**: * Insert string `abc ` into any position in `t`. More formally, `t` becomes `tleft + abc + tright`, where `t == tleft + tright`. Note that `tleft` and `tright` may be **empty**. Return `true` _if_ `s` _is a **valid** string, otherwise, return_ `false`. **Example 1:** **Input:** s = aabcbc **Output:** true **Explanation:** > abc > aabcbc Thus, aabcbc is valid. **Example 2:** **Input:** s = abcabcababcc **Output:** true **Explanation:** > abc > abcabc > abcabcabc > abcabcababcc Thus, abcabcababcc is valid. **Example 3:** **Input:** s = abccba **Output:** false **Explanation:** It is impossible to get abccba using the operation. **Constraints:** * `1 <= s.length <= 2 * 104` * `s` consists of letters `\'a\'`, `\'b\'`, and `\'c\'`","completion":"from collections import defaultdict from math import sqrt, inf def minAreaFreeRect(points): minArea = inf xGroups = defaultdict(set) for x, y in points: xGroups[x].add(y) for x1, ys1 in xGroups.items(): for x2, ys2 in xGroups.items(): if x1 == x2: continue for y1 in ys1: for y2 in ys2: if y2 in ys1 and y1 in ys2: area = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) * sqrt((x1 - x2) ** 2 + (y1 - y1) ** 2) minArea = min(minArea, area) return minArea if minArea != inf else 0"},{"prompt":"Due to a bug, there are many duplicate folders in a file system. You are given a 2D array `paths`, where `paths[i]` is an array representing an absolute path to the `ith` folder in the file system. * For example, `[ one , two , three ]` represents the path `/one/two/three `. Two folders (not necessarily on the same level) are **identical** if they contain the **same nonempty** set of identical subfolders and underlying subfolder structure. The folders **do not** need to be at the root level to be identical. If two or more folders are **identical**, then **mark** the folders as well as all their subfolders. * For example, folders `/a ` and `/b ` in the file structure below are identical. They (as well as their subfolders) should **all** be marked: * `/a` * `/a/x` * `/a/x/y` * `/a/z` * `/b` * `/b/x` * `/b/x/y` * `/b/z` * However, if the file structure also included the path `/b/w `, then the folders `/a ` and `/b ` would not be identical. Note that `/a/x ` and `/b/x ` would still be considered identical even with the added folder. Once all the identical folders and their subfolders have been marked, the file system will **delete** all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted. Return _the 2D array_ `ans` _containing the paths of the **remaining** folders after deleting all the marked folders. The paths may be returned in **any** order_. **Example 1:** **Input:** paths = [[ a ],[ c ],[ d ],[ a , b ],[ c , b ],[ d , a ]] **Output:** [[ d ],[ d , a ]] **Explanation:** The file structure is as shown. Folders /a and /c (and their subfolders) are marked for deletion because they both contain an empty folder named b . **Example 2:** **Input:** paths = [[ a ],[ c ],[ a , b ],[ c , b ],[ a , b , x ],[ a , b , x , y ],[ w ],[ w , y ]] **Output:** [[ c ],[ c , b ],[ a ],[ a , b ]] **Explanation:** The file structure is as shown. Folders /a/b/x and /w (and their subfolders) are marked for deletion because they both contain an empty folder named y . Note that folders /a and /c are identical after the deletion, but they are not deleted because they were not marked beforehand. **Example 3:** **Input:** paths = [[ a , b ],[ c , d ],[ c ],[ a ]] **Output:** [[ c ],[ c , d ],[ a ],[ a , b ]] **Explanation:** All folders are unique in the file system. Note that the returned array can be in a different order as the order does not matter. **Constraints:** * `1 <= paths.length <= 2 * 104` * `1 <= paths[i].length <= 500` * `1 <= paths[i][j].length <= 10` * `1 <= sum(paths[i][j].length) <= 2 * 105` * `path[i][j]` consists of lowercase English letters. * No two paths lead to the same folder. * For any folder not at the root level, its parent folder will also be in the input.","completion":"from collections import defaultdict def delete_duplicate_folder(paths): folder_counts = defaultdict(int) for path in paths: path_string = \'/\' + \'/\'.join(path) folder_counts[path_string] += 1 remaining_paths = [] for path in paths: path_string = \'/\' + path[0] not_duplicate = folder_counts[path_string] == 1 for i in range(1, len(path)): path_string += \'/\' + path[i] if folder_counts[path_string] > 1: not_duplicate = False break if not_duplicate: remaining_paths.append(path) return remaining_paths"},{"prompt":"You are given a **0indexed** 2D integer array `peaks` where `peaks[i] = [xi, yi]` states that mountain `i` has a peak at coordinates `(xi, yi)`. A mountain can be described as a rightangled isosceles triangle, with its base along the `x`axis and a right angle at its peak. More formally, the **gradients** of ascending and descending the mountain are `1` and `1` respectively. A mountain is considered **visible** if its peak does not lie within another mountain (including the border of other mountains). Return _the number of visible mountains_. **Example 1:** **Input:** peaks = [[2,2],[6,3],[5,4]] **Output:** 2 **Explanation:** The diagram above shows the mountains. Mountain 0 is visible since its peak does not lie within another mountain or its sides. Mountain 1 is not visible since its peak lies within the side of mountain 2. Mountain 2 is visible since its peak does not lie within another mountain or its sides. There are 2 mountains that are visible. **Example 2:** **Input:** peaks = [[1,3],[1,3]] **Output:** 0 **Explanation:** The diagram above shows the mountains (they completely overlap). Both mountains are not visible since their peaks lie within each other. **Constraints:** * `1 <= peaks.length <= 105` * `peaks[i].length == 2` * `1 <= xi, yi <= 105`","completion":"def min_operations(current, correct): current_mins = int(current[:2]) * 60 + int(current[3:]) correct_mins = int(correct[:2]) * 60 + int(correct[3:]) if current_mins > correct_mins: correct_mins += 24 * 60 diff = correct_mins - current_mins count = diff // 60 + (diff % 60) // 15 + ((diff % 60) % 15) // 5 + (((diff % 60) % 15) % 5) return count"},{"prompt":"You are given an array `nums`. You can rotate it by a nonnegative integer `k` so that the array becomes `[nums[k], nums[k + 1], ... nums[nums.length 1], nums[0], nums[1], ..., nums[k1]]`. Afterward, any entries that are less than or equal to their index are worth one point. * For example, if we have `nums = [2,4,1,3,0]`, and we rotate by `k = 2`, it becomes `[1,3,0,2,4]`. This is worth `3` points because `1 > 0` [no points], `3 > 1` [no points], `0 <= 2` [one point], `2 <= 3` [one point], `4 <= 4` [one point]. Return _the rotation index_ `k` _that corresponds to the highest score we can achieve if we rotated_ `nums` _by it_. If there are multiple answers, return the smallest such index `k`. **Example 1:** **Input:** nums = [2,3,1,4,0] **Output:** 3 **Explanation:** Scores for each k are listed below: k = 0, nums = [2,3,1,4,0], score 2 k = 1, nums = [3,1,4,0,2], score 3 k = 2, nums = [1,4,0,2,3], score 3 k = 3, nums = [4,0,2,3,1], score 4 k = 4, nums = [0,2,3,1,4], score 3 So we should choose k = 3, which has the highest score. **Example 2:** **Input:** nums = [1,3,0,2,4] **Output:** 0 **Explanation:** nums will always have 3 points no matter how it shifts. So we will choose the smallest k, which is 0. **Constraints:** * `1 <= nums.length <= 105` * `0 <= nums[i] < nums.length`","completion":"def moves_to_chessboard(board): N = len(board) row, col = 0, 0 row_count, col_count = 0, 0 for i in range(N): for j in range(N): if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0: return -1 for i in range(N): row ^= board[0][i] col ^= board[i][0] row_count += 1 if board[0][i] == 1 else 0 col_count += 1 if board[i][0] == 1 else 0 if row != 0 and row_count * 2 != N: return -1 if col != 0 and col_count * 2 != N: return -1 if N % 2 == 1: if row_count % 2 == 1: row_count = N - row_count if col_count % 2 == 1: col_count = N - col_count else: row_count = min(row_count, N - row_count) col_count = min(col_count, N - col_count) return (row_count + col_count) // 2"},{"prompt":"You are given a **0indexed** integer array `nums`. For each index `i` (`1 <= i <= nums.length 2`) the **beauty** of `nums[i]` equals: * `2`, if `nums[j] < nums[i] < nums[k]`, for **all** `0 <= j < i` and for **all** `i < k <= nums.length 1`. * `1`, if `nums[i 1] < nums[i] < nums[i + 1]`, and the previous condition is not satisfied. * `0`, if none of the previous conditions holds. Return _the **sum of beauty** of all_ `nums[i]` _where_ `1 <= i <= nums.length 2`. **Example 1:** **Input:** nums = [1,2,3] **Output:** 2 **Explanation:** For each index i in the range 1 <= i <= 1: The beauty of nums[1] equals 2. **Example 2:** **Input:** nums = [2,4,6,4] **Output:** 1 **Explanation:** For each index i in the range 1 <= i <= 2: The beauty of nums[1] equals 1. The beauty of nums[2] equals 0. **Example 3:** **Input:** nums = [3,2,1] **Output:** 0 **Explanation:** For each index i in the range 1 <= i <= 1: The beauty of nums[1] equals 0. **Constraints:** * `3 <= nums.length <= 105` * `1 <= nums[i] <= 105`","completion":"from queue import PriorityQueue def assignTasks(servers, tasks): n, m = len(servers), len(tasks) ans = [0] * m freeServers = PriorityQueue() for i in range(n): freeServers.put((servers[i], i)) busyServers = PriorityQueue() currentTask = 0 while currentTask < m: while not busyServers.empty() and busyServers.queue[0][0] <= currentTask: _, idx = busyServers.get() freeServers.put((servers[idx], idx)) while not freeServers.empty() and currentTask < m: _, idx = freeServers.get() ans[currentTask] = idx busyServers.put((currentTask + tasks[currentTask], idx)) currentTask += 1 if freeServers.empty(): currentTask = busyServers.queue[0][0] return ans"},{"prompt":"Given a string `s` and an integer `k`, return _the number of substrings in_ `s` _of length_ `k` _with no repeated characters_. **Example 1:** **Input:** s = havefunonleetcode , k = 5 **Output:** 6 **Explanation:** There are 6 substrings they are: \'havef\',\'avefu\',\'vefun\',\'efuno\',\'etcod\',\'tcode\'. **Example 2:** **Input:** s = home , k = 5 **Output:** 0 **Explanation:** Notice k can be larger than the length of s. In this case, it is not possible to find any substring. **Constraints:** * `1 <= s.length <= 104` * `s` consists of lowercase English letters. * `1 <= k <= 104`","completion":"def num_k_len_substr_no_repeats(s: str, k: int) -> int: n = len(s) if k > n: return 0 result = 0 window = set() i = 0 for j in range(n): while s[j] in window: window.remove(s[i]) i += 1 window.add(s[j]) if j - i + 1 == k: result += 1 window.remove(s[i]) i += 1 return result"},{"prompt":"You are given an array of **distinct** integers `arr` and an array of integer arrays `pieces`, where the integers in `pieces` are **distinct**. Your goal is to form `arr` by concatenating the arrays in `pieces` **in any order**. However, you are **not** allowed to reorder the integers in each array `pieces[i]`. Return `true` _if it is possible_ _to form the array_ `arr` _from_ `pieces`. Otherwise, return `false`. **Example 1:** **Input:** arr = [15,88], pieces = [[88],[15]] **Output:** true **Explanation:** Concatenate [15] then [88] **Example 2:** **Input:** arr = [49,18,16], pieces = [[16,18,49]] **Output:** false **Explanation:** Even though the numbers match, we cannot reorder pieces[0]. **Example 3:** **Input:** arr = [91,4,64,78], pieces = [[78],[4,64],[91]] **Output:** true **Explanation:** Concatenate [91] then [4,64] then [78] **Constraints:** * `1 <= pieces.length <= arr.length <= 100` * `sum(pieces[i].length) == arr.length` * `1 <= pieces[i].length <= arr.length` * `1 <= arr[i], pieces[i][j] <= 100` * The integers in `arr` are **distinct**. * The integers in `pieces` are **distinct** (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).","completion":"def canFormArray(arr, pieces): map = {piece[0]: piece for piece in pieces} i = 0 while i < len(arr): if arr[i] not in map: return False piece = map[arr[i]] for num in piece: if num != arr[i]: return False i += 1 return True"},{"prompt":"The **kbeauty** of an integer `num` is defined as the number of **substrings** of `num` when it is read as a string that meet the following conditions: * It has a length of `k`. * It is a divisor of `num`. Given integers `num` and `k`, return _the kbeauty of_ `num`. Note: * **Leading zeros** are allowed. * `0` is not a divisor of any value. A **substring** is a contiguous sequence of characters in a string. **Example 1:** **Input:** num = 240, k = 2 **Output:** 2 **Explanation:** The following are the substrings of num of length k: 24 from **24**0 : 24 is a divisor of 240. 40 from 2**40** : 40 is a divisor of 240. Therefore, the kbeauty is 2. **Example 2:** **Input:** num = 430043, k = 2 **Output:** 2 **Explanation:** The following are the substrings of num of length k: 43 from **43**0043 : 43 is a divisor of 430043. 30 from 4**30**043 : 30 is not a divisor of 430043. 00 from 43**00**43 : 0 is not a divisor of 430043. 04 from 430**04**3 : 4 is not a divisor of 430043. 43 from 4300**43** : 43 is a divisor of 430043. Therefore, the kbeauty is 2. **Constraints:** * `1 <= num <= 109` * `1 <= k <= num.length` (taking `num` as a string)","completion":"def num_elements_with_smaller_and_greater(nums): n = len(nums) res = 0 for i in range(n): has_smaller = has_greater = False for j in range(n): if i == j: continue if nums[j] > nums[i]: has_greater = True if nums[j] < nums[i]: has_smaller = True if has_smaller and has_greater: res += 1 break return res"},{"prompt":"You are given two **0indexed** arrays `nums` and `cost` consisting each of `n` **positive** integers. You can do the following operation **any** number of times: * Increase or decrease **any** element of the array `nums` by `1`. The cost of doing one operation on the `ith` element is `cost[i]`. Return _the **minimum** total cost such that all the elements of the array_ `nums` _become **equal**_. **Example 1:** **Input:** nums = [1,3,5,2], cost = [2,3,1,14] **Output:** 8 **Explanation:** We can make all the elements equal to 2 in the following way: Increase the 0th element one time. The cost is 2. Decrease the 1st element one time. The cost is 3. Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3. The total cost is 2 + 3 + 3 = 8. It can be shown that we cannot make the array equal with a smaller cost. **Example 2:** **Input:** nums = [2,2,2,2,2], cost = [4,2,8,1,3] **Output:** 0 **Explanation:** All the elements are already equal, so no operations are needed. **Constraints:** * `n == nums.length == cost.length` * `1 <= n <= 105` * `1 <= nums[i], cost[i] <= 106`","completion":"def minCost(nums, cost): ans = float(\\"inf\\") base = min(nums) for target in range(base, base + 2): local_res = 0 for i in range(len(nums)): local_res += abs(nums[i] - target) * cost[i] ans = min(ans, local_res) return ans"},{"prompt":"You are given a **0indexed** integer array `nums`. A pair of indices `(i, j)` is a **bad pair** if `i < j` and `j i != nums[j] nums[i]`. Return _the total number of **bad pairs** in_ `nums`. **Example 1:** **Input:** nums = [4,1,3,3] **Output:** 5 **Explanation:** The pair (0, 1) is a bad pair since 1 0 != 1 4. The pair (0, 2) is a bad pair since 2 0 != 3 4, 2 != 1. The pair (0, 3) is a bad pair since 3 0 != 3 4, 3 != 1. The pair (1, 2) is a bad pair since 2 1 != 3 1, 1 != 2. The pair (2, 3) is a bad pair since 3 2 != 3 3, 1 != 0. There are a total of 5 bad pairs, so we return 5. **Example 2:** **Input:** nums = [1,2,3,4,5] **Output:** 0 **Explanation:** There are no bad pairs. **Constraints:** * `1 <= nums.length <= 105` * `1 <= nums[i] <= 109`","completion":"def bad_pairs(nums): count = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): if j - i != nums[j] - nums[i]: count += 1 return count"},{"prompt":"Given an integer array `nums` and a positive integer `k`, return _the most **competitive** subsequence of_ `nums` _of size_ `k`. An array\'s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence `a` is more **competitive** than a subsequence `b` (of the same length) if in the first position where `a` and `b` differ, subsequence `a` has a number **less** than the corresponding number in `b`. For example, `[1,3,4]` is more competitive than `[1,3,5]` because the first position they differ is at the final number, and `4` is less than `5`. **Example 1:** **Input:** nums = [3,5,2,6], k = 2 **Output:** [2,6] **Explanation:** Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive. **Example 2:** **Input:** nums = [2,4,3,3,5,4,9,6], k = 4 **Output:** [2,3,3,4] **Constraints:** * `1 <= nums.length <= 105` * `0 <= nums[i] <= 109` * `1 <= k <= nums.length`","completion":"from collections import deque def mostCompetitive(nums, k): stack = deque() n = len(nums) for i in range(n): while stack and stack[-1] > nums[i] and len(stack) + n - i > k: stack.pop() if len(stack) < k: stack.append(nums[i]) return list(stack)"},{"prompt":"Given a `m x n` matrix `mat` and an integer `k`, return _a matrix_ `answer` _where each_ `answer[i][j]` _is the sum of all elements_ `mat[r][c]` _for_: * `i k <= r <= i + k,` * `j k <= c <= j + k`, and * `(r, c)` is a valid position in the matrix. **Example 1:** **Input:** mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1 **Output:** [[12,21,16],[27,45,33],[24,39,28]] **Example 2:** **Input:** mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2 **Output:** [[45,45,45],[45,45,45],[45,45,45]] **Constraints:** * `m == mat.length` * `n == mat[i].length` * `1 <= m, n, k <= 100` * `1 <= mat[i][j] <= 100`","completion":"def matrix_block_sum(mat, k): m, n = len(mat), len(mat[0]) answer = [[0 for _ in range(n)] for _ in range(m)] for i in range(m): for j in range(n): for r in range(max(0, i - k), min(m, i + k + 1)): for c in range(max(0, j - k), min(n, j + k + 1)): answer[i][j] += mat[r][c] return answer"},{"prompt":"On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return _the **minimum time** in seconds to visit all the points in the order given by_ `points`. You can move according to these rules: * In `1` second, you can either: * move vertically by one unit, * move horizontally by one unit, or * move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second). * You have to visit the points in the same order as they appear in the array. * You are allowed to pass through points that appear later in the order, but these do not count as visits. **Example 1:** **Input:** points = [[1,1],[3,4],[1,0]] **Output:** 7 **Explanation:** One optimal path is **[1,1]** > [2,2] > [3,3] > **[3,4]** > [2,3] > [1,2] > [0,1] > **[1,0]** Time from [1,1] to [3,4] = 3 seconds Time from [3,4] to [1,0] = 4 seconds Total time = 7 seconds **Example 2:** **Input:** points = [[3,2],[2,2]] **Output:** 5 **Constraints:** * `points.length == n` * `1 <= n <= 100` * `points[i].length == 2` * `1000 <= points[i][0], points[i][1] <= 1000`","completion":"def minTimeToVisitAllPoints(points): time = 0 for i in range(1, len(points)): dx = abs(points[i][0] - points[i - 1][0]) dy = abs(points[i][1] - points[i - 1][1]) time += max(dx, dy) return time"},{"prompt":"A room is represented by a **0indexed** 2D binary matrix `room` where a `0` represents an **empty** space and a `1` represents a space with an **object**. The top left corner of the room will be empty in all test cases. A cleaning robot starts at the top left corner of the room and is facing right. The robot will continue heading straight until it reaches the edge of the room or it hits an object, after which it will turn 90 degrees **clockwise** and repeat this process. The starting space and all spaces that the robot visits are **cleaned** by it. Return _the number of **clean** spaces in the room if the robot runs indefinetely._ **Example 1:** **Input:** room = [[0,0,0],[1,1,0],[0,0,0]] **Output:** 7 **Explanation:** The robot cleans the spaces at (0, 0), (0, 1), and (0, 2). The robot is at the edge of the room, so it turns 90 degrees clockwise and now faces down. The robot cleans the spaces at (1, 2), and (2, 2). The robot is at the edge of the room, so it turns 90 degrees clockwise and now faces left. The robot cleans the spaces at (2, 1), and (2, 0). The robot has cleaned all 7 empty spaces, so return 7. **Example 2:** **Input:** room = [[0,1,0],[1,0,0],[0,0,0]] **Output:** 1 **Explanation:** The robot cleans the space at (0, 0). The robot hits an object, so it turns 90 degrees clockwise and now faces down. The robot hits an object, so it turns 90 degrees clockwise and now faces left. The robot is at the edge of the room, so it turns 90 degrees clockwise and now faces up. The robot is at the edge of the room, so it turns 90 degrees clockwise and now faces right. The robot is back at its starting position. The robot has cleaned 1 space, so return 1. **Constraints:** * `m == room.length` * `n == room[r].length` * `1 <= m, n <= 300` * `room[r][c]` is either `0` or `1`. * `room[0][0] == 0`","completion":"def colorTheGrid(m, n): mod = 10**9 + 7 dp = [6, 6] dpf = [3, 3] for _ in range(2, max(m, n) + 1): temp = dp[1] dp[1] = (dpf[1] * 2) % mod dp[0] = temp dpf[1] = (dpf[1] + dpf[0]) % mod dpf[0] = (dpf[0] + temp) % mod return (dp[0 if m == 1 else 1] * dpf[0 if n == 1 else 1]) % mod"},{"prompt":"Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor. The doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor\'s advice. Given the integer array `candyType` of length `n`, return _the **maximum** number of different types of candies she can eat if she only eats_ `n / 2` _of them_. **Example 1:** **Input:** candyType = [1,1,2,2,3,3] **Output:** 3 **Explanation:** Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type. **Example 2:** **Input:** candyType = [1,1,2,3] **Output:** 2 **Explanation:** Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types. **Example 3:** **Input:** candyType = [6,6,6,6] **Output:** 1 **Explanation:** Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type. **Constraints:** * `n == candyType.length` * `2 <= n <= 104` * `n` is even. * `105 <= candyType[i] <= 105`","completion":"def maxNumberOfCandies(candyType): uniqueCandies = set(candyType) return min(len(uniqueCandies), len(candyType) // 2)"},{"prompt":"Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`. * For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST. Return _the number of ways to reorder_ `nums` _such that the BST formed is identical to the original BST formed from_ `nums`. Since the answer may be very large, **return it modulo** `109 + 7`. **Example 1:** **Input:** nums = [2,1,3] **Output:** 1 **Explanation:** We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST. **Example 2:** **Input:** nums = [3,4,5,1,2] **Output:** 5 **Explanation:** The following 5 arrays will yield the same BST: [3,1,2,4,5] [3,1,4,2,5] [3,1,4,5,2] [3,4,1,2,5] [3,4,1,5,2] **Example 3:** **Input:** nums = [1,2,3] **Output:** 0 **Explanation:** There are no other orderings of nums that will yield the same BST. **Constraints:** * `1 <= nums.length <= 1000` * `1 <= nums[i] <= nums.length` * All integers in `nums` are **distinct**.","completion":"def maxDotProduct(nums1, nums2): n, m = len(nums1), len(nums2) dp = [[float(\'-inf\') for _ in range(m + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1]) return dp[n][m]"},{"prompt":"An integer `n` is **strictly palindromic** if, for **every** base `b` between `2` and `n 2` (**inclusive**), the string representation of the integer `n` in base `b` is **palindromic**. Given an integer `n`, return `true` _if_ `n` _is **strictly palindromic** and_ `false` _otherwise_. A string is **palindromic** if it reads the same forward and backward. **Example 1:** **Input:** n = 9 **Output:** false **Explanation:** In base 2: 9 = 1001 (base 2), which is palindromic. In base 3: 9 = 100 (base 3), which is not palindromic. Therefore, 9 is not strictly palindromic so we return false. Note that in bases 4, 5, 6, and 7, n = 9 is also not palindromic. **Example 2:** **Input:** n = 4 **Output:** false **Explanation:** We only consider base 2: 4 = 100 (base 2), which is not palindromic. Therefore, we return false. **Constraints:** * `4 <= n <= 105`","completion":"def is_palindrome(s: str) -> bool: return s == s[::-1] def to_base_str(n: int, base: int) -> str: s = [] while n > 0: s.append(str(n % base)) n //= base return \\"\\".join(reversed(s)) def is_strictly_palindromic(n: int) -> bool: for b in range(2, n - 1): if not is_palindrome(to_base_str(n, b)): return False return True"},{"prompt":"You are given an integer array `nums` and an integer `goal`. You want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence\'s elements is `sum`, then you want to **minimize the absolute difference** `abs(sum goal)`. Return _the **minimum** possible value of_ `abs(sum goal)`. Note that a subsequence of an array is an array formed by removing some elements **(possibly all or none)** of the original array. **Example 1:** **Input:** nums = [5,7,3,5], goal = 6 **Output:** 0 **Explanation:** Choose the whole array as a subsequence, with a sum of 6. This is equal to the goal, so the absolute difference is 0. **Example 2:** **Input:** nums = [7,9,15,2], goal = 5 **Output:** 1 **Explanation:** Choose the subsequence [7,9,2], with a sum of 4. The absolute difference is abs(4 (5)) = abs(1) = 1, which is the minimum. **Example 3:** **Input:** nums = [1,2,3], goal = 7 **Output:** 7 **Constraints:** * `1 <= nums.length <= 40` * `107 <= nums[i] <= 107` * `109 <= goal <= 109`","completion":"def decrypt(code, k): n = len(code) result = [0] * n if k == 0: return result for i in range(n): sum = 0 for j in range(1, abs(k) + 1): sum += code[(i + j) % n] if k > 0 else code[(i - j + n) % n] result[i] = sum return result"},{"prompt":"A farmer has a **rectangular grid** of land with `m` rows and `n` columns that can be divided into unit cells. Each cell is either **fertile** (represented by a `1`) or **barren** (represented by a `0`). All cells outside the grid are considered barren. A **pyramidal plot** of land can be defined as a set of cells with the following criteria: 1. The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**. 2. The **apex** of a pyramid is the **topmost** cell of the pyramid. The **height** of a pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r <= i <= r + h 1` **and** `c (i r) <= j <= c + (i r)`. An **inverse pyramidal plot** of land can be defined as a set of cells with similar criteria: 1. The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**. 2. The **apex** of an inverse pyramid is the **bottommost** cell of the inverse pyramid. The **height** of an inverse pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r h + 1 <= i <= r` **and** `c (r i) <= j <= c + (r i)`. Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells. Given a **0indexed** `m x n` binary matrix `grid` representing the farmland, return _the **total number** of pyramidal and inverse pyramidal plots that can be found in_ `grid`. **Example 1:** **Input:** grid = [[0,1,1,0],[1,1,1,1]] **Output:** 2 **Explanation:** The 2 possible pyramidal plots are shown in blue and red respectively. There are no inverse pyramidal plots in this grid. Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2. **Example 2:** **Input:** grid = [[1,1,1],[1,1,1]] **Output:** 2 **Explanation:** The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. Hence the total number of plots is 1 + 1 = 2. **Example 3:** **Input:** grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]] **Output:** 13 **Explanation:** There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures. There are 6 inverse pyramidal plots, 2 of which are shown in the last figure. The total number of plots is 7 + 6 = 13. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 1000` * `1 <= m * n <= 105` * `grid[i][j]` is either `0` or `1`.","completion":"def min_time_to_type(word: str) -> int: time, prev = 0, 0 for c in word: pos = ord(c) - ord(\'a\') time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1 prev = pos return time"},{"prompt":"You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`. You start your journey from building `0` and move to the next building by possibly using bricks or ladders. While moving from building `i` to building `i+1` (**0indexed**), * If the current building\'s height is **greater than or equal** to the next building\'s height, you do **not** need a ladder or bricks. * If the current building\'s height is **less than** the next building\'s height, you can either use **one ladder** or `(h[i+1] h[i])` **bricks**. _Return the furthest building index (0indexed) you can reach if you use the given ladders and bricks optimally._ **Example 1:** **Input:** heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 **Output:** 4 **Explanation:** Starting at building 0, you can follow these steps: Go to building 1 without using ladders nor bricks since 4 >= 2. Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7. Go to building 3 without using ladders nor bricks since 7 >= 6. Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9. It is impossible to go beyond building 4 because you do not have any more bricks or ladders. **Example 2:** **Input:** heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 **Output:** 7 **Example 3:** **Input:** heights = [14,3,19,3], bricks = 17, ladders = 0 **Output:** 3 **Constraints:** * `1 <= heights.length <= 105` * `1 <= heights[i] <= 106` * `0 <= bricks <= 109` * `0 <= ladders <= heights.length`","completion":"def maxWaterBottles(numBottles: int, numExchange: int) -> int: total = numBottles while numBottles >= numExchange: newBottles = numBottles // numExchange total += newBottles numBottles = newBottles + numBottles % numExchange return total"},{"prompt":"You are given a **0indexed** integer array `nums`. Rearrange the values of `nums` according to the following rules: 1. Sort the values at **odd indices** of `nums` in **nonincreasing** order. * For example, if `nums = [4,**1**,2,**3**]` before this step, it becomes `[4,**3**,2,**1**]` after. The values at odd indices `1` and `3` are sorted in nonincreasing order. 2. Sort the values at **even indices** of `nums` in **nondecreasing** order. * For example, if `nums = [**4**,1,**2**,3]` before this step, it becomes `[**2**,1,**4**,3]` after. The values at even indices `0` and `2` are sorted in nondecreasing order. Return _the array formed after rearranging the values of_ `nums`. **Example 1:** **Input:** nums = [4,1,2,3] **Output:** [2,3,4,1] **Explanation:** First, we sort the values present at odd indices (1 and 3) in nonincreasing order. So, nums changes from [4,**1**,2,**3**] to [4,**3**,2,**1**]. Next, we sort the values present at even indices (0 and 2) in nondecreasing order. So, nums changes from [**4**,1,**2**,3] to [**2**,3,**4**,1]. Thus, the array formed after rearranging the values is [2,3,4,1]. **Example 2:** **Input:** nums = [2,1] **Output:** [2,1] **Explanation:** Since there is exactly one odd index and one even index, no rearrangement of values takes place. The resultant array formed is [2,1], which is the same as the initial array. **Constraints:** * `1 <= nums.length <= 100` * `1 <= nums[i] <= 100`","completion":"def maxValue(events): events.sort(key=lambda a: a[1]) dp = [0] * len(events) dp[0] = events[0][2] for i in range(1, len(events)): lastNonConflict = -1 for j in range(i - 1, -1, -1): if events[j][1] < events[i][0]: lastNonConflict = j break includedValue = events[i][2] if lastNonConflict != -1: includedValue += dp[lastNonConflict] dp[i] = max(includedValue, dp[i - 1]) return dp[-1]"},{"prompt":"You are given a **directed** graph of `n` nodes numbered from `0` to `n 1`, where each node has **at most one** outgoing edge. The graph is represented with a given **0indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == 1`. You are also given two integers `node1` and `node2`. Return _the **index** of the node that can be reached from both_ `node1` _and_ `node2`_, such that the **maximum** between the distance from_ `node1` _to that node, and from_ `node2` _to that node is **minimized**_. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `1`. Note that `edges` may contain cycles. **Example 1:** **Input:** edges = [2,2,3,1], node1 = 0, node2 = 1 **Output:** 2 **Explanation:** The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1. The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2. **Example 2:** **Input:** edges = [1,2,1], node1 = 0, node2 = 2 **Output:** 2 **Explanation:** The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0. The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2. **Constraints:** * `n == edges.length` * `2 <= n <= 105` * `1 <= edges[i] < n` * `edges[i] != i` * `0 <= node1, node2 < n`","completion":"def get_index_with_min_max_distance(edges, node1, node2): dist1 = [-1] * len(edges) dist2 = [-1] * len(edges) dist1[node1] = 0 dist2[node2] = 0 for i in range(len(edges)): if dist1[i] != -1 and edges[i] != -1: if dist1[edges[i]] == -1: dist1[edges[i]] = dist1[i] + 1 else: dist1[edges[i]] = min(dist1[edges[i]], dist1[i] + 1) if dist2[i] != -1 and edges[i] != -1: if dist2[edges[i]] == -1: dist2[edges[i]] = dist2[i] + 1 else: dist2[edges[i]] = min(dist2[edges[i]], dist2[i] + 1) ans = -1 min_max_dist = float(\\"inf\\") for i in range(len(edges)): if dist1[i] != -1 and dist2[i] != -1: max_dist = max(dist1[i], dist2[i]) if max_dist < min_max_dist: min_max_dist = max_dist ans = i return ans"},{"prompt":"Given a binary array `nums`, you should delete one element from it. Return _the size of the longest nonempty subarray containing only_ `1`_\'s in the resulting array_. Return `0` if there is no such subarray. **Example 1:** **Input:** nums = [1,1,0,1] **Output:** 3 **Explanation:** After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1\'s. **Example 2:** **Input:** nums = [0,1,1,1,0,1,1,0,1] **Output:** 5 **Explanation:** After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1\'s is [1,1,1,1,1]. **Example 3:** **Input:** nums = [1,1,1] **Output:** 2 **Explanation:** You must delete one element. **Constraints:** * `1 <= nums.length <= 105` * `nums[i]` is either `0` or `1`.","completion":"from collections import defaultdict def frogPosition(n, edges, t, target): graph = defaultdict(list) for edge in edges: graph[edge[0]].append(edge[1]) graph[edge[1]].append(edge[0]) return dfs(1, -1, t, target, graph) def dfs(node, parent, t, target, graph): if t == 0: return 1.0 if node == target else 0.0 probability = 0.0 for neighbor in graph[node]: if neighbor != parent: probability += dfs(neighbor, node, t - 1, target, graph) return probability / (len(graph[node]) - (0 if parent == -1 else 1))"},{"prompt":"**Reversing** an integer means to reverse all its digits. * For example, reversing `2021` gives `1202`. Reversing `12300` gives `321` as the **leading zeros are not retained**. Given an integer `num`, **reverse** `num` to get `reversed1`, **then reverse** `reversed1` to get `reversed2`. Return `true` _if_ `reversed2` _equals_ `num`. Otherwise return `false`. **Example 1:** **Input:** num = 526 **Output:** true **Explanation:** Reverse num to get 625, then reverse 625 to get 526, which equals num. **Example 2:** **Input:** num = 1800 **Output:** false **Explanation:** Reverse num to get 81, then reverse 81 to get 18, which does not equal num. **Example 3:** **Input:** num = 0 **Output:** true **Explanation:** Reverse num to get 0, then reverse 0 to get 0, which equals num. **Constraints:** * `0 <= num <= 106`","completion":"def minOperations(nums): nums = sorted(set(nums)) n = len(nums) ans = n for i in range(n): j = 0 while j < n and nums[j] <= nums[i] + n - 1: j += 1 ans = min(ans, n - (j - i)) return ans"},{"prompt":"There are `n` rooms you need to visit, labeled from `0` to `n 1`. Each day is labeled, starting from `0`. You will go in and visit one room a day. Initially on day `0`, you visit room `0`. The **order** you visit the rooms for the coming days is determined by the following **rules** and a given **0indexed** array `nextVisit` of length `n`: * Assuming that on a day, you visit room `i`, * if you have been in room `i` an **odd** number of times (**including** the current visit), on the **next** day you will visit a room with a **lower or equal room number** specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`; * if you have been in room `i` an **even** number of times (**including** the current visit), on the **next** day you will visit room `(i + 1) mod n`. Return _the label of the **first** day where you have been in **all** the rooms_. It can be shown that such a day exists. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** nextVisit = [0,0] **Output:** 2 **Explanation:** On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd. On the next day you will visit room nextVisit[0] = 0 On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even. On the next day you will visit room (0 + 1) mod 2 = 1 On day 2, you visit room 1. This is the first day where you have been in all the rooms. **Example 2:** **Input:** nextVisit = [0,0,2] **Output:** 6 **Explanation:** Your room visiting order for each day is: [0,0,1,0,0,1,2,...]. Day 6 is the first day where you have been in all the rooms. **Example 3:** **Input:** nextVisit = [0,1,2,0] **Output:** 6 **Explanation:** Your room visiting order for each day is: [0,0,1,1,2,2,3,...]. Day 6 is the first day where you have been in all the rooms. **Constraints:** * `n == nextVisit.length` * `2 <= n <= 105` * `0 <= nextVisit[i] <= i`","completion":"def firstDayBeenInAllRooms(nextVisit): n = len(nextVisit) MOD = 10**9 + 7 dp = [0] * n for i in range(1, n): dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD return dp[n - 1]"},{"prompt":"A perfectly straight street is represented by a number line. The street has building(s) on it and is represented by a 2D integer array `buildings`, where `buildings[i] = [starti, endi, heighti]`. This means that there is a building with `heighti` in the **halfclosed segment** `[starti, endi)`. You want to **describe** the heights of the buildings on the street with the **minimum** number of nonoverlapping **segments**. The street can be represented by the 2D integer array `street` where `street[j] = [leftj, rightj, averagej]` describes a **halfclosed segment** `[leftj, rightj)` of the road where the **average** heights of the buildings in the **segment** is `averagej`. * For example, if `buildings = [[1,5,2],[3,10,4]],` the street could be represented by `street = [[1,3,2],[3,5,3],[5,10,4]]` because: * From 1 to 3, there is only the first building with an average height of `2 / 1 = 2`. * From 3 to 5, both the first and the second building are there with an average height of `(2+4) / 2 = 3`. * From 5 to 10, there is only the second building with an average height of `4 / 1 = 4`. Given `buildings`, return _the 2D integer array_ `street` _as described above (**excluding** any areas of the street where there are no buldings). You may return the array in **any order**_. The **average** of `n` elements is the **sum** of the `n` elements divided (**integer division**) by `n`. A **halfclosed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`. **Example 1:** **Input:** buildings = [[1,4,2],[3,9,4]] **Output:** [[1,3,2],[3,4,3],[4,9,4]] **Explanation:** From 1 to 3, there is only the first building with an average height of 2 / 1 = 2. From 3 to 4, both the first and the second building are there with an average height of (2+4) / 2 = 3. From 4 to 9, there is only the second building with an average height of 4 / 1 = 4. **Example 2:** **Input:** buildings = [[1,3,2],[2,5,3],[2,8,3]] **Output:** [[1,3,2],[3,8,3]] **Explanation:** From 1 to 2, there is only the first building with an average height of 2 / 1 = 2. From 2 to 3, all three buildings are there with an average height of (2+3+3) / 3 = 2. From 3 to 5, both the second and the third building are there with an average height of (3+3) / 2 = 3. From 5 to 8, there is only the last building with an average height of 3 / 1 = 3. The average height from 1 to 3 is the same so we can group them into one segment. The average height from 3 to 8 is the same so we can group them into one segment. **Example 3:** **Input:** buildings = [[1,2,1],[5,6,1]] **Output:** [[1,2,1],[5,6,1]] **Explanation:** From 1 to 2, there is only the first building with an average height of 1 / 1 = 1. From 2 to 5, there are no buildings, so it is not included in the output. From 5 to 6, there is only the second building with an average height of 1 / 1 = 1. We cannot group the segments together because an empty space with no buildings seperates the segments. **Constraints:** * `1 <= buildings.length <= 105` * `buildings[i].length == 3` * `0 <= starti < endi <= 108` * `1 <= heighti <= 105`","completion":"def findRotation(mat, target): for _ in range(4): if mat == target: return True n = len(mat) for r in range((n + 1) // 2): for c in range(n // 2): mat[r][c], mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r] = mat[n - 1 - c][r], mat[n - 1 - r][n - 1 - c], mat[c][n - 1 - r], mat[r][c] return False"},{"prompt":"Given an array of string `words`, return _all strings in_ `words` _that is a **substring** of another word_. You can return the answer in **any order**. A **substring** is a contiguous sequence of characters within a string **Example 1:** **Input:** words = [ mass , as , hero , superhero ] **Output:** [ as , hero ] **Explanation:** as is substring of mass and hero is substring of superhero . [ hero , as ] is also a valid answer. **Example 2:** **Input:** words = [ leetcode , et , code ] **Output:** [ et , code ] **Explanation:** et , code are substring of leetcode . **Example 3:** **Input:** words = [ blue , green , bu ] **Output:** [] **Explanation:** No string of words is substring of another string. **Constraints:** * `1 <= words.length <= 100` * `1 <= words[i].length <= 30` * `words[i]` contains only lowercase English letters. * All the strings of `words` are **unique**.","completion":"import math def smallest_divisor(nums, threshold): left, right = 1, 10**6 while left < right: mid = (left + right) // 2 total = sum(math.ceil(n / mid) for n in nums) if total > threshold: left = mid + 1 else: right = mid return left"},{"prompt":"A **selfdividing number** is a number that is divisible by every digit it contains. * For example, `128` is **a selfdividing number** because `128 % 1 == 0`, `128 % 2 == 0`, and `128 % 8 == 0`. A **selfdividing number** is not allowed to contain the digit zero. Given two integers `left` and `right`, return _a list of all the **selfdividing numbers** in the range_ `[left, right]`. **Example 1:** **Input:** left = 1, right = 22 **Output:** [1,2,3,4,5,6,7,8,9,11,12,15,22] **Example 2:** **Input:** left = 47, right = 85 **Output:** [48,55,66,77] **Constraints:** * `1 <= left <= right <= 104`","completion":"def is_self_dividing(num): n = num while n: digit = n % 10 if digit == 0 or num % digit != 0: return False n //= 10 return True def self_dividing_numbers(left, right): return [i for i in range(left, right+1) if is_self_dividing(i)]"},{"prompt":"You are given two strings order and s. All the characters of `order` are **unique** and were sorted in some custom order previously. Permute the characters of `s` so that they match the order that `order` was sorted. More specifically, if a character `x` occurs before a character `y` in `order`, then `x` should occur before `y` in the permuted string. Return _any permutation of_ `s` _that satisfies this property_. **Example 1:** **Input:** order = cba , s = abcd **Output:** cbad **Explanation:** a , b , c appear in order, so the order of a , b , c should be c , b , and a . Since d does not appear in order, it can be at any position in the returned string. dcba , cdba , cbda are also valid outputs. **Example 2:** **Input:** order = cbafg , s = abcd **Output:** cbad **Constraints:** * `1 <= order.length <= 26` * `1 <= s.length <= 200` * `order` and `s` consist of lowercase English letters. * All the characters of `order` are **unique**.","completion":"def customSortString(order, s): priority = {char: idx for idx, char in enumerate(order)} return \\"\\".join(sorted(s, key=lambda x: priority.get(x, 0)))"},{"prompt":"There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands. The people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n 2, 2n 1)`. Return _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats. **Example 1:** **Input:** row = [0,2,1,3] **Output:** 1 **Explanation:** We only need to swap the second (row[1]) and third (row[2]) person. **Example 2:** **Input:** row = [3,2,0,1] **Output:** 0 **Explanation:** All couples are already seated side by side. **Constraints:** * `2n == row.length` * `2 <= n <= 30` * `n` is even. * `0 <= row[i] < 2n` * All the elements of `row` are **unique**.","completion":"def minSwapsCouples(row): n = len(row) position = [0] * n for i in range(n): position[row[i]] = i swaps = 0 for i in range(0, n, 2): partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1 if row[i + 1] != partner: row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]] position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]] swaps += 1 return swaps"},{"prompt":"You are given an `n x n` integer matrix `grid`. Generate an integer matrix `maxLocal` of size `(n 2) x (n 2)` such that: * `maxLocal[i][j]` is equal to the **largest** value of the `3 x 3` matrix in `grid` centered around row `i + 1` and column `j + 1`. In other words, we want to find the largest value in every contiguous `3 x 3` matrix in `grid`. Return _the generated matrix_. **Example 1:** **Input:** grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] **Output:** [[9,9],[8,6]] **Explanation:** The diagram above shows the original matrix and the generated matrix. Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid. **Example 2:** **Input:** grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] **Output:** [[2,2,2],[2,2,2],[2,2,2]] **Explanation:** Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid. **Constraints:** * `n == grid.length == grid[i].length` * `3 <= n <= 100` * `1 <= grid[i][j] <= 100`","completion":"def largest_matrix(grid): n = len(grid) maxLocal = [[0] * (n - 2) for _ in range(n - 2)] for i in range(1, n - 1): for j in range(1, n - 1): max_val = grid[i - 1][j - 1] for x in range(-1, 2): for y in range(-1, 2): max_val = max(max_val, grid[i + x][j + y]) maxLocal[i - 1][j - 1] = max_val return maxLocal"},{"prompt":"You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell. You are given an `m x n` character matrix, `grid`, of these different types of cells: * `\'*\'` is your location. There is **exactly one** `\'*\'` cell. * `\'#\'` is a food cell. There may be **multiple** food cells. * `\'O\'` is free space, and you can travel through these cells. * `\'X\'` is an obstacle, and you cannot travel through these cells. You can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle. Return _the **length** of the shortest path for you to reach **any** food cell_. If there is no path for you to reach food, return `1`. **Example 1:** **Input:** grid = [[ X , X , X , X , X , X ],[ X , * , O , O , O , X ],[ X , O , O , # , O , X ],[ X , X , X , X , X , X ]] **Output:** 3 **Explanation:** It takes 3 steps to reach the food. **Example 2:** **Input:** grid = [[ X , X , X , X , X ],[ X , * , X , O , X ],[ X , O , X , # , X ],[ X , X , X , X , X ]] **Output:** 1 **Explanation:** It is not possible to reach the food. **Example 3:** **Input:** grid = [[ X , X , X , X , X , X , X , X ],[ X , * , O , X , O , # , O , X ],[ X , O , O , X , O , O , X , X ],[ X , O , O , O , O , # , O , X ],[ X , X , X , X , X , X , X , X ]] **Output:** 6 **Explanation:** There can be multiple food cells. It only takes 6 steps to reach the bottom food. **Constraints:** * `m == grid.length` * `n == grid[i].length` * `1 <= m, n <= 200` * `grid[row][col]` is `\'*\'`, `\'X\'`, `\'O\'`, or `\'#\'`. * The `grid` contains **exactly one** `\'*\'`.","completion":"def find_special_integer(nums): for x in range(1, len(nums) + 1): count = sum(1 for num in nums if num >= x) if count == x: return x return -1"},{"prompt":"You are given two string arrays, `queries` and `dictionary`. All words in each array comprise of lowercase English letters and have the same length. In one **edit** you can take a word from `queries`, and change any letter in it to any other letter. Find all words from `queries` that, after a **maximum** of two edits, equal some word from `dictionary`. Return _a list of all words from_ `queries`_,_ _that match with some word from_ `dictionary` _after a maximum of **two edits**_. Return the words in the **same order** they appear in `queries`. **Example 1:** **Input:** queries = [ word , note , ants , wood ], dictionary = [ wood , joke , moat ] **Output:** [ word , note , wood ] **Explanation:** Changing the \'r\' in word to \'o\' allows it to equal the dictionary word wood . Changing the \'n\' to \'j\' and the \'t\' to \'k\' in note changes it to joke . It would take more than 2 edits for ants to equal a dictionary word. wood can remain unchanged (0 edits) and match the corresponding dictionary word. Thus, we return [ word , note , wood ]. **Example 2:** **Input:** queries = [ yes ], dictionary = [ not ] **Output:** [] **Explanation:** Applying any two edits to yes cannot make it equal to not . Thus, we return an empty array. **Constraints:** * `1 <= queries.length, dictionary.length <= 100` * `n == queries[i].length == dictionary[j].length` * `1 <= n <= 100` * All `queries[i]` and `dictionary[j]` are composed of lowercase English letters.","completion":"def count_differences(a, b): return sum(c1 != c2 for c1, c2 in zip(a, b)) def find_matching_words(queries, dictionary): result = [] for query in queries: for dict_word in dictionary: if count_differences(query, dict_word) <= 2: result.append(query) break return result"},{"prompt":"Given a positive integer `n`, find the **pivot integer** `x` such that: * The sum of all elements between `1` and `x` inclusively equals the sum of all elements between `x` and `n` inclusively. Return _the pivot integer_ `x`. If no such integer exists, return `1`. It is guaranteed that there will be at most one pivot index for the given input. **Example 1:** **Input:** n = 8 **Output:** 6 **Explanation:** 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21. **Example 2:** **Input:** n = 1 **Output:** 1 **Explanation:** 1 is the pivot integer since: 1 = 1. **Example 3:** **Input:** n = 4 **Output:** 1 **Explanation:** It can be proved that no such integer exist. **Constraints:** * `1 <= n <= 1000`","completion":"def find_pivot(n: int) -> int: total = n * (n + 1) // 2 left_sum = 0 for x in range(1, n + 1): left_sum += x if 2 * left_sum == total: return x return -1"},{"prompt":"A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits `s` and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array. Given the string `s` and the integer `k`, return _the number of the possible arrays that can be printed as_ `s` _using the mentioned program_. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** **Input:** s = 1000 , k = 10000 **Output:** 1 **Explanation:** The only possible array is [1000] **Example 2:** **Input:** s = 1000 , k = 10 **Output:** 0 **Explanation:** There cannot be an array that was printed this way and has all integer >= 1 and <= 10. **Example 3:** **Input:** s = 1317 , k = 2000 **Output:** 8 **Explanation:** Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7] **Constraints:** * `1 <= s.length <= 105` * `s` consists of only digits and does not contain leading zeros. * `1 <= k <= 109`","completion":"def numDecodings(s: str, k: int) -> int: n = len(s) dp = [0] * (n + 1) dp[n] = 1 MOD = 1000000007 for i in range(n - 1, -1, -1): num = 0 for j in range(i, n): num = num * 10 + int(s[j]) if num >= 1 and num <= k: dp[i] = (dp[i] + dp[j + 1]) % MOD if num > k: break return dp[0]"},{"prompt":"Given two binary trees `original` and `cloned` and given a reference to a node `target` in the original tree. The `cloned` tree is a **copy of** the `original` tree. Return _a reference to the same node_ in the `cloned` tree. **Note** that you are **not allowed** to change any of the two trees or the `target` node and the answer **must be** a reference to a node in the `cloned` tree. **Example 1:** **Input:** tree = [7,4,3,null,null,6,19], target = 3 **Output:** 3 **Explanation:** In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree. **Example 2:** **Input:** tree = [7], target = 7 **Output:** 7 **Example 3:** **Input:** tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4 **Output:** 4 **Constraints:** * The number of nodes in the `tree` is in the range `[1, 104]`. * The values of the nodes of the `tree` are unique. * `target` node is a node from the `original` tree and is not `null`.","completion":"def reconstructMatrix(upper, lower, colsum): result = [[0] * len(colsum) for _ in range(2)] for i in range(len(colsum)): if colsum[i] == 2: result[0][i] = 1 result[1][i] = 1 upper -= 1 lower -= 1 elif colsum[i] == 1: if upper > lower: result[0][i] = 1 upper -= 1 else: result[1][i] = 1 lower -= 1 if upper < 0 or lower < 0: return [] if upper > 0 or lower > 0: return [] return result"},{"prompt":"Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size `groupSize`, and consists of `groupSize` consecutive cards. Given an integer array `hand` where `hand[i]` is the value written on the `ith` card and an integer `groupSize`, return `true` if she can rearrange the cards, or `false` otherwise. **Example 1:** **Input:** hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 **Output:** true **Explanation:** Alice\'s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8] **Example 2:** **Input:** hand = [1,2,3,4,5], groupSize = 4 **Output:** false **Explanation:** Alice\'s hand can not be rearranged into groups of 4. **Constraints:** * `1 <= hand.length <= 104` * `0 <= hand[i] <= 109` * `1 <= groupSize <= hand.length` **Note:** This question is the same as 1296: [https://leetcode.com/problems/dividearrayinsetsofkconsecutivenumbers/](https://leetcode.com/problems/dividearrayinsetsofkconsecutivenumbers/)","completion":"from collections import Counter def is_possible_divide(hand, group_size): card_count = Counter(hand) for card in sorted(card_count): if card_count[card] > 0: count = card_count[card] for i in range(1, group_size): if card_count[card + i] < count: return False card_count[card + i] -= count return True"},{"prompt":"Given an integer array `nums`, _find three numbers whose product is maximum and return the maximum product_. **Example 1:** **Input:** nums = [1,2,3] **Output:** 6 **Example 2:** **Input:** nums = [1,2,3,4] **Output:** 24 **Example 3:** **Input:** nums = [1,2,3] **Output:** 6 **Constraints:** * `3 <= nums.length <= 104` * `1000 <= nums[i] <= 1000`","completion":"def maximumProduct(nums): nums.sort() n = len(nums) return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])"},{"prompt":"You have a binary tree with a small defect. There is **exactly one** invalid node where its right child incorrectly points to another node at the **same depth** but to the **invalid node\'s right**. Given the root of the binary tree with this defect, `root`, return _the root of the binary tree after **removing** this invalid node **and every node underneath it** (minus the node it incorrectly points to)._ **Custom testing:** The test input is read as 3 lines: * `TreeNode root` * `int fromNode` (**not available to** `correctBinaryTree`) * `int toNode` (**not available to** `correctBinaryTree`) After the binary tree rooted at `root` is parsed, the `TreeNode` with value of `fromNode` will have its right child pointer pointing to the `TreeNode` with a value of `toNode`. Then, `root` is passed to `correctBinaryTree`. **Example 1:** **Input:** root = [1,2,3], fromNode = 2, toNode = 3 **Output:** [1,null,3] **Explanation:** The node with value 2 is invalid, so remove it. **Example 2:** **Input:** root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4 **Output:** [8,3,1,null,null,9,4,null,null,5,6] **Explanation:** The node with value 7 is invalid, so remove it and the node underneath it, node 2. **Constraints:** * The number of nodes in the tree is in the range `[3, 104]`. * `109 <= Node.val <= 109` * All `Node.val` are **unique**. * `fromNode != toNode` * `fromNode` and `toNode` will exist in the tree and will be on the same depth. * `toNode` is to the **right** of `fromNode`. * `fromNode.right` is `null` in the initial tree from the test data.","completion":"def thousand_separator(n: int) -> str: result = str(n) count = 0 for i in range(len(result) - 1, 0, -1): count += 1 if count % 3 == 0: result = result[:i] + \'.\' + result[i:] return result"},{"prompt":"You have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e., `0 <= i < n`). In one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e., perform `arr[x] =1` and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations. Given an integer `n`, the length of the array, return _the minimum number of operations_ needed to make all the elements of arr equal. **Example 1:** **Input:** n = 3 **Output:** 2 **Explanation:** arr = [1, 3, 5] First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4] In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3]. **Example 2:** **Input:** n = 6 **Output:** 9 **Constraints:** * `1 <= n <= 104`","completion":"def min_operations(n): return n * n // 4"},{"prompt":"You have `n` computers. You are given the integer `n` and a **0indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries. Initially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time. Note that the batteries cannot be recharged. Return _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._ **Example 1:** **Input:** n = 2, batteries = [3,3,3] **Output:** 4 **Explanation:** Initially, insert battery 0 into the first computer and battery 1 into the second computer. After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute. At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead. By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running. We can run the two computers simultaneously for at most 4 minutes, so we return 4. **Example 2:** **Input:** n = 2, batteries = [1,1,1,1] **Output:** 2 **Explanation:** Initially, insert battery 0 into the first computer and battery 2 into the second computer. After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running. We can run the two computers simultaneously for at most 2 minutes, so we return 2. **Constraints:** * `1 <= n <= batteries.length <= 105` * `1 <= batteries[i] <= 109`","completion":"def max_computer_runtime(n, batteries): batteries.sort() result = 0 for i in range(len(batteries)): result = max(result, min(n, len(batteries) - i) * batteries[i]) return result"},{"prompt":"You have a convex `n`sided polygon where each vertex has an integer value. You are given an integer array `values` where `values[i]` is the value of the `ith` vertex (i.e., **clockwise order**). You will **triangulate** the polygon into `n 2` triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all `n 2` triangles in the triangulation. Return _the smallest possible total score that you can achieve with some triangulation of the polygon_. **Example 1:** **Input:** values = [1,2,3] **Output:** 6 **Explanation:** The polygon is already triangulated, and the score of the only triangle is 6. **Example 2:** **Input:** values = [3,7,4,5] **Output:** 144 **Explanation:** There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144. The minimum score is 144. **Example 3:** **Input:** values = [1,3,1,4,1,5] **Output:** 13 **Explanation:** The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13. **Constraints:** * `n == values.length` * `3 <= n <= 50` * `1 <= values[i] <= 100`","completion":"def find_judge(n, trust): trustCounts = [0] * (n + 1) for a, b in trust: trustCounts[a] -= 1 trustCounts[b] += 1 for i in range(1, n + 1): if trustCounts[i] == n - 1: return i return -1"},{"prompt":"You are given a string `s` that contains some bracket pairs, with each pair containing a **nonempty** key. * For example, in the string `(name)is(age)yearsold `, there are **two** bracket pairs that contain the keys `name ` and `age `. You know the values of a wide range of keys. This is represented by a 2D string array `knowledge` where each `knowledge[i] = [keyi, valuei]` indicates that key `keyi` has a value of `valuei`. You are tasked to evaluate **all** of the bracket pairs. When you evaluate a bracket pair that contains some key `keyi`, you will: * Replace `keyi` and the bracket pair with the key\'s corresponding `valuei`. * If you do not know the value of the key, you will replace `keyi` and the bracket pair with a question mark `? ` (without the quotation marks). Each key will appear at most once in your `knowledge`. There will not be any nested brackets in `s`. Return _the resulting string after evaluating **all** of the bracket pairs._ **Example 1:** **Input:** s = (name)is(age)yearsold , knowledge = [[ name , bob ],[ age , two ]] **Output:** bobistwoyearsold **Explanation:** The key name has a value of bob , so replace (name) with bob . The key age has a value of two , so replace (age) with two . **Example 2:** **Input:** s = hi(name) , knowledge = [[ a , b ]] **Output:** hi? **Explanation:** As you do not know the value of the key name , replace (name) with ? . **Example 3:** **Input:** s = (a)(a)(a)aaa , knowledge = [[ a , yes ]] **Output:** yesyesyesaaa **Explanation:** The same key can appear multiple times. The key a has a value of yes , so replace all occurrences of (a) with yes . Notice that the a s not in a bracket pair are not evaluated. **Constraints:** * `1 <= s.length <= 105` * `0 <= knowledge.length <= 105` * `knowledge[i].length == 2` * `1 <= keyi.length, valuei.length <= 10` * `s` consists of lowercase English letters and round brackets `\'(\'` and `\')\'`. * Every open bracket `\'(\'` in `s` will have a corresponding close bracket `\')\'`. * The key in each bracket pair of `s` will be nonempty. * There will not be any nested bracket pairs in `s`. * `keyi` and `valuei` consist of lowercase English letters. * Each `keyi` in `knowledge` is unique.","completion":"def minPartitions(n: str) -> int: max_digit = 0 for c in n: max_digit = max(max_digit, int(c)) if max_digit == 9: break return max_digit"},{"prompt":"Write an API that generates fancy sequences using the `append`, `addAll`, and `multAll` operations. Implement the `Fancy` class: * `Fancy()` Initializes the object with an empty sequence. * `void append(val)` Appends an integer `val` to the end of the sequence. * `void addAll(inc)` Increments all existing values in the sequence by an integer `inc`. * `void multAll(m)` Multiplies all existing values in the sequence by an integer `m`. * `int getIndex(idx)` Gets the current value at index `idx` (0indexed) of the sequence **modulo** `109 + 7`. If the index is greater or equal than the length of the sequence, return `1`. **Example 1:** **Input** [ Fancy , append , addAll , append , multAll , getIndex , addAll , append , multAll , getIndex , getIndex , getIndex ] [[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]] **Output** [null, null, null, null, null, 10, null, null, null, 26, 34, 20] **Explanation** Fancy fancy = new Fancy(); fancy.append(2); // fancy sequence: [2] fancy.addAll(3); // fancy sequence: [2+3] > [5] fancy.append(7); // fancy sequence: [5, 7] fancy.multAll(2); // fancy sequence: [5*2, 7*2] > [10, 14] fancy.getIndex(0); // return 10 fancy.addAll(3); // fancy sequence: [10+3, 14+3] > [13, 17] fancy.append(10); // fancy sequence: [13, 17, 10] fancy.multAll(2); // fancy sequence: [13*2, 17*2, 10*2] > [26, 34, 20] fancy.getIndex(0); // return 26 fancy.getIndex(1); // return 34 fancy.getIndex(2); // return 20 **Constraints:** * `1 <= val, inc, m <= 100` * `0 <= idx <= 105` * At most `105` calls total will be made to `append`, `addAll`, `multAll`, and `getIndex`.","completion":"from collections import deque def findMaxValueOfEquation(points, k): res = -float(\\"inf\\") q = deque() for p in points: while q and p[0] - q[0][1] > k: q.popleft() if q: res = max(res, p[1] + p[0] + q[0][0]) while q and p[1] - p[0] >= q[-1][0]: q.pop() q.append((p[1] - p[0], p[0])) return res"},{"prompt":"Given a `sentence` that consists of some words separated by a **single space**, and a `searchWord`, check if `searchWord` is a prefix of any word in `sentence`. Return _the index of the word in_ `sentence` _(**1indexed**) where_ `searchWord` _is a prefix of this word_. If `searchWord` is a prefix of more than one word, return the index of the first word **(minimum index)**. If there is no such word return `1`. A **prefix** of a string `s` is any leading contiguous substring of `s`. **Example 1:** **Input:** sentence = i love eating burger , searchWord = burg **Output:** 4 **Explanation:** burg is prefix of burger which is the 4th word in the sentence. **Example 2:** **Input:** sentence = this problem is an easy problem , searchWord = pro **Output:** 2 **Explanation:** pro is prefix of problem which is the 2nd and the 6th word in the sentence, but we return 2 as it\'s the minimal index. **Example 3:** **Input:** sentence = i am tired , searchWord = you **Output:** 1 **Explanation:** you is not a prefix of any word in the sentence. **Constraints:** * `1 <= sentence.length <= 100` * `1 <= searchWord.length <= 10` * `sentence` consists of lowercase English letters and spaces. * `searchWord` consists of lowercase English letters.","completion":"def filter_restaurants(restaurants, vegan_friendly, max_price, max_distance): def custom_compare(a, b): if a[1] == b[1]: return b[0] - a[0] return b[1] - a[1] filtered_restaurants = [ r for r in restaurants if (vegan_friendly == 0 or r[2] == vegan_friendly) and r[3] <= max_price and r[4] <= max_distance ] filtered_restaurants.sort(key=lambda r: (r[1], r[0]), reverse=True) return [r[0] for r in filtered_restaurants]"}]'),A={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:C,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.prompt&&e.prompt.toLowerCase().includes(i)||e.completion&&e.completion.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},R={class:"search-container"},Y={class:"card-container"},z={key:0,class:"empty-state"},S=["disabled"],F={key:0},N={key:1};function D(i,e,l,p,r,s){const c=g("PoemCard");return n(),a("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",R,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),b(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[w,r.searchQuery]]),r.searchQuery?(n(),a("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):u("",!0)]),t("div",Y,[(n(!0),a(y,null,x(s.displayedPoems,(o,f)=>(n(),v(c,{key:f,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),a("div",z,' No results found for "'+h(r.searchQuery)+'". ',1)):u("",!0)]),s.hasMorePoems?(n(),a("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[r.isLoading?(n(),a("span",N,"Loading...")):(n(),a("span",F,"See more"))],8,S)):u("",!0)])}const G=m(A,[["render",D],["__scopeId","data-v-dce5ee8a"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/4.md","filePath":"library/4.md"}'),P={name:"library/4.md"},M=Object.assign(P,{setup(i){return(e,l)=>(n(),a("div",null,[_(G)]))}});export{B as __pageData,M as default};
